// Package worker provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package worker

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"autoteam/internal/types"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for GetLogsParamsRole.
const (
	Both      GetLogsParamsRole = "both"
	Collector GetLogsParamsRole = "collector"
	Executor  GetLogsParamsRole = "executor"
)

// ConfigResponse defines model for ConfigResponse.
type ConfigResponse = types.ConfigResponse

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse = types.ErrorResponse

// FlowInfo defines model for FlowInfo.
type FlowInfo = types.FlowInfo

// FlowResponse defines model for FlowResponse.
type FlowResponse = types.FlowResponse

// FlowStepInfo defines model for FlowStepInfo.
type FlowStepInfo = types.FlowStepInfo

// FlowStepsResponse defines model for FlowStepsResponse.
type FlowStepsResponse = types.FlowStepsResponse

// HealthCheck defines model for HealthCheck.
type HealthCheck = types.HealthCheck

// HealthResponse defines model for HealthResponse.
type HealthResponse = types.HealthResponse

// LogFile defines model for LogFile.
type LogFile = types.LogFile

// LogsResponse defines model for LogsResponse.
type LogsResponse = types.LogsResponse

// MetricsResponse defines model for MetricsResponse.
type MetricsResponse = types.MetricsResponse

// StatusResponse defines model for StatusResponse.
type StatusResponse = types.StatusResponse

// WorkerConfig Sanitized worker configuration
type WorkerConfig = types.WorkerConfig

// WorkerInfo defines model for WorkerInfo.
type WorkerInfo = types.WorkerInfo

// WorkerMetrics defines model for WorkerMetrics.
type WorkerMetrics = types.WorkerMetrics

// GetLogsParams defines parameters for GetLogs.
type GetLogsParams struct {
	// Role Filter logs by role (collector, executor, both) - auto-determined from file paths and names
	Role *GetLogsParamsRole `form:"role,omitempty" json:"role,omitempty"`

	// Limit Maximum number of log files to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetLogsParamsRole defines parameters for GetLogs.
type GetLogsParamsRole string

// GetLogFileParams defines parameters for GetLogFile.
type GetLogFileParams struct {
	// Tail Number of last lines to return (tail behavior)
	Tail *int `form:"tail,omitempty" json:"tail,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Worker configuration
	// (GET /config)
	GetConfig(ctx echo.Context) error
	// API documentation
	// (GET /docs/)
	GetSwaggerUI(ctx echo.Context) error
	// Worker flow configuration
	// (GET /flow)
	GetFlow(ctx echo.Context) error
	// Flow step details
	// (GET /flow/steps)
	GetFlowSteps(ctx echo.Context) error
	// Worker health check
	// (GET /health)
	GetHealth(ctx echo.Context) error
	// List worker logs
	// (GET /logs)
	GetLogs(ctx echo.Context, params GetLogsParams) error
	// Download log file
	// (GET /logs/{filename})
	GetLogFile(ctx echo.Context, filename string, params GetLogFileParams) error
	// Worker metrics
	// (GET /metrics)
	GetMetrics(ctx echo.Context) error
	// OpenAPI specification
	// (GET /openapi.yaml)
	GetOpenAPISpec(ctx echo.Context) error
	// Worker status
	// (GET /status)
	GetStatus(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetConfig(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetConfig(ctx)
	return err
}

// GetSwaggerUI converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwaggerUI(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSwaggerUI(ctx)
	return err
}

// GetFlow converts echo context to params.
func (w *ServerInterfaceWrapper) GetFlow(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFlow(ctx)
	return err
}

// GetFlowSteps converts echo context to params.
func (w *ServerInterfaceWrapper) GetFlowSteps(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFlowSteps(ctx)
	return err
}

// GetHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealth(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetHealth(ctx)
	return err
}

// GetLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetLogs(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLogsParams
	// ------------- Optional query parameter "role" -------------

	err = runtime.BindQueryParameter("form", true, false, "role", ctx.QueryParams(), &params.Role)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter role: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLogs(ctx, params)
	return err
}

// GetLogFile converts echo context to params.
func (w *ServerInterfaceWrapper) GetLogFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "filename" -------------
	var filename string

	err = runtime.BindStyledParameterWithOptions("simple", "filename", ctx.Param("filename"), &filename, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filename: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLogFileParams
	// ------------- Optional query parameter "tail" -------------

	err = runtime.BindQueryParameter("form", true, false, "tail", ctx.QueryParams(), &params.Tail)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tail: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLogFile(ctx, filename, params)
	return err
}

// GetMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) GetMetrics(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMetrics(ctx)
	return err
}

// GetOpenAPISpec converts echo context to params.
func (w *ServerInterfaceWrapper) GetOpenAPISpec(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOpenAPISpec(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/config", wrapper.GetConfig)
	router.GET(baseURL+"/docs/", wrapper.GetSwaggerUI)
	router.GET(baseURL+"/flow", wrapper.GetFlow)
	router.GET(baseURL+"/flow/steps", wrapper.GetFlowSteps)
	router.GET(baseURL+"/health", wrapper.GetHealth)
	router.GET(baseURL+"/logs", wrapper.GetLogs)
	router.GET(baseURL+"/logs/:filename", wrapper.GetLogFile)
	router.GET(baseURL+"/metrics", wrapper.GetMetrics)
	router.GET(baseURL+"/openapi.yaml", wrapper.GetOpenAPISpec)
	router.GET(baseURL+"/status", wrapper.GetStatus)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AwAA//93xmU3PDYAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
