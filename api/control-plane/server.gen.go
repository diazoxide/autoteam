// Package controlplane provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package controlplane

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"autoteam/internal/types"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for ControlPlaneHealthResponseStatus.
const (
	ControlPlaneHealthResponseStatusDegraded  ControlPlaneHealthResponseStatus = "degraded"
	ControlPlaneHealthResponseStatusHealthy   ControlPlaneHealthResponseStatus = "healthy"
	ControlPlaneHealthResponseStatusUnhealthy ControlPlaneHealthResponseStatus = "unhealthy"
)

// Defines values for ControlPlaneHealthResponseWorkersHealth.
const (
	ControlPlaneHealthResponseWorkersHealthHealthy     ControlPlaneHealthResponseWorkersHealth = "healthy"
	ControlPlaneHealthResponseWorkersHealthUnhealthy   ControlPlaneHealthResponseWorkersHealth = "unhealthy"
	ControlPlaneHealthResponseWorkersHealthUnreachable ControlPlaneHealthResponseWorkersHealth = "unreachable"
)

// Defines values for WorkerDetailsStatus.
const (
	Reachable   WorkerDetailsStatus = "reachable"
	Unknown     WorkerDetailsStatus = "unknown"
	Unreachable WorkerDetailsStatus = "unreachable"
)

// Defines values for GetWorkerLogsParamsRole.
const (
	Both      GetWorkerLogsParamsRole = "both"
	Collector GetWorkerLogsParamsRole = "collector"
	Executor  GetWorkerLogsParamsRole = "executor"
)

// ConfigResponse defines model for ConfigResponse.
type ConfigResponse = types.ConfigResponse

// ControlPlaneHealthResponse defines model for ControlPlaneHealthResponse.
type ControlPlaneHealthResponse struct {
	// Message Additional health information
	Message *string `json:"message,omitempty"`

	// Status Overall control plane health status
	Status ControlPlaneHealthResponseStatus `json:"status"`

	// Timestamp Health check timestamp
	Timestamp time.Time `json:"timestamp"`

	// WorkersHealth Health status of each configured worker
	WorkersHealth map[string]ControlPlaneHealthResponseWorkersHealth `json:"workers_health"`
}

// ControlPlaneHealthResponseStatus Overall control plane health status
type ControlPlaneHealthResponseStatus string

// ControlPlaneHealthResponseWorkersHealth defines model for ControlPlaneHealthResponse.WorkersHealth.
type ControlPlaneHealthResponseWorkersHealth string

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse = types.ErrorResponse

// FlowInfo defines model for FlowInfo.
type FlowInfo = types.FlowInfo

// FlowResponse defines model for FlowResponse.
type FlowResponse = types.FlowResponse

// FlowStepInfo defines model for FlowStepInfo.
type FlowStepInfo = types.FlowStepInfo

// FlowStepsResponse defines model for FlowStepsResponse.
type FlowStepsResponse = types.FlowStepsResponse

// HealthCheck defines model for HealthCheck.
type HealthCheck = types.HealthCheck

// HealthResponse defines model for HealthResponse.
type HealthResponse = types.HealthResponse

// LogFile defines model for LogFile.
type LogFile = types.LogFile

// LogsResponse defines model for LogsResponse.
type LogsResponse = types.LogsResponse

// MetricsResponse defines model for MetricsResponse.
type MetricsResponse = types.MetricsResponse

// StatusResponse defines model for StatusResponse.
type StatusResponse = types.StatusResponse

// WorkerConfig Sanitized worker configuration
type WorkerConfig = types.WorkerConfig

// WorkerDetails defines model for WorkerDetails.
type WorkerDetails struct {
	// Id Worker ID from configuration
	Id string `json:"id"`

	// LastCheck Last health check timestamp
	LastCheck *time.Time `json:"last_check,omitempty"`

	// Status Worker connectivity status
	Status WorkerDetailsStatus `json:"status"`

	// Url Worker API URL
	Url        string      `json:"url"`
	WorkerInfo *WorkerInfo `json:"worker_info,omitempty"`
}

// WorkerDetailsStatus Worker connectivity status
type WorkerDetailsStatus string

// WorkerDetailsResponse defines model for WorkerDetailsResponse.
type WorkerDetailsResponse struct {
	// Timestamp Response timestamp
	Timestamp time.Time     `json:"timestamp"`
	Worker    WorkerDetails `json:"worker"`
}

// WorkerInfo defines model for WorkerInfo.
type WorkerInfo = types.WorkerInfo

// WorkerMetrics defines model for WorkerMetrics.
type WorkerMetrics = types.WorkerMetrics

// WorkersResponse defines model for WorkersResponse.
type WorkersResponse struct {
	// Timestamp Response timestamp
	Timestamp time.Time `json:"timestamp"`

	// Total Total number of configured workers
	Total   int             `json:"total"`
	Workers []WorkerDetails `json:"workers"`
}

// GetWorkerLogsParams defines parameters for GetWorkerLogs.
type GetWorkerLogsParams struct {
	// Role Filter logs by role (collector, executor, both)
	Role *GetWorkerLogsParamsRole `form:"role,omitempty" json:"role,omitempty"`

	// Limit Maximum number of log files to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetWorkerLogsParamsRole defines parameters for GetWorkerLogs.
type GetWorkerLogsParamsRole string

// GetWorkerLogFileParams defines parameters for GetWorkerLogFile.
type GetWorkerLogFileParams struct {
	// Tail Number of last lines to return
	Tail *int `form:"tail,omitempty" json:"tail,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// API documentation
	// (GET /docs/)
	GetSwaggerUI(ctx echo.Context) error
	// Control plane health check
	// (GET /health)
	GetHealth(ctx echo.Context) error
	// OpenAPI specification
	// (GET /openapi.yaml)
	GetOpenAPISpec(ctx echo.Context) error
	// List workers
	// (GET /workers)
	GetWorkers(ctx echo.Context) error
	// Get worker details
	// (GET /workers/{worker_id})
	GetWorker(ctx echo.Context, workerId string) error
	// Worker configuration
	// (GET /workers/{worker_id}/config)
	GetWorkerConfig(ctx echo.Context, workerId string) error
	// Worker flow configuration
	// (GET /workers/{worker_id}/flow)
	GetWorkerFlow(ctx echo.Context, workerId string) error
	// Worker flow steps
	// (GET /workers/{worker_id}/flow/steps)
	GetWorkerFlowSteps(ctx echo.Context, workerId string) error
	// Worker health check
	// (GET /workers/{worker_id}/health)
	GetWorkerHealth(ctx echo.Context, workerId string) error
	// Worker logs
	// (GET /workers/{worker_id}/logs)
	GetWorkerLogs(ctx echo.Context, workerId string, params GetWorkerLogsParams) error
	// Worker log file
	// (GET /workers/{worker_id}/logs/{filename})
	GetWorkerLogFile(ctx echo.Context, workerId string, filename string, params GetWorkerLogFileParams) error
	// Worker metrics
	// (GET /workers/{worker_id}/metrics)
	GetWorkerMetrics(ctx echo.Context, workerId string) error
	// Worker status
	// (GET /workers/{worker_id}/status)
	GetWorkerStatus(ctx echo.Context, workerId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetSwaggerUI converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwaggerUI(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSwaggerUI(ctx)
	return err
}

// GetHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealth(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetHealth(ctx)
	return err
}

// GetOpenAPISpec converts echo context to params.
func (w *ServerInterfaceWrapper) GetOpenAPISpec(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOpenAPISpec(ctx)
	return err
}

// GetWorkers converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkers(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkers(ctx)
	return err
}

// GetWorker converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorker(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorker(ctx, workerId)
	return err
}

// GetWorkerConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkerConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkerConfig(ctx, workerId)
	return err
}

// GetWorkerFlow converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkerFlow(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkerFlow(ctx, workerId)
	return err
}

// GetWorkerFlowSteps converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkerFlowSteps(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkerFlowSteps(ctx, workerId)
	return err
}

// GetWorkerHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkerHealth(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkerHealth(ctx, workerId)
	return err
}

// GetWorkerLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkerLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWorkerLogsParams
	// ------------- Optional query parameter "role" -------------

	err = runtime.BindQueryParameter("form", true, false, "role", ctx.QueryParams(), &params.Role)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter role: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkerLogs(ctx, workerId, params)
	return err
}

// GetWorkerLogFile converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkerLogFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	// ------------- Path parameter "filename" -------------
	var filename string

	err = runtime.BindStyledParameterWithOptions("simple", "filename", ctx.Param("filename"), &filename, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filename: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWorkerLogFileParams
	// ------------- Optional query parameter "tail" -------------

	err = runtime.BindQueryParameter("form", true, false, "tail", ctx.QueryParams(), &params.Tail)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tail: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkerLogFile(ctx, workerId, filename, params)
	return err
}

// GetWorkerMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkerMetrics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkerMetrics(ctx, workerId)
	return err
}

// GetWorkerStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkerStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkerStatus(ctx, workerId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/docs/", wrapper.GetSwaggerUI)
	router.GET(baseURL+"/health", wrapper.GetHealth)
	router.GET(baseURL+"/openapi.yaml", wrapper.GetOpenAPISpec)
	router.GET(baseURL+"/workers", wrapper.GetWorkers)
	router.GET(baseURL+"/workers/:worker_id", wrapper.GetWorker)
	router.GET(baseURL+"/workers/:worker_id/config", wrapper.GetWorkerConfig)
	router.GET(baseURL+"/workers/:worker_id/flow", wrapper.GetWorkerFlow)
	router.GET(baseURL+"/workers/:worker_id/flow/steps", wrapper.GetWorkerFlowSteps)
	router.GET(baseURL+"/workers/:worker_id/health", wrapper.GetWorkerHealth)
	router.GET(baseURL+"/workers/:worker_id/logs", wrapper.GetWorkerLogs)
	router.GET(baseURL+"/workers/:worker_id/logs/:filename", wrapper.GetWorkerLogFile)
	router.GET(baseURL+"/workers/:worker_id/metrics", wrapper.GetWorkerMetrics)
	router.GET(baseURL+"/workers/:worker_id/status", wrapper.GetWorkerStatus)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
