// Package controlplane provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package controlplane

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"autoteam/internal/types"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for ControlPlaneHealthResponseStatus.
const (
	ControlPlaneHealthResponseStatusDegraded  ControlPlaneHealthResponseStatus = "degraded"
	ControlPlaneHealthResponseStatusHealthy   ControlPlaneHealthResponseStatus = "healthy"
	ControlPlaneHealthResponseStatusUnhealthy ControlPlaneHealthResponseStatus = "unhealthy"
)

// Defines values for ControlPlaneHealthResponseWorkersHealth.
const (
	ControlPlaneHealthResponseWorkersHealthHealthy     ControlPlaneHealthResponseWorkersHealth = "healthy"
	ControlPlaneHealthResponseWorkersHealthUnhealthy   ControlPlaneHealthResponseWorkersHealth = "unhealthy"
	ControlPlaneHealthResponseWorkersHealthUnreachable ControlPlaneHealthResponseWorkersHealth = "unreachable"
)

// Defines values for RetryConfigBackoff.
const (
	Exponential RetryConfigBackoff = "exponential"
	Fixed       RetryConfigBackoff = "fixed"
	Linear      RetryConfigBackoff = "linear"
)

// Defines values for WorkerDetailsStatus.
const (
	Reachable   WorkerDetailsStatus = "reachable"
	Unknown     WorkerDetailsStatus = "unknown"
	Unreachable WorkerDetailsStatus = "unreachable"
)

// Defines values for GetWorkerLogsParamsRole.
const (
	Both      GetWorkerLogsParamsRole = "both"
	Collector GetWorkerLogsParamsRole = "collector"
	Executor  GetWorkerLogsParamsRole = "executor"
)

// ConfigResponse defines model for ConfigResponse.
type ConfigResponse = types.ConfigResponse

// ControlPlaneHealthResponse defines model for ControlPlaneHealthResponse.
type ControlPlaneHealthResponse struct {
	// Message Additional health information
	Message *string `json:"message,omitempty"`

	// Status Overall control plane health status
	Status ControlPlaneHealthResponseStatus `json:"status"`

	// Timestamp Health check timestamp
	Timestamp time.Time `json:"timestamp"`

	// WorkersHealth Health status of each configured worker
	WorkersHealth map[string]ControlPlaneHealthResponseWorkersHealth `json:"workers_health"`
}

// ControlPlaneHealthResponseStatus Overall control plane health status
type ControlPlaneHealthResponseStatus string

// ControlPlaneHealthResponseWorkersHealth defines model for ControlPlaneHealthResponse.WorkersHealth.
type ControlPlaneHealthResponseWorkersHealth string

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse = types.ErrorResponse

// FlowInfo defines model for FlowInfo.
type FlowInfo = types.FlowInfo

// FlowResponse defines model for FlowResponse.
type FlowResponse = types.FlowResponse

// FlowStepInfo defines model for FlowStepInfo.
type FlowStepInfo = types.FlowStepInfo

// FlowStepsResponse defines model for FlowStepsResponse.
type FlowStepsResponse = types.FlowStepsResponse

// HealthCheck defines model for HealthCheck.
type HealthCheck = types.HealthCheck

// HealthResponse defines model for HealthResponse.
type HealthResponse = types.HealthResponse

// LogFile defines model for LogFile.
type LogFile = types.LogFile

// LogsResponse defines model for LogsResponse.
type LogsResponse = types.LogsResponse

// MetricsResponse defines model for MetricsResponse.
type MetricsResponse = types.MetricsResponse

// RetryConfig Configuration for retry behavior
type RetryConfig struct {
	// Backoff Backoff strategy for retry delays
	Backoff *RetryConfigBackoff `json:"backoff,omitempty"`

	// Delay Initial delay between retries in seconds
	Delay *int `json:"delay,omitempty"`

	// MaxAttempts Maximum number of retry attempts
	MaxAttempts *int `json:"max_attempts,omitempty"`

	// MaxDelay Maximum delay between retries in seconds
	MaxDelay *int `json:"max_delay,omitempty"`
}

// RetryConfigBackoff Backoff strategy for retry delays
type RetryConfigBackoff string

// StatusResponse defines model for StatusResponse.
type StatusResponse = types.StatusResponse

// WorkerConfig Sanitized worker configuration
type WorkerConfig = types.WorkerConfig

// WorkerDetails defines model for WorkerDetails.
type WorkerDetails struct {
	// Id Worker ID from configuration
	Id string `json:"id"`

	// LastCheck Last health check timestamp
	LastCheck *time.Time `json:"last_check,omitempty"`

	// Status Worker connectivity status
	Status WorkerDetailsStatus `json:"status"`

	// Url Worker API URL
	Url        string      `json:"url"`
	WorkerInfo *WorkerInfo `json:"worker_info,omitempty"`
}

// WorkerDetailsStatus Worker connectivity status
type WorkerDetailsStatus string

// WorkerDetailsResponse defines model for WorkerDetailsResponse.
type WorkerDetailsResponse struct {
	// Timestamp Response timestamp
	Timestamp time.Time     `json:"timestamp"`
	Worker    WorkerDetails `json:"worker"`
}

// WorkerInfo defines model for WorkerInfo.
type WorkerInfo = types.WorkerInfo

// WorkerMetrics defines model for WorkerMetrics.
type WorkerMetrics = types.WorkerMetrics

// WorkersResponse defines model for WorkersResponse.
type WorkersResponse struct {
	// Timestamp Response timestamp
	Timestamp time.Time `json:"timestamp"`

	// Total Total number of configured workers
	Total   int             `json:"total"`
	Workers []WorkerDetails `json:"workers"`
}

// GetWorkerLogsParams defines parameters for GetWorkerLogs.
type GetWorkerLogsParams struct {
	// Role Filter logs by role (collector, executor, both)
	Role *GetWorkerLogsParamsRole `form:"role,omitempty" json:"role,omitempty"`

	// Limit Maximum number of log files to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetWorkerLogsParamsRole defines parameters for GetWorkerLogs.
type GetWorkerLogsParamsRole string

// GetWorkerLogFileParams defines parameters for GetWorkerLogFile.
type GetWorkerLogFileParams struct {
	// Tail Number of last lines to return
	Tail *int `form:"tail,omitempty" json:"tail,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// API documentation
	// (GET /docs/)
	GetSwaggerUI(ctx echo.Context) error
	// Control plane health check
	// (GET /health)
	GetHealth(ctx echo.Context) error
	// OpenAPI specification
	// (GET /openapi.yaml)
	GetOpenAPISpec(ctx echo.Context) error
	// List workers
	// (GET /workers)
	GetWorkers(ctx echo.Context) error
	// Get worker details
	// (GET /workers/{worker_id})
	GetWorker(ctx echo.Context, workerId string) error
	// Worker configuration
	// (GET /workers/{worker_id}/config)
	GetWorkerConfig(ctx echo.Context, workerId string) error
	// Worker flow configuration
	// (GET /workers/{worker_id}/flow)
	GetWorkerFlow(ctx echo.Context, workerId string) error
	// Worker flow steps
	// (GET /workers/{worker_id}/flow/steps)
	GetWorkerFlowSteps(ctx echo.Context, workerId string) error
	// Worker health check
	// (GET /workers/{worker_id}/health)
	GetWorkerHealth(ctx echo.Context, workerId string) error
	// Worker logs
	// (GET /workers/{worker_id}/logs)
	GetWorkerLogs(ctx echo.Context, workerId string, params GetWorkerLogsParams) error
	// Worker log file
	// (GET /workers/{worker_id}/logs/{filename})
	GetWorkerLogFile(ctx echo.Context, workerId string, filename string, params GetWorkerLogFileParams) error
	// Worker metrics
	// (GET /workers/{worker_id}/metrics)
	GetWorkerMetrics(ctx echo.Context, workerId string) error
	// Worker status
	// (GET /workers/{worker_id}/status)
	GetWorkerStatus(ctx echo.Context, workerId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetSwaggerUI converts echo context to params.
func (w *ServerInterfaceWrapper) GetSwaggerUI(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSwaggerUI(ctx)
	return err
}

// GetHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealth(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetHealth(ctx)
	return err
}

// GetOpenAPISpec converts echo context to params.
func (w *ServerInterfaceWrapper) GetOpenAPISpec(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOpenAPISpec(ctx)
	return err
}

// GetWorkers converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkers(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkers(ctx)
	return err
}

// GetWorker converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorker(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorker(ctx, workerId)
	return err
}

// GetWorkerConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkerConfig(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkerConfig(ctx, workerId)
	return err
}

// GetWorkerFlow converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkerFlow(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkerFlow(ctx, workerId)
	return err
}

// GetWorkerFlowSteps converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkerFlowSteps(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkerFlowSteps(ctx, workerId)
	return err
}

// GetWorkerHealth converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkerHealth(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkerHealth(ctx, workerId)
	return err
}

// GetWorkerLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkerLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWorkerLogsParams
	// ------------- Optional query parameter "role" -------------

	err = runtime.BindQueryParameter("form", true, false, "role", ctx.QueryParams(), &params.Role)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter role: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkerLogs(ctx, workerId, params)
	return err
}

// GetWorkerLogFile converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkerLogFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	// ------------- Path parameter "filename" -------------
	var filename string

	err = runtime.BindStyledParameterWithOptions("simple", "filename", ctx.Param("filename"), &filename, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filename: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetWorkerLogFileParams
	// ------------- Optional query parameter "tail" -------------

	err = runtime.BindQueryParameter("form", true, false, "tail", ctx.QueryParams(), &params.Tail)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tail: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkerLogFile(ctx, workerId, filename, params)
	return err
}

// GetWorkerMetrics converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkerMetrics(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkerMetrics(ctx, workerId)
	return err
}

// GetWorkerStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkerStatus(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "worker_id" -------------
	var workerId string

	err = runtime.BindStyledParameterWithOptions("simple", "worker_id", ctx.Param("worker_id"), &workerId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter worker_id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkerStatus(ctx, workerId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/docs/", wrapper.GetSwaggerUI)
	router.GET(baseURL+"/health", wrapper.GetHealth)
	router.GET(baseURL+"/openapi.yaml", wrapper.GetOpenAPISpec)
	router.GET(baseURL+"/workers", wrapper.GetWorkers)
	router.GET(baseURL+"/workers/:worker_id", wrapper.GetWorker)
	router.GET(baseURL+"/workers/:worker_id/config", wrapper.GetWorkerConfig)
	router.GET(baseURL+"/workers/:worker_id/flow", wrapper.GetWorkerFlow)
	router.GET(baseURL+"/workers/:worker_id/flow/steps", wrapper.GetWorkerFlowSteps)
	router.GET(baseURL+"/workers/:worker_id/health", wrapper.GetWorkerHealth)
	router.GET(baseURL+"/workers/:worker_id/logs", wrapper.GetWorkerLogs)
	router.GET(baseURL+"/workers/:worker_id/logs/:filename", wrapper.GetWorkerLogFile)
	router.GET(baseURL+"/workers/:worker_id/metrics", wrapper.GetWorkerMetrics)
	router.GET(baseURL+"/workers/:worker_id/status", wrapper.GetWorkerStatus)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
