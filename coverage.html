
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>autoteam: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">autoteam/cmd/autoteam/main.go (21.3%)</option>
				
				<option value="file1">autoteam/cmd/worker/main.go (0.0%)</option>
				
				<option value="file2">autoteam/internal/agent/claude_code.go (0.0%)</option>
				
				<option value="file3">autoteam/internal/agent/debug_agent.go (0.0%)</option>
				
				<option value="file4">autoteam/internal/agent/factory.go (0.0%)</option>
				
				<option value="file5">autoteam/internal/agent/gemini_cli.go (0.0%)</option>
				
				<option value="file6">autoteam/internal/agent/qwen_code.go (0.0%)</option>
				
				<option value="file7">autoteam/internal/config/config.go (70.8%)</option>
				
				<option value="file8">autoteam/internal/deps/installer.go (0.0%)</option>
				
				<option value="file9">autoteam/internal/flow/executor.go (0.0%)</option>
				
				<option value="file10">autoteam/internal/generator/fileops.go (56.9%)</option>
				
				<option value="file11">autoteam/internal/generator/generator.go (55.0%)</option>
				
				<option value="file12">autoteam/internal/generator/templates.go (0.0%)</option>
				
				<option value="file13">autoteam/internal/logger/logger.go (0.0%)</option>
				
				<option value="file14">autoteam/internal/monitor/loop.go (0.0%)</option>
				
				<option value="file15">autoteam/internal/ports/ports.go (84.6%)</option>
				
				<option value="file16">autoteam/internal/server/handlers.go (0.0%)</option>
				
				<option value="file17">autoteam/internal/server/server.go (0.0%)</option>
				
				<option value="file18">autoteam/internal/task/log_stream.go (0.0%)</option>
				
				<option value="file19">autoteam/internal/task/parser.go (0.0%)</option>
				
				<option value="file20">autoteam/internal/task/service.go (0.0%)</option>
				
				<option value="file21">autoteam/internal/task/types.go (0.0%)</option>
				
				<option value="file22">autoteam/internal/testutil/testutil.go (0.0%)</option>
				
				<option value="file23">autoteam/internal/worker/config.go (0.0%)</option>
				
				<option value="file24">autoteam/internal/worker/hooks.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "os"
        "os/exec"
        "strings"

        "autoteam/internal/config"
        "autoteam/internal/generator"
        "autoteam/internal/logger"
        "autoteam/internal/ports"

        "github.com/joho/godotenv"
        "github.com/urfave/cli/v3"
        "go.uber.org/zap"
)

// Build-time variables (set by ldflags)
var (
        Version   = "dev"
        BuildTime = "unknown"
        GitCommit = "unknown"
)

// Context key for storing config
type contextKey string

const configContextKey contextKey = "config"

func main() <span class="cov0" title="0">{
        // Load .env file if it exists (ignore errors for optional file)
        _ = godotenv.Load()

        app := &amp;cli.Command{
                Name:    "autoteam",
                Usage:   "Universal AI Agent Management System",
                Version: fmt.Sprintf("%s (built %s, commit %s)", Version, BuildTime, GitCommit),
                Before:  setupContextWithLogger,
                Flags: []cli.Flag{
                        &amp;cli.StringFlag{
                                Name:    "log-level",
                                Aliases: []string{"l"},
                                Usage:   "Set log level (debug, info, warn, error)",
                                Value:   "warn",
                        },
                },
                Commands: []*cli.Command{
                        {
                                Name:   "generate",
                                Usage:  "Generate compose.yaml from autoteam.yaml",
                                Action: generateCommand,
                        },
                        {
                                Name:   "up",
                                Usage:  "Generate and start containers",
                                Action: upCommand,
                                Flags: []cli.Flag{
                                        &amp;cli.StringFlag{
                                                Name:    "docker-compose-args",
                                                Aliases: []string{"args"},
                                                Usage:   "Additional arguments to pass to docker compose command",
                                                Value:   "",
                                        },
                                },
                        },
                        {
                                Name:   "down",
                                Usage:  "Stop containers",
                                Action: downCommand,
                        },
                        {
                                Name:   "init",
                                Usage:  "Create sample autoteam.yaml",
                                Action: initCommand,
                        },
                        {
                                Name:   "workers",
                                Usage:  "List all workers and their states",
                                Action: workersCommand,
                        },
                },
        }

        if err := app.Run(context.Background(), os.Args); err != nil </span><span class="cov0" title="0">{
                // Create emergency logger for fatal errors
                if emergencyLogger, logErr := logger.NewLogger(logger.ErrorLevel); logErr == nil </span><span class="cov0" title="0">{
                        emergencyLogger.Fatal("Application failed to run", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        os.Exit(1)
                }</span>
        }
}

func generateCommand(ctx context.Context, cmd *cli.Command) error <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        cfg := getConfigFromContext(ctx)
        if cfg == nil </span><span class="cov8" title="1">{
                log.Error("Config not available in context")
                return fmt.Errorf("config not available in context")
        }</span>

        <span class="cov8" title="1">log.Info("Generating compose.yaml", zap.String("team_name", cfg.Settings.GetTeamName()))
        gen := generator.New()
        if err := gen.GenerateCompose(cfg); err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to generate compose.yaml", zap.Error(err))
                return fmt.Errorf("failed to generate compose.yaml: %w", err)
        }</span>

        <span class="cov8" title="1">log.Info("Generated compose.yaml successfully")
        fmt.Println("Generated compose.yaml successfully")
        return nil</span>
}

func upCommand(ctx context.Context, cmd *cli.Command) error <span class="cov0" title="0">{
        log := logger.FromContext(ctx)
        cfg := getConfigFromContext(ctx)
        if cfg == nil </span><span class="cov0" title="0">{
                log.Error("Config not available in context")
                return fmt.Errorf("config not available in context")
        }</span>

        // Find free ports for enabled workers
        <span class="cov0" title="0">enabledWorkersWithSettings := cfg.GetEnabledWorkersWithEffectiveSettings()
        if len(enabledWorkersWithSettings) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Finding free ports for %d workers...\n", len(enabledWorkersWithSettings))

                portManager := ports.NewPortManager()
                var serviceNames []string

                // Get service names for enabled workers
                for _, workerWithSettings := range enabledWorkersWithSettings </span><span class="cov0" title="0">{
                        serviceNames = append(serviceNames, workerWithSettings.Worker.GetNormalizedName())
                }</span>

                // Allocate ports for all enabled worker services
                <span class="cov0" title="0">portAllocation, err := portManager.AllocatePortsForServices(serviceNames)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to allocate ports", zap.Error(err))
                        return fmt.Errorf("failed to allocate ports: %w", err)
                }</span>

                // Display port allocations
                <span class="cov0" title="0">fmt.Println("Port allocations:")
                for serviceName, port := range portAllocation </span><span class="cov0" title="0">{
                        fmt.Printf("  %s: http://localhost:%d\n", serviceName, port)
                }</span>
                <span class="cov0" title="0">fmt.Println()

                // Generate compose with port allocations
                log.Info("Generating compose.yaml with dynamic ports", zap.String("team_name", cfg.Settings.GetTeamName()))
                gen := generator.New()
                if err := gen.GenerateComposeWithPorts(cfg, portAllocation); err != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to generate compose.yaml", zap.Error(err))
                        return fmt.Errorf("failed to generate compose.yaml: %w", err)
                }</span>

                <span class="cov0" title="0">log.Info("Generated compose.yaml successfully with port mappings")
                fmt.Println("Generated compose.yaml successfully with port mappings")</span>
        } else<span class="cov0" title="0"> {
                // No enabled agents, use regular generation
                if err := generateCommand(ctx, cmd); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("Starting containers...")

        // Start with default args
        args := []string{"up", "-d", "--remove-orphans"}

        // Add additional docker-compose-args if provided
        if dockerComposeArgs := cmd.String("docker-compose-args"); dockerComposeArgs != "" </span><span class="cov0" title="0">{
                // Split the args string by spaces and append to args
                additionalArgs := strings.Fields(dockerComposeArgs)
                args = append(args, additionalArgs...)
        }</span>

        <span class="cov0" title="0">if err := runDockerCompose(ctx, args...); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start containers: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Containers started successfully")
        return nil</span>
}

func downCommand(ctx context.Context, cmd *cli.Command) error <span class="cov0" title="0">{
        fmt.Println("Stopping containers...")
        if err := runDockerCompose(ctx, "down"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop containers: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Containers stopped successfully")
        return nil</span>
}

func initCommand(ctx context.Context, cmd *cli.Command) error <span class="cov8" title="1">{
        if err := config.CreateSampleConfig("autoteam.yaml"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create sample config: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Println("Created sample autoteam.yaml")
        return nil</span>
}

func workersCommand(ctx context.Context, cmd *cli.Command) error <span class="cov0" title="0">{
        log := logger.FromContext(ctx)
        cfg := getConfigFromContext(ctx)
        if cfg == nil </span><span class="cov0" title="0">{
                log.Error("Config not available in context")
                return fmt.Errorf("config not available in context")
        }</span>

        <span class="cov0" title="0">fmt.Println("Workers configuration:")
        fmt.Println()

        for i, worker := range cfg.Workers </span><span class="cov0" title="0">{
                status := "enabled"
                if !worker.IsEnabled() </span><span class="cov0" title="0">{
                        status = "disabled"
                }</span>

                <span class="cov0" title="0">fmt.Printf("%d. %s (%s)\n", i+1, worker.Name, status)
                if worker.Prompt != "" </span><span class="cov0" title="0">{
                        // Show first line of prompt
                        lines := strings.Split(worker.Prompt, "\n")
                        if len(lines) &gt; 0 &amp;&amp; lines[0] != "" </span><span class="cov0" title="0">{
                                prompt := lines[0]
                                if len(prompt) &gt; 80 </span><span class="cov0" title="0">{
                                        prompt = prompt[:77] + "..."
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("   Prompt: %s\n", prompt)</span>
                        }
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Summary
        <span class="cov0" title="0">enabledCount := 0
        for _, worker := range cfg.Workers </span><span class="cov0" title="0">{
                if worker.IsEnabled() </span><span class="cov0" title="0">{
                        enabledCount++
                }</span>
        }
        <span class="cov0" title="0">fmt.Printf("Total workers: %d (enabled: %d, disabled: %d)\n",
                len(cfg.Workers), enabledCount, len(cfg.Workers)-enabledCount)

        return nil</span>
}

func runDockerCompose(ctx context.Context, args ...string) error <span class="cov8" title="1">{
        cfg := getConfigFromContext(ctx)

        // Use the compose.yaml file from .autoteam directory
        composeArgs := []string{"-f", config.ComposeFilePath}

        // If config is available, use custom project name, otherwise use default
        if cfg != nil &amp;&amp; cfg.Settings.GetTeamName() != "" </span><span class="cov0" title="0">{
                composeArgs = append(composeArgs, "-p", cfg.Settings.GetTeamName())
        }</span>

        <span class="cov8" title="1">composeArgs = append(composeArgs, args...)

        cmd := exec.Command("docker-compose", composeArgs...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        return cmd.Run()</span>
}

// setupContextWithLogger sets up logger and loads config into context
func setupContextWithLogger(ctx context.Context, cmd *cli.Command) (context.Context, error) <span class="cov0" title="0">{
        // Setup logger first
        logLevelStr := cmd.String("log-level")
        logLevel, err := logger.ParseLogLevel(logLevelStr)
        if err != nil </span><span class="cov0" title="0">{
                return ctx, fmt.Errorf("invalid log level: %w", err)
        }</span>

        <span class="cov0" title="0">ctx, err = logger.SetupContext(ctx, logLevel)
        if err != nil </span><span class="cov0" title="0">{
                return ctx, fmt.Errorf("failed to setup logger: %w", err)
        }</span>

        <span class="cov0" title="0">log := logger.FromContext(ctx)
        log.Info("Starting autoteam",
                zap.String("version", Version),
                zap.String("build_time", BuildTime),
                zap.String("git_commit", GitCommit),
                zap.String("log_level", string(logLevel)),
        )

        // Skip loading config for init command as it creates the config file
        // Check command line arguments since Before hook runs on root command
        if len(os.Args) &gt; 1 &amp;&amp; os.Args[1] == "init" </span><span class="cov0" title="0">{
                return ctx, nil
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadConfig("autoteam.yaml")
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to load config", zap.Error(err))
                return ctx, fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">log.Debug("Config loaded successfully", zap.String("team_name", cfg.Settings.GetTeamName()))
        return context.WithValue(ctx, configContextKey, cfg), nil</span>
}

// getConfigFromContext retrieves the config from context
func getConfigFromContext(ctx context.Context) *config.Config <span class="cov8" title="1">{
        cfg, ok := ctx.Value(configContextKey).(*config.Config)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return cfg</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "os/signal"
        "syscall"
        "time"

        "autoteam/internal/config"
        "autoteam/internal/logger"
        "autoteam/internal/monitor"
        "autoteam/internal/worker"

        "github.com/joho/godotenv"
        "github.com/urfave/cli/v3"
        "go.uber.org/zap"
)

// Build-time variables (set by ldflags)
var (
        Version   = "dev"
        BuildTime = "unknown"
        GitCommit = "unknown"
)

func main() <span class="cov0" title="0">{
        // Load .env file if it exists (ignore errors for optional file)
        _ = godotenv.Load()

        app := &amp;cli.Command{
                Name:    "autoteam-worker",
                Usage:   "AutoTeam Worker - AI agent worker execution via MCP servers",
                Version: fmt.Sprintf("%s (built %s, commit %s)", Version, BuildTime, GitCommit),
                Action:  runWorker,
                Flags: []cli.Flag{
                        // Primary configuration file
                        &amp;cli.StringFlag{
                                Name:     "config-file",
                                Aliases:  []string{"c"},
                                Usage:    "Path to worker configuration file (YAML)",
                                Required: true,
                                Sources:  cli.EnvVars("CONFIG_FILE"),
                        },

                        // Runtime Configuration
                        &amp;cli.BoolFlag{
                                Name:  "verbose",
                                Usage: "Enable verbose logging",
                        },
                        &amp;cli.StringFlag{
                                Name:    "log-level",
                                Aliases: []string{"l"},
                                Usage:   "Set log level (debug, info, warn, error)",
                                Value:   "info",
                                Sources: cli.EnvVars("LOG_LEVEL"),
                        },
                },
        }

        if err := app.Run(context.Background(), os.Args); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func runWorker(ctx context.Context, cmd *cli.Command) error <span class="cov0" title="0">{
        // Setup structured logger first
        logLevelStr := cmd.String("log-level")

        // Handle legacy debug/verbose flags
        if cmd.Bool("debug") </span><span class="cov0" title="0">{
                logLevelStr = "debug"
        }</span> else<span class="cov0" title="0"> if cmd.Bool("verbose") </span><span class="cov0" title="0">{
                logLevelStr = "debug"
        }</span>

        <span class="cov0" title="0">logLevel, err := logger.ParseLogLevel(logLevelStr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid log level: %w", err)
        }</span>

        <span class="cov0" title="0">ctx, err = logger.SetupContext(ctx, logLevel)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup logger: %w", err)
        }</span>

        <span class="cov0" title="0">log := logger.FromContext(ctx)
        log.Info("Starting AutoTeam Worker",
                zap.String("version", Version),
                zap.String("build_time", BuildTime),
                zap.String("git_commit", GitCommit),
                zap.String("log_level", string(logLevel)),
        )

        // Load worker configuration from file
        configPath := cmd.String("config-file")
        workerConfig, err := worker.LoadWorkerFromFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to load worker configuration from file", zap.String("config_path", configPath), zap.Error(err))
                return fmt.Errorf("failed to load worker configuration from file %s: %w", configPath, err)
        }</span>

        // Get worker effective settings (without global settings - worker is standalone)
        <span class="cov0" title="0">effectiveSettings := workerConfig.GetEffectiveSettings(config.AgentSettings{})

        log.Info("Worker configuration loaded successfully",
                zap.String("worker_name", workerConfig.Name),
                zap.String("team_name", effectiveSettings.GetTeamName()),
        )

        // Execute on_init hooks from worker settings
        if hookErr := worker.ExecuteHooks(ctx, effectiveSettings.Hooks, "on_init"); hookErr != nil </span><span class="cov0" title="0">{
                log.Error("Failed to execute on_init hooks", zap.Error(hookErr))
                return fmt.Errorf("failed to execute on_init hooks: %w", hookErr)
        }</span>

        // Create context for graceful shutdown
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(ctx)
        defer cancel()

        // Handle interrupt signals
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
        go func() </span><span class="cov0" title="0">{
                sig := &lt;-sigChan
                log.Info("Received signal, shutting down gracefully", zap.String("signal", sig.String()))

                // Execute on_stop hooks from worker settings
                if hookErr := worker.ExecuteHooks(ctx, effectiveSettings.Hooks, "on_stop"); hookErr != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to execute on_stop hooks", zap.Error(hookErr))
                }</span>

                <span class="cov0" title="0">cancel()</span>
        }()

        // Flow configuration is required
        <span class="cov0" title="0">if len(effectiveSettings.Flow) == 0 </span><span class="cov0" title="0">{
                log.Error("No flow configuration found")
                return fmt.Errorf("flow configuration is required")
        }</span>

        // Note: Git operations now handled via MCP servers

        // Initialize flow-based monitor with worker and effective settings
        <span class="cov0" title="0">monitorConfig := monitor.Config{
                SleepDuration: time.Duration(effectiveSettings.GetSleepDuration()) * time.Second,
                TeamName:      effectiveSettings.GetTeamName(),
        }

        log.Info("Creating flow-based monitor", zap.Int("flow_steps", len(effectiveSettings.Flow)))
        mon := monitor.New(workerConfig, effectiveSettings, monitorConfig)

        // Execute on_start hooks from worker settings
        if hookErr := worker.ExecuteHooks(ctx, effectiveSettings.Hooks, "on_start"); hookErr != nil </span><span class="cov0" title="0">{
                log.Error("Failed to execute on_start hooks", zap.Error(hookErr))
                return fmt.Errorf("failed to execute on_start hooks: %w", hookErr)
        }</span>

        <span class="cov0" title="0">log.Info("Starting flow-based agent monitoring loop",
                zap.Duration("sleep_duration", time.Duration(effectiveSettings.GetSleepDuration())*time.Second),
                zap.Int("flow_steps", len(effectiveSettings.Flow)))

        // Start monitoring with error handling for on_error hooks
        err = mon.Start(ctx)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Monitoring loop failed", zap.Error(err))

                // Execute on_error hooks from worker settings
                if hookErr := worker.ExecuteHooks(ctx, effectiveSettings.Hooks, "on_error"); hookErr != nil </span><span class="cov0" title="0">{
                        log.Error("Failed to execute on_error hooks", zap.Error(hookErr))
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package agent

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "autoteam/internal/config"
        "autoteam/internal/logger"
        "autoteam/internal/server"

        "go.uber.org/zap"
)

// ClaudeCode implements the Agent interface for Claude Code
type ClaudeCode struct {
        name       string
        binaryPath string
        mcpServers map[string]config.MCPServer
        args       []string
        env        map[string]string
}

// NewClaudeCode creates a new Claude Code agent instance
func NewClaudeCode(name string, args []string, env map[string]string, mcpServers map[string]config.MCPServer) *ClaudeCode <span class="cov0" title="0">{
        return &amp;ClaudeCode{
                name:       name,
                binaryPath: "claude", // Will be found in PATH after installation
                mcpServers: mcpServers,
                args:       args,
                env:        env,
        }
}</span>

// Name returns the agent name
func (c *ClaudeCode) Name() string <span class="cov0" title="0">{
        return c.name
}</span>

// Type returns the agent type
func (c *ClaudeCode) Type() string <span class="cov0" title="0">{
        return "claude"
}</span>

// Run executes Claude with the given prompt and options
func (c *ClaudeCode) Run(ctx context.Context, prompt string, options RunOptions) (*AgentOutput, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        lgr.Info("Running Claude", zap.String("agent", c.name), zap.String("prompt", prompt))

        // Update Claude before running
        if err := c.update(ctx); err != nil </span><span class="cov0" title="0">{
                lgr.Warn("Failed to update Claude", zap.Error(err))
        }</span>

        // Build the command arguments
        <span class="cov0" title="0">args := c.buildArgs()

        // Add continue flag when requested
        if options.ContinueMode </span><span class="cov0" title="0">{
                args = append(args, "--continue")
        }</span>

        // Prepare output capture buffers
        <span class="cov0" title="0">var stdout, stderr bytes.Buffer

        // Execute Claude
        cmd := exec.CommandContext(ctx, c.binaryPath, args...)
        cmd.Dir = options.WorkingDirectory
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr
        cmd.Stdin = strings.NewReader(prompt)

        // Set environment variables
        cmd.Env = os.Environ()

        // Add Claude-specific environment
        cmd.Env = append(cmd.Env, "IS_SANDBOX=1")

        // Add custom environment variables
        for k, v := range c.env </span><span class="cov0" title="0">{
                cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", k, v))
        }</span>

        <span class="cov0" title="0">lgr.Debug("Executing Claude command",
                zap.String("binary", c.binaryPath),
                zap.Strings("args", args),
                zap.String("working_dir", options.WorkingDirectory),
                zap.Int("prompt_length", len(prompt)))

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return &amp;AgentOutput{
                        Stdout: stdout.String(),
                        Stderr: stderr.String(),
                }, fmt.Errorf("claude execution failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;AgentOutput{
                Stdout: stdout.String(),
                Stderr: stderr.String(),
        }, nil</span>
}

// IsAvailable checks if Claude is available
func (c *ClaudeCode) IsAvailable(ctx context.Context) bool <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, c.binaryPath, "--version")
        return cmd.Run() == nil
}</span>

// CheckAvailability checks if Claude Code is available, returns error if not found
func (c *ClaudeCode) CheckAvailability(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)
        lgr.Info("Checking Claude Code availability")

        if !c.IsAvailable(ctx) </span><span class="cov0" title="0">{
                return fmt.Errorf("claude command not found - please install Claude Code using: npm install -g @anthropic-ai/claude-code")
        }</span>

        <span class="cov0" title="0">lgr.Info("Claude Code is available")
        return nil</span>
}

// Version returns the Claude version
func (c *ClaudeCode) Version(ctx context.Context) (string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, c.binaryPath, "--version")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get Claude version: %w", err)
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(output)), nil</span>
}

// update updates Claude to the latest version
func (c *ClaudeCode) update(ctx context.Context) error <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, c.binaryPath, "update")
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        return cmd.Run()
}</span>

// buildArgs builds the command line arguments for Claude
func (c *ClaudeCode) buildArgs() []string <span class="cov0" title="0">{
        args := []string{
                "--dangerously-skip-permissions",
        }

        // Add custom args from agent configuration
        args = append(args, c.args...)

        // Add MCP config file if MCP servers are configured
        if len(c.mcpServers) &gt; 0 </span><span class="cov0" title="0">{
                mcpConfigPath := c.getMCPConfigPath()
                args = append(args, "--mcp-config", mcpConfigPath)
        }</span>

        <span class="cov0" title="0">return args</span>
}

// Configure configures MCP servers in Claude configuration
func (c *ClaudeCode) Configure(ctx context.Context) error <span class="cov0" title="0">{
        return c.ConfigureForProject(ctx, "")
}</span>

// ConfigureForProject configures MCP servers for a specific agent
func (c *ClaudeCode) ConfigureForProject(ctx context.Context, projectPath string) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        if len(c.mcpServers) == 0 </span><span class="cov0" title="0">{
                lgr.Debug("No MCP servers to configure")
                return nil
        }</span>

        <span class="cov0" title="0">lgr.Info("Configuring MCP servers", zap.Int("count", len(c.mcpServers)), zap.String("agent", c.name))

        // Create dedicated MCP configuration file for this agent
        if err := c.createMCPConfigFile(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create MCP configuration file: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Info("MCP servers configured successfully")
        return nil</span>
}

// getMCPConfigPath returns the path to the MCP configuration file for this agent
func (c *ClaudeCode) getMCPConfigPath() string <span class="cov0" title="0">{
        // Use the agent name as passed from the factory (already normalized with variations)
        // Don't re-normalize as it would convert senior_developer/executor back to senior_developer_executor
        return fmt.Sprintf("/opt/autoteam/workers/%s/.mcp.json", c.name)
}</span>

// createMCPConfigFile creates the MCP configuration file for this agent
func (c *ClaudeCode) createMCPConfigFile(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        mcpConfigPath := c.getMCPConfigPath()
        lgr.Info("Creating MCP configuration file", zap.String("path", mcpConfigPath))

        // Ensure the directory exists
        if err := os.MkdirAll(filepath.Dir(mcpConfigPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create MCP config directory: %w", err)
        }</span>

        // Convert MCP servers to Claude format with mcpServers wrapper
        <span class="cov0" title="0">mcpServersMap := make(map[string]interface{})
        for name, server := range c.mcpServers </span><span class="cov0" title="0">{
                serverConfig := map[string]interface{}{
                        "command": server.Command,
                }

                if len(server.Args) &gt; 0 </span><span class="cov0" title="0">{
                        serverConfig["args"] = server.Args
                }</span>

                <span class="cov0" title="0">if len(server.Env) &gt; 0 </span><span class="cov0" title="0">{
                        serverConfig["env"] = server.Env
                }</span>

                <span class="cov0" title="0">mcpServersMap[name] = serverConfig</span>
        }

        // Wrap in mcpServers object as required by Claude format
        <span class="cov0" title="0">mcpConfig := map[string]interface{}{
                "mcpServers": mcpServersMap,
        }

        // Marshal to JSON with indentation for readability
        data, err := json.MarshalIndent(mcpConfig, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal MCP config: %w", err)
        }</span>

        // Write the MCP configuration file
        <span class="cov0" title="0">if err := os.WriteFile(mcpConfigPath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write MCP config file: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Info("MCP configuration file created successfully",
                zap.String("path", mcpConfigPath),
                zap.Int("mcp_servers", len(c.mcpServers)))

        return nil</span>
}

// SetMCPServers sets the MCP servers for this agent
func (c *ClaudeCode) SetMCPServers(mcpServers map[string]config.MCPServer) <span class="cov0" title="0">{
        c.mcpServers = mcpServers
}</span>

// CreateHTTPServer creates an HTTP API server for this agent
func (c *ClaudeCode) CreateHTTPServer(workingDir string, port int, apiKey string) HTTPServer <span class="cov0" title="0">{
        config := server.Config{
                Port:       port,
                APIKey:     apiKey,
                WorkingDir: workingDir,
        }
        return server.NewServer(c, config)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package agent

import (
        "autoteam/internal/config"
        "context"
        "fmt"
)

// DebugAgent implements the Agent interface for debugging purposes
type DebugAgent struct {
        name       string
        mcpServers map[string]config.MCPServer
        args       []string
        env        map[string]string
}

// NewDebugAgent creates a new Debug agent instance
func NewDebugAgent(name string, args []string, env map[string]string, mcpServers map[string]config.MCPServer) Agent <span class="cov0" title="0">{
        return &amp;DebugAgent{
                name:       name,
                mcpServers: mcpServers,
                args:       args,
                env:        env,
        }
}</span>

// Name returns the agent name
func (d *DebugAgent) Name() string <span class="cov0" title="0">{
        return d.name
}</span>

// Type returns the agent type
func (d *DebugAgent) Type() string <span class="cov0" title="0">{
        return "debug"
}</span>

// Run executes the debug agent with the given prompt
func (d *DebugAgent) Run(ctx context.Context, prompt string, options RunOptions) (*AgentOutput, error) <span class="cov0" title="0">{
        return &amp;AgentOutput{
                Stdout: fmt.Sprintf("Debug agent '%s' executed with prompt: %s", d.name, prompt),
                Stderr: "",
        }, nil
}</span>

// IsAvailable checks if the debug agent is available (always true for debug)
func (d *DebugAgent) IsAvailable(ctx context.Context) bool <span class="cov0" title="0">{
        return true
}</span>

// CheckAvailability checks if the debug agent is available (always true for debug)
func (d *DebugAgent) CheckAvailability(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// Version returns the debug agent version
func (d *DebugAgent) Version(ctx context.Context) (string, error) <span class="cov0" title="0">{
        return "debug-1.0.0", nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package agent

import (
        "fmt"

        "autoteam/internal/config"
)

// Agent type constants
const (
        AgentTypeDebug      = "debug"
        AgentTypeClaudeCode = "claude"
        AgentTypeQwenCode   = "qwen"
        AgentTypeGeminiCli  = "gemini"
)

// CreateAgent creates an agent based on configuration
func CreateAgent(agentConfig config.AgentConfig, name string, mcpServers map[string]config.MCPServer) (Agent, error) <span class="cov0" title="0">{
        switch agentConfig.Type </span>{
        case AgentTypeClaudeCode:<span class="cov0" title="0">
                agent := NewClaudeCode(name, agentConfig.Args, agentConfig.Env, mcpServers)
                return agent, nil</span>
        case AgentTypeDebug:<span class="cov0" title="0">
                agent := NewDebugAgent(name, agentConfig.Args, agentConfig.Env, mcpServers)
                return agent, nil</span>
        case AgentTypeQwenCode:<span class="cov0" title="0">
                agent := NewQwenCode(name, agentConfig.Args, agentConfig.Env, mcpServers)
                return agent, nil</span>
        case AgentTypeGeminiCli:<span class="cov0" title="0">
                agent := NewGeminiCli(name, agentConfig.Args, agentConfig.Env, mcpServers)
                return agent, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported agent type: %s", agentConfig.Type)</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package agent

import (
        "autoteam/internal/config"
        "autoteam/internal/logger"
        "autoteam/internal/server"
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "go.uber.org/zap"
)

// GeminiCli implements the Agent interface for Gemini CLI
type GeminiCli struct {
        name       string
        binaryPath string
        mcpServers map[string]config.MCPServer
        agentArgs  []string
        agentEnv   map[string]string
}

// NewGeminiCli creates a new Gemini agent instance
func NewGeminiCli(name string, args []string, env map[string]string, mcpServers map[string]config.MCPServer) *GeminiCli <span class="cov0" title="0">{
        return &amp;GeminiCli{
                name:       name,
                binaryPath: "gemini", // Will be found in PATH after npm installation
                mcpServers: mcpServers,
                agentArgs:  args,
                agentEnv:   env,
        }
}</span>

// Name returns the agent name
func (q *GeminiCli) Name() string <span class="cov0" title="0">{
        return q.name
}</span>

// Type returns the agent type
func (q *GeminiCli) Type() string <span class="cov0" title="0">{
        return "gemini"
}</span>

// Run executes Gemini with the given prompt and options
func (q *GeminiCli) Run(ctx context.Context, prompt string, options RunOptions) (*AgentOutput, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Build the command arguments
        args := q.buildArgs()

        // Add continue flag when requested
        if options.ContinueMode </span><span class="cov0" title="0">{
                args = append(args, "--continue")
        }</span>

        // Log the full prompt being sent for debugging
        <span class="cov0" title="0">lgr.Info("Sending full prompt to Gemini",
                zap.String("prompt_length", fmt.Sprintf("%d chars", len(prompt))),
                zap.String("full_prompt", prompt))

        // Prepare output capture buffers
        var stdout, stderr bytes.Buffer

        // Execute Gemini
        cmd := exec.CommandContext(ctx, q.binaryPath, args...)

        // Set working directory
        if options.WorkingDirectory != "" </span><span class="cov0" title="0">{
                cmd.Dir = options.WorkingDirectory
        }</span> else<span class="cov0" title="0"> {
                // Use the agent name as passed (already normalized with variations)
                cmd.Dir = fmt.Sprintf("/opt/autoteam/workers/%s", q.name)
        }</span>

        // Log execution details for debugging
        <span class="cov0" title="0">lgr.Info("Executing Gemini CLI",
                zap.String("binary_path", q.binaryPath),
                zap.Strings("args", args),
                zap.String("working_dir", cmd.Dir))

        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr
        cmd.Stdin = strings.NewReader(prompt)

        // Set environment variables
        cmd.Env = os.Environ()
        // Add custom environment variables from agent config
        for k, v := range q.agentEnv </span><span class="cov0" title="0">{
                cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", k, v))
        }</span>

        <span class="cov0" title="0">if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return &amp;AgentOutput{
                        Stdout: stdout.String(),
                        Stderr: stderr.String(),
                }, fmt.Errorf("gemini execution failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;AgentOutput{
                Stdout: stdout.String(),
                Stderr: stderr.String(),
        }, nil</span>
}

// IsAvailable checks if Gemini is available
func (q *GeminiCli) IsAvailable(ctx context.Context) bool <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, q.binaryPath, "--version")
        return cmd.Run() == nil
}</span>

// CheckAvailability checks if Gemini CLI is available, returns error if not found
func (q *GeminiCli) CheckAvailability(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)
        lgr.Info("Checking Gemini CLI availability")

        if !q.IsAvailable(ctx) </span><span class="cov0" title="0">{
                return fmt.Errorf("gemini command not found - please install Gemini CLI using: npm install -g @google/gemini-cli")
        }</span>

        <span class="cov0" title="0">lgr.Info("Gemini CLI is available")
        return nil</span>
}

// Version returns the Gemini version
func (q *GeminiCli) Version(ctx context.Context) (string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, q.binaryPath, "--version")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get Gemini version: %w", err)
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(output)), nil</span>
}

// buildArgs builds the command line arguments for Gemini
func (q *GeminiCli) buildArgs() []string <span class="cov0" title="0">{
        args := []string{"--yolo"} // Add default yolo parameter for non-interactive execution

        // Add custom args from agent configuration
        args = append(args, q.agentArgs...)

        // Gemini automatically looks for .gemini/settings.json in the current working directory
        // or ~/.gemini/settings.json globally. Since we set cmd.Dir to the agent's working directory,
        // Gemini will find the .gemini/settings.json file we created there.

        return args
}</span>

// Configure configures MCP servers for Gemini
func (q *GeminiCli) Configure(ctx context.Context) error <span class="cov0" title="0">{
        return q.ConfigureForProject(ctx, "")
}</span>

// ConfigureForProject configures MCP servers for a specific agent
func (q *GeminiCli) ConfigureForProject(ctx context.Context, projectPath string) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        if len(q.mcpServers) == 0 </span><span class="cov0" title="0">{
                lgr.Debug("No MCP servers to configure for Gemini agent")
                return nil
        }</span>

        <span class="cov0" title="0">lgr.Info("Configuring MCP servers for Gemini", zap.Int("count", len(q.mcpServers)), zap.String("agent", q.name))

        // Create dedicated MCP configuration file for this agent
        if err := q.createMCPConfigFile(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create MCP configuration file: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Info("MCP servers configured successfully for Gemini")
        return nil</span>
}

// getMCPConfigPath returns the path to the MCP configuration file for this agent
// Gemini looks for configuration in ~/.gemini/settings.json or project-specific .gemini/settings.json
func (q *GeminiCli) getMCPConfigPath() string <span class="cov0" title="0">{
        // Use the agent name as passed from the factory (already normalized with variations)
        // Don't re-normalize as it would convert senior_developer/collector back to senior_developer_collector
        return fmt.Sprintf("/opt/autoteam/workers/%s/.gemini/settings.json", q.name)
}</span>

// createMCPConfigFile creates the MCP configuration file for this agent
func (q *GeminiCli) createMCPConfigFile(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        mcpConfigPath := q.getMCPConfigPath()
        lgr.Info("Creating MCP configuration file for Gemini", zap.String("path", mcpConfigPath))

        // Ensure the directory exists
        if err := os.MkdirAll(filepath.Dir(mcpConfigPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create MCP config directory: %w", err)
        }</span>

        // Start with existing settings or create new config
        <span class="cov0" title="0">geminiConfig := make(map[string]interface{})

        // Try to read existing settings file
        if existingData, err := os.ReadFile(mcpConfigPath); err == nil </span><span class="cov0" title="0">{
                if err := json.Unmarshal(existingData, &amp;geminiConfig); err != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Failed to parse existing Gemini settings file, creating new one", zap.Error(err))
                        geminiConfig = make(map[string]interface{})
                }</span>
        }

        // Convert MCP servers to Gemini format (same as Claude/Qwen format)
        <span class="cov0" title="0">mcpServersMap := make(map[string]interface{})
        for name, server := range q.mcpServers </span><span class="cov0" title="0">{
                serverConfig := map[string]interface{}{
                        "command": server.Command,
                }

                if len(server.Args) &gt; 0 </span><span class="cov0" title="0">{
                        serverConfig["args"] = server.Args
                }</span>

                <span class="cov0" title="0">if len(server.Env) &gt; 0 </span><span class="cov0" title="0">{
                        serverConfig["env"] = server.Env
                }</span>

                <span class="cov0" title="0">mcpServersMap[name] = serverConfig</span>
        }

        // Add MCP servers to config while preserving existing settings
        <span class="cov0" title="0">geminiConfig["mcpServers"] = mcpServersMap

        // Marshal to JSON with indentation for readability
        data, err := json.MarshalIndent(geminiConfig, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal Gemini config: %w", err)
        }</span>

        // Write the configuration file
        <span class="cov0" title="0">if err := os.WriteFile(mcpConfigPath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write Gemini config file: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Info("MCP configuration file created successfully for Gemini",
                zap.String("path", mcpConfigPath),
                zap.Int("mcp_servers", len(q.mcpServers)))

        return nil</span>
}

// SetMCPServers sets the MCP servers for this agent
func (q *GeminiCli) SetMCPServers(mcpServers map[string]config.MCPServer) <span class="cov0" title="0">{
        q.mcpServers = mcpServers
}</span>

// CreateHTTPServer creates an HTTP API server for this agent
func (q *GeminiCli) CreateHTTPServer(workingDir string, port int, apiKey string) HTTPServer <span class="cov0" title="0">{
        config := server.Config{
                Port:       port,
                APIKey:     apiKey,
                WorkingDir: workingDir,
        }
        return server.NewServer(q, config)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package agent

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "autoteam/internal/config"
        "autoteam/internal/logger"
        "autoteam/internal/server"

        "go.uber.org/zap"
)

// QwenCode implements the Agent interface for Qwen Code
type QwenCode struct {
        name       string
        binaryPath string
        mcpServers map[string]config.MCPServer
        agentArgs  []string
        agentEnv   map[string]string
}

// NewQwenCode creates a new Qwen agent instance
func NewQwenCode(name string, args []string, env map[string]string, mcpServers map[string]config.MCPServer) *QwenCode <span class="cov0" title="0">{
        return &amp;QwenCode{
                name:       name,
                binaryPath: "qwen", // Will be found in PATH after npm installation
                mcpServers: mcpServers,
                agentArgs:  args,
                agentEnv:   env,
        }
}</span>

// Name returns the agent name
func (q *QwenCode) Name() string <span class="cov0" title="0">{
        return q.name
}</span>

// Type returns the agent type
func (q *QwenCode) Type() string <span class="cov0" title="0">{
        return "qwen"
}</span>

// Run executes Qwen with the given prompt and options
func (q *QwenCode) Run(ctx context.Context, prompt string, options RunOptions) (*AgentOutput, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Build the command arguments
        args := q.buildArgs()

        // Add continue flag when requested
        if options.ContinueMode </span><span class="cov0" title="0">{
                args = append(args, "--continue")
        }</span>

        // Prepare output capture buffers
        <span class="cov0" title="0">var stdout, stderr bytes.Buffer

        // Execute Qwen
        cmd := exec.CommandContext(ctx, q.binaryPath, args...)

        // Set working directory
        if options.WorkingDirectory != "" </span><span class="cov0" title="0">{
                cmd.Dir = options.WorkingDirectory
        }</span> else<span class="cov0" title="0"> {
                // Use agent directory where .qwen/settings.json is located
                cmd.Dir = fmt.Sprintf("/opt/autoteam/workers/%s", q.name)
        }</span>

        <span class="cov0" title="0">cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr
        cmd.Stdin = strings.NewReader(prompt)

        // Set environment variables
        cmd.Env = os.Environ()
        // Add custom environment variables from agent config
        for k, v := range q.agentEnv </span><span class="cov0" title="0">{
                cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", k, v))
        }</span>

        <span class="cov0" title="0">lgr.Debug("Executing Qwen command",
                zap.String("binary", q.binaryPath),
                zap.Strings("args", args),
                zap.String("working_dir", cmd.Dir),
                zap.Int("prompt_length", len(prompt)))

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return &amp;AgentOutput{
                        Stdout: stdout.String(),
                        Stderr: stderr.String(),
                }, fmt.Errorf("qwen execution failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;AgentOutput{
                Stdout: stdout.String(),
                Stderr: stderr.String(),
        }, nil</span>
}

// IsAvailable checks if Qwen is available
func (q *QwenCode) IsAvailable(ctx context.Context) bool <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, q.binaryPath, "--version")
        return cmd.Run() == nil
}</span>

// CheckAvailability checks if Qwen Code is available, returns error if not found
func (q *QwenCode) CheckAvailability(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)
        lgr.Info("Checking Qwen Code availability")

        if !q.IsAvailable(ctx) </span><span class="cov0" title="0">{
                return fmt.Errorf("qwen command not found - please install Qwen Code using: npm install -g @qwen-code/qwen-code@latest")
        }</span>

        <span class="cov0" title="0">lgr.Info("Qwen Code is available")
        return nil</span>
}

// Version returns the Qwen version
func (q *QwenCode) Version(ctx context.Context) (string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, q.binaryPath, "--version")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get Qwen version: %w", err)
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(output)), nil</span>
}

// buildArgs builds the command line arguments for Qwen
func (q *QwenCode) buildArgs() []string <span class="cov0" title="0">{
        args := []string{"--yolo"} // Add default yolo parameter for non-interactive execution

        // Add custom args from agent configuration
        args = append(args, q.agentArgs...)

        // Qwen Code automatically looks for .qwen/settings.json in the current working directory
        // Since we set cmd.Dir to the agent's working directory, Qwen will find the .qwen/settings.json file we created there.

        return args
}</span>

// Configure configures MCP servers for Qwen
func (q *QwenCode) Configure(ctx context.Context) error <span class="cov0" title="0">{
        return q.ConfigureForProject(ctx, "")
}</span>

// ConfigureForProject configures MCP servers for a specific agent
func (q *QwenCode) ConfigureForProject(ctx context.Context, projectPath string) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        if len(q.mcpServers) == 0 </span><span class="cov0" title="0">{
                lgr.Debug("No MCP servers to configure for Qwen agent")
                return nil
        }</span>

        <span class="cov0" title="0">lgr.Info("Configuring MCP servers for Qwen", zap.Int("count", len(q.mcpServers)), zap.String("agent", q.name))

        // Create dedicated MCP configuration file for this agent
        if err := q.createMCPConfigFile(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create MCP configuration file: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Info("MCP servers configured successfully for Qwen")
        return nil</span>
}

// getMCPConfigPath returns the path to the MCP configuration file for this agent
// Qwen Code looks for configuration in .qwen/settings.json in the project directory
func (q *QwenCode) getMCPConfigPath() string <span class="cov0" title="0">{
        // Use the agent name as passed from the factory (already normalized with variations)
        // Don't re-normalize as it would convert senior_developer/collector back to senior_developer_collector
        return fmt.Sprintf("/opt/autoteam/workers/%s/.qwen/settings.json", q.name)
}</span>

// createMCPConfigFile creates the MCP configuration file for this agent
func (q *QwenCode) createMCPConfigFile(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        mcpConfigPath := q.getMCPConfigPath()
        lgr.Info("Creating MCP configuration file for Qwen", zap.String("path", mcpConfigPath))

        // Ensure the directory exists
        if err := os.MkdirAll(filepath.Dir(mcpConfigPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create MCP config directory: %w", err)
        }</span>

        // Start with existing settings or create new config
        <span class="cov0" title="0">qwenConfig := make(map[string]interface{})

        // Try to read existing settings file
        if existingData, err := os.ReadFile(mcpConfigPath); err == nil </span><span class="cov0" title="0">{
                if err := json.Unmarshal(existingData, &amp;qwenConfig); err != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Failed to parse existing Qwen settings file, creating new one", zap.Error(err))
                        qwenConfig = make(map[string]interface{})
                }</span>
        }

        // Convert MCP servers to Qwen format (similar to Gemini/Claude format)
        <span class="cov0" title="0">mcpServersMap := make(map[string]interface{})
        for name, server := range q.mcpServers </span><span class="cov0" title="0">{
                serverConfig := map[string]interface{}{
                        "command": server.Command,
                }

                if len(server.Args) &gt; 0 </span><span class="cov0" title="0">{
                        serverConfig["args"] = server.Args
                }</span>

                <span class="cov0" title="0">if len(server.Env) &gt; 0 </span><span class="cov0" title="0">{
                        serverConfig["env"] = server.Env
                }</span>

                <span class="cov0" title="0">mcpServersMap[name] = serverConfig</span>
        }

        // Add MCP servers to config while preserving existing settings
        <span class="cov0" title="0">qwenConfig["mcpServers"] = mcpServersMap

        // Marshal to JSON with indentation for readability
        data, err := json.MarshalIndent(qwenConfig, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal Qwen config: %w", err)
        }</span>

        // Write the configuration file
        <span class="cov0" title="0">if err := os.WriteFile(mcpConfigPath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write Qwen config file: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Info("MCP configuration file created successfully for Qwen",
                zap.String("path", mcpConfigPath),
                zap.Int("mcp_servers", len(q.mcpServers)))

        return nil</span>
}

// SetMCPServers sets the MCP servers for this agent
func (q *QwenCode) SetMCPServers(mcpServers map[string]config.MCPServer) <span class="cov0" title="0">{
        q.mcpServers = mcpServers
}</span>

// CreateHTTPServer creates an HTTP API server for this agent
func (q *QwenCode) CreateHTTPServer(workingDir string, port int, apiKey string) HTTPServer <span class="cov0" title="0">{
        config := server.Config{
                Port:       port,
                APIKey:     apiKey,
                WorkingDir: workingDir,
        }
        return server.NewServer(q, config)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "fmt"
        "maps"
        "os"
        "regexp"
        "strings"

        "gopkg.in/yaml.v3"
)

// Default configuration constants
const (
        DefaultTeamName = "autoteam"
)

type Config struct {
        Workers    []Worker                          `yaml:"workers"`
        Services   map[string]map[string]interface{} `yaml:"services,omitempty"`
        Settings   AgentSettings                     `yaml:"settings"`
        MCPServers map[string]MCPServer              `yaml:"mcp_servers,omitempty"`
}

type Worker struct {
        Name       string               `yaml:"name"`
        Prompt     string               `yaml:"prompt"`
        Enabled    *bool                `yaml:"enabled,omitempty"`
        Settings   *AgentSettings       `yaml:"settings,omitempty"`
        MCPServers map[string]MCPServer `yaml:"mcp_servers,omitempty"`
}

type AgentSettings struct {
        SleepDuration *int                   `yaml:"sleep_duration,omitempty"`
        TeamName      *string                `yaml:"team_name,omitempty"`
        InstallDeps   *bool                  `yaml:"install_deps,omitempty"`
        CommonPrompt  *string                `yaml:"common_prompt,omitempty"`
        MaxAttempts   *int                   `yaml:"max_attempts,omitempty"`
        Service       map[string]interface{} `yaml:"service,omitempty"`
        MCPServers    map[string]MCPServer   `yaml:"mcp_servers,omitempty"`
        Hooks         *HookConfig            `yaml:"hooks,omitempty"`
        Debug         *bool                  `yaml:"debug,omitempty"`
        // Dynamic Flow Configuration
        Flow []FlowStep `yaml:"flow"`
}

// FlowStep represents a single step in a dynamic flow configuration
type FlowStep struct {
        Name      string            `yaml:"name"`                 // Unique step name
        Type      string            `yaml:"type"`                 // Agent type (claude, gemini, qwen)
        Args      []string          `yaml:"args,omitempty"`       // Agent-specific arguments
        Env       map[string]string `yaml:"env,omitempty"`        // Environment variables
        DependsOn []string          `yaml:"depends_on,omitempty"` // Step dependencies
        Input     string            `yaml:"input,omitempty"`      // Agent input prompt (supports templates)
        Output    string            `yaml:"output,omitempty"`     // Output transformation template (Sprig)
        SkipWhen  string            `yaml:"skip_when,omitempty"`  // Skip condition template (if evaluates to "true")
}

// MCPServer represents a Model Context Protocol server configuration
type MCPServer struct {
        Command string            `yaml:"command"`
        Args    []string          `yaml:"args,omitempty"`
        Env     map[string]string `yaml:"env,omitempty"`
}

// AgentConfig represents unified agent configuration structure
type AgentConfig struct {
        Type   string            `yaml:"type"`
        Args   []string          `yaml:"args,omitempty"`
        Env    map[string]string `yaml:"env,omitempty"`
        Prompt *string           `yaml:"prompt,omitempty"`
}

// HookConfig represents agent lifecycle hook-driven script execution configuration
type HookConfig struct {
        OnInit  []HookCommand `yaml:"on_init,omitempty"`  // Before agent initialization
        OnStart []HookCommand `yaml:"on_start,omitempty"` // When agent starts monitoring
        OnStop  []HookCommand `yaml:"on_stop,omitempty"`  // When agent stops
        OnError []HookCommand `yaml:"on_error,omitempty"` // When agent encounters errors
}

// HookCommand represents a command to execute on an agent lifecycle hook
type HookCommand struct {
        Command     string            `yaml:"command"`
        Args        []string          `yaml:"args,omitempty"`
        Env         map[string]string `yaml:"env,omitempty"`
        WorkingDir  *string           `yaml:"working_dir,omitempty"`
        Timeout     *int              `yaml:"timeout,omitempty"`     // timeout in seconds
        ContinueOn  *string           `yaml:"continue_on,omitempty"` // "success", "error", "always"
        Description *string           `yaml:"description,omitempty"`
}

func LoadConfig(filename string) (*Config, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov8" title="1">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse YAML: %w", err)
        }</span>

        // Validate required fields
        <span class="cov8" title="1">if err := validateConfig(&amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Set defaults
        <span class="cov8" title="1">setDefaults(&amp;config)

        return &amp;config, nil</span>
}

func validateConfig(config *Config) error <span class="cov8" title="1">{
        if len(config.Workers) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("at least one worker must be configured")
        }</span>

        // Count enabled workers
        <span class="cov8" title="1">enabledCount := 0
        for _, worker := range config.Workers </span><span class="cov8" title="1">{
                if worker.IsEnabled() </span><span class="cov8" title="1">{
                        enabledCount++
                }</span>
        }

        <span class="cov8" title="1">if enabledCount == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("at least one worker must be enabled")
        }</span>

        <span class="cov8" title="1">for i, worker := range config.Workers </span><span class="cov8" title="1">{
                if worker.Name == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("worker[%d].name is required", i)
                }</span>
                // Only validate required fields for enabled workers
                <span class="cov8" title="1">if worker.IsEnabled() </span><span class="cov8" title="1">{
                        if worker.Prompt == "" </span><span class="cov8" title="1">{
                                return fmt.Errorf("worker[%d].prompt is required for enabled workers", i)
                        }</span>

                        // Get effective settings to check flow configuration
                        <span class="cov8" title="1">settings := worker.GetEffectiveSettings(config.Settings)
                        if len(settings.Flow) == 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("worker[%d].flow is required for enabled workers", i)
                        }</span>

                        // Validate flow steps
                        <span class="cov8" title="1">if err := validateFlow(settings.Flow); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("agent[%d].flow validation failed: %w", i, err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// validateFlow validates flow configuration
func validateFlow(flow []FlowStep) error <span class="cov8" title="1">{
        if len(flow) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("flow must contain at least one step")
        }</span>

        <span class="cov8" title="1">stepNames := make(map[string]bool)
        for i, step := range flow </span><span class="cov8" title="1">{
                if step.Name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("step[%d].name is required", i)
                }</span>
                <span class="cov8" title="1">if step.Type == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("step[%d].type is required", i)
                }</span>
                <span class="cov8" title="1">if stepNames[step.Name] </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate step name: %s", step.Name)
                }</span>
                <span class="cov8" title="1">stepNames[step.Name] = true

                // Validate dependencies exist
                for _, dep := range step.DependsOn </span><span class="cov8" title="1">{
                        found := false
                        for _, otherStep := range flow </span><span class="cov8" title="1">{
                                if otherStep.Name == dep </span><span class="cov8" title="1">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                                return fmt.Errorf("step %s depends on non-existent step: %s", step.Name, dep)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func setDefaults(config *Config) <span class="cov8" title="1">{
        if config.Settings.SleepDuration == nil </span><span class="cov8" title="1">{
                config.Settings.SleepDuration = IntPtr(60)
        }</span>
        <span class="cov8" title="1">if config.Settings.TeamName == nil </span><span class="cov8" title="1">{
                config.Settings.TeamName = StringPtr(DefaultTeamName)
        }</span>
        <span class="cov8" title="1">if config.Settings.MaxAttempts == nil </span><span class="cov8" title="1">{
                config.Settings.MaxAttempts = IntPtr(3)
        }</span>
        // Set default service configuration if not provided
        <span class="cov8" title="1">if config.Settings.Service == nil </span><span class="cov8" title="1">{
                config.Settings.Service = map[string]interface{}{
                        "image": "node:18.17.1",
                        "user":  "developer",
                }
        }</span>
}

func CreateSampleConfig(filename string) error <span class="cov8" title="1">{
        sampleConfig := Config{
                Workers: []Worker{
                        {
                                Name:   "dev1",
                                Prompt: "You are a developer agent responsible for implementing features and fixing bugs.",
                        },
                        {
                                Name:   "arch1",
                                Prompt: "You are an architecture agent responsible for system design and code reviews.",
                                Settings: &amp;AgentSettings{
                                        SleepDuration: IntPtr(30),
                                        Service: map[string]interface{}{
                                                "image": "python:3.11",
                                                "volumes": []string{
                                                        "./custom-configs:/app/configs:ro",
                                                        "/var/run/docker.sock:/var/run/docker.sock",
                                                },
                                                "environment": map[string]string{
                                                        "PYTHON_PATH": "/app/custom",
                                                        "DEBUG_MODE":  "true",
                                                },
                                        },
                                        Hooks: &amp;HookConfig{
                                                OnInit: []HookCommand{
                                                        {
                                                                Command:     "/bin/sh",
                                                                Args:        []string{"-c", "echo 'Agent initializing: $AGENT_NAME'"},
                                                                Description: StringPtr("Log agent initialization"),
                                                        },
                                                },
                                                OnStart: []HookCommand{
                                                        {
                                                                Command:     "/bin/bash",
                                                                Args:        []string{"-c", "pip install --upgrade pip &amp;&amp; pip install requests"},
                                                                Timeout:     IntPtr(60),
                                                                ContinueOn:  StringPtr("always"),
                                                                Description: StringPtr("Install additional Python packages"),
                                                        },
                                                },
                                                OnStop: []HookCommand{
                                                        {
                                                                Command:     "/bin/sh",
                                                                Args:        []string{"-c", "echo 'Agent $AGENT_NAME shutting down gracefully'"},
                                                                Description: StringPtr("Log graceful shutdown"),
                                                        },
                                                },
                                        },
                                },
                        },
                        {
                                Name:    "devops1",
                                Prompt:  "You are a DevOps agent responsible for CI/CD and infrastructure.",
                                Enabled: BoolPtr(false), // This agent is disabled
                        },
                },
                Services: map[string]map[string]interface{}{
                        "postgres": {
                                "image": "postgres:15",
                                "environment": map[string]string{
                                        "POSTGRES_DB":       "autoteam_dev",
                                        "POSTGRES_USER":     "autoteam",
                                        "POSTGRES_PASSWORD": "development_password",
                                },
                                "ports": []string{"5432:5432"},
                                "volumes": []string{
                                        "postgres_data:/var/lib/postgresql/data",
                                        "./sql/init.sql:/docker-entrypoint-initdb.d/init.sql:ro",
                                },
                        },
                        "redis": {
                                "image":   "redis:7",
                                "ports":   []string{"6379:6379"},
                                "volumes": []string{"redis_data:/data"},
                        },
                },
                Settings: AgentSettings{
                        SleepDuration: IntPtr(60),
                        TeamName:      StringPtr(DefaultTeamName),
                        InstallDeps:   BoolPtr(true),
                        CommonPrompt:  StringPtr("Always follow coding best practices and write comprehensive tests."),
                        MaxAttempts:   IntPtr(3),
                        Service: map[string]interface{}{
                                "image": "node:18.17.1",
                                "user":  "developer",
                        },
                        Flow: []FlowStep{
                                {
                                        Name:   "collector",
                                        Type:   "gemini",
                                        Args:   []string{"--model", "gemini-2.5-flash"},
                                        Input:  "You are a notification collector. Get unread GitHub notifications and list them.\nUse GitHub MCP to get unread notifications.\nCRITICAL: Mark all notifications as read after collecting them.",
                                        Output: "{{ .stdout | trim }}",
                                },
                                {
                                        Name:      "analyzer",
                                        Type:      "claude",
                                        DependsOn: []string{"collector"},
                                        Input:     "{{ index .inputs 0 }}\n\nYou are the GitHub Notification Handler. Process GitHub notifications exactly like a human would.\n\nFor each notification:\n1. Read the full context (issues, PRs, comments, code)\n2. Respond naturally as a project contributor\n3. Take appropriate action (comment, review, create PR, etc.)\n4. Use GitHub MCP to publish your responses\n\nAlways be professional, helpful, and maintain high quality standards.",
                                },
                        },
                },
                MCPServers: map[string]MCPServer{
                        "memory": {
                                Command: "npx",
                                Args:    []string{"-y", "mcp-memory-service"},
                        },
                },
        }

        data, err := yaml.Marshal(&amp;sampleConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal sample config: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(filename, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write sample config: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// mergeServiceConfigs merges global and agent service configurations
// Agent service properties override global ones, with special handling for maps and arrays
func mergeServiceConfigs(global, agent map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        if global == nil &amp;&amp; agent == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if global == nil </span><span class="cov0" title="0">{
                return copyServiceConfig(agent)
        }</span>
        <span class="cov8" title="1">if agent == nil </span><span class="cov0" title="0">{
                return copyServiceConfig(global)
        }</span>

        // Start with a copy of global config
        <span class="cov8" title="1">result := copyServiceConfig(global)

        // Override/merge with agent config
        for key, agentValue := range agent </span><span class="cov8" title="1">{
                globalValue, exists := result[key]

                // If key doesn't exist in global, just add it
                if !exists </span><span class="cov8" title="1">{
                        result[key] = agentValue
                        continue</span>
                }

                // Universal map merging - merge any map-type values recursively
                <span class="cov8" title="1">if merged := tryMergeAsMapRecursive(globalValue, agentValue); merged != nil </span><span class="cov8" title="1">{
                        result[key] = merged
                        continue</span>
                }

                // For all other properties (including arrays like volumes, ports), agent replaces global
                <span class="cov8" title="1">result[key] = agentValue</span>
        }

        <span class="cov8" title="1">return result</span>
}

// tryMergeAsMapRecursive attempts to merge two values as maps recursively using golang maps package
// Returns the merged map if successful, nil if values aren't compatible maps
func tryMergeAsMapRecursive(globalValue, agentValue interface{}) interface{} <span class="cov8" title="1">{
        // Try map[string]string first (most common for environment, labels, etc.)
        if globalMap, ok := globalValue.(map[string]string); ok </span><span class="cov8" title="1">{
                if agentMap, ok := agentValue.(map[string]string); ok </span><span class="cov8" title="1">{
                        // Use maps.Clone for efficient copying, then merge
                        merged := maps.Clone(globalMap)
                        maps.Copy(merged, agentMap) // Agent values override global
                        return merged
                }</span>
        }

        // Try map[string]interface{} (common after YAML unmarshaling) with recursive merging
        <span class="cov8" title="1">if globalMap, ok := globalValue.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if agentMap, ok := agentValue.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        // Use maps.Clone for efficient copying
                        merged := maps.Clone(globalMap)

                        // Recursively merge/override with agent values
                        for k, agentVal := range agentMap </span><span class="cov8" title="1">{
                                globalVal, exists := merged[k]

                                if !exists </span><span class="cov8" title="1">{
                                        // Key doesn't exist in global, just add it (deep copy)
                                        merged[k] = deepCopyValue(agentVal)
                                }</span> else<span class="cov8" title="1"> {
                                        // Try recursive merge for nested maps
                                        if recursiveMerged := tryMergeAsMapRecursive(globalVal, agentVal); recursiveMerged != nil </span><span class="cov8" title="1">{
                                                merged[k] = recursiveMerged
                                        }</span> else<span class="cov8" title="1"> {
                                                // Not mergeable maps, agent value replaces global (deep copy)
                                                merged[k] = deepCopyValue(agentVal)
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">return merged</span>
                }
        }

        // Try mixed map types - convert map[string]string to map[string]interface{}
        <span class="cov8" title="1">if globalMap, ok := globalValue.(map[string]string); ok </span><span class="cov0" title="0">{
                if agentMap, ok := agentValue.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Convert global to interface{} map and clone
                        merged := make(map[string]interface{})
                        for k, v := range globalMap </span><span class="cov0" title="0">{
                                merged[k] = v
                        }</span>

                        // Recursively merge/override with agent values
                        <span class="cov0" title="0">for k, agentVal := range agentMap </span><span class="cov0" title="0">{
                                globalVal, exists := merged[k]

                                if !exists </span><span class="cov0" title="0">{
                                        merged[k] = deepCopyValue(agentVal)
                                }</span> else<span class="cov0" title="0"> {
                                        if recursiveMerged := tryMergeAsMapRecursive(globalVal, agentVal); recursiveMerged != nil </span><span class="cov0" title="0">{
                                                merged[k] = recursiveMerged
                                        }</span> else<span class="cov0" title="0"> {
                                                merged[k] = deepCopyValue(agentVal)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">return merged</span>
                }
        }

        // Try reverse mixed types - convert map[string]interface{} to accommodate map[string]string
        <span class="cov8" title="1">if globalMap, ok := globalValue.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if agentMap, ok := agentValue.(map[string]string); ok </span><span class="cov0" title="0">{
                        // Use maps.Clone for efficient copying
                        merged := maps.Clone(globalMap)

                        // Override with agent values (convert to interface{})
                        for k, v := range agentMap </span><span class="cov0" title="0">{
                                merged[k] = v
                        }</span>
                        <span class="cov0" title="0">return merged</span>
                }
        }

        // Values aren't compatible maps
        <span class="cov8" title="1">return nil</span>
}

// deepCopyValue creates a deep copy of various value types
func deepCopyValue(value interface{}) interface{} <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case map[string]string:<span class="cov0" title="0">
                return maps.Clone(v)</span> // Use efficient maps.Clone
        case map[string]interface{}:<span class="cov0" title="0">
                // Deep copy for nested interface{} maps
                copied := make(map[string]interface{})
                for k, val := range v </span><span class="cov0" title="0">{
                        copied[k] = deepCopyValue(val) // Recursive deep copy
                }</span>
                <span class="cov0" title="0">return copied</span>
        case []string:<span class="cov0" title="0">
                // Use slices.Clone if available, otherwise manual copy
                copied := make([]string, len(v))
                copy(copied, v)
                return copied</span>
        case []interface{}:<span class="cov0" title="0">
                // Deep copy for slice of interfaces
                copied := make([]interface{}, len(v))
                for i, val := range v </span><span class="cov0" title="0">{
                        copied[i] = deepCopyValue(val) // Recursive deep copy
                }</span>
                <span class="cov0" title="0">return copied</span>
        default:<span class="cov8" title="1">
                // For primitive types (string, int, bool, etc.), direct assignment is fine
                return value</span>
        }
}

// copyServiceConfig creates a deep copy of a service configuration map
func copyServiceConfig(source map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        if source == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">result := make(map[string]interface{})
        for key, value := range source </span><span class="cov8" title="1">{
                // Special handling for map types (like environment)
                if envMap, ok := value.(map[string]string); ok </span><span class="cov8" title="1">{
                        newEnvMap := make(map[string]string)
                        for k, v := range envMap </span><span class="cov8" title="1">{
                                newEnvMap[k] = v
                        }</span>
                        <span class="cov8" title="1">result[key] = newEnvMap</span>
                } else<span class="cov8" title="1"> if strSlice, ok := value.([]string); ok </span><span class="cov8" title="1">{
                        // Copy string slices (like volumes)
                        newSlice := make([]string, len(strSlice))
                        copy(newSlice, strSlice)
                        result[key] = newSlice
                }</span> else<span class="cov8" title="1"> {
                        // For other types, direct assignment (should be safe for scalars)
                        result[key] = value
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// mergeMCPServers merges MCP server configurations from global settings, agent settings, and agent-level MCP servers
// Priority: agent-level MCPServers &gt; agent.settings.MCPServers &gt; global settings MCPServers
func mergeMCPServers(globalMCPServers, agentSettingsMCPServers, agentMCPServers map[string]MCPServer) map[string]MCPServer <span class="cov8" title="1">{
        if globalMCPServers == nil &amp;&amp; agentSettingsMCPServers == nil &amp;&amp; agentMCPServers == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make(map[string]MCPServer)

        // Start with global MCP servers
        for name, server := range globalMCPServers </span><span class="cov0" title="0">{
                result[name] = copyMCPServer(server)
        }</span>

        // Override with agent settings MCP servers
        <span class="cov0" title="0">for name, server := range agentSettingsMCPServers </span><span class="cov0" title="0">{
                result[name] = copyMCPServer(server)
        }</span>

        // Override with agent-level MCP servers (highest priority)
        <span class="cov0" title="0">for name, server := range agentMCPServers </span><span class="cov0" title="0">{
                result[name] = copyMCPServer(server)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// copyMCPServer creates a deep copy of an MCPServer
func copyMCPServer(server MCPServer) MCPServer <span class="cov0" title="0">{
        copied := MCPServer{
                Command: server.Command,
        }

        // Copy args slice
        if server.Args != nil </span><span class="cov0" title="0">{
                copied.Args = make([]string, len(server.Args))
                copy(copied.Args, server.Args)
        }</span>

        // Copy env map using maps.Clone
        <span class="cov0" title="0">if server.Env != nil </span><span class="cov0" title="0">{
                copied.Env = maps.Clone(server.Env)
        }</span>

        <span class="cov0" title="0">return copied</span>
}

// copyHookConfig creates a deep copy of a HookConfig
func copyHookConfig(source *HookConfig) *HookConfig <span class="cov8" title="1">{
        if source == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">copied := &amp;HookConfig{}

        // Copy each hook command slice
        if source.OnInit != nil </span><span class="cov8" title="1">{
                copied.OnInit = copyHookCommands(source.OnInit)
        }</span>
        <span class="cov8" title="1">if source.OnStart != nil </span><span class="cov8" title="1">{
                copied.OnStart = copyHookCommands(source.OnStart)
        }</span>
        <span class="cov8" title="1">if source.OnStop != nil </span><span class="cov8" title="1">{
                copied.OnStop = copyHookCommands(source.OnStop)
        }</span>
        <span class="cov8" title="1">if source.OnError != nil </span><span class="cov0" title="0">{
                copied.OnError = copyHookCommands(source.OnError)
        }</span>

        <span class="cov8" title="1">return copied</span>
}

// copyHookCommands creates a deep copy of a slice of HookCommand
func copyHookCommands(source []HookCommand) []HookCommand <span class="cov8" title="1">{
        if source == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">copied := make([]HookCommand, len(source))
        for i, cmd := range source </span><span class="cov8" title="1">{
                copied[i] = HookCommand{
                        Command: cmd.Command,
                }

                // Copy args slice
                if cmd.Args != nil </span><span class="cov8" title="1">{
                        copied[i].Args = make([]string, len(cmd.Args))
                        copy(copied[i].Args, cmd.Args)
                }</span>

                // Copy env map
                <span class="cov8" title="1">if cmd.Env != nil </span><span class="cov8" title="1">{
                        copied[i].Env = maps.Clone(cmd.Env)
                }</span>

                // Copy optional fields
                <span class="cov8" title="1">if cmd.WorkingDir != nil </span><span class="cov8" title="1">{
                        copied[i].WorkingDir = StringPtr(*cmd.WorkingDir)
                }</span>
                <span class="cov8" title="1">if cmd.Timeout != nil </span><span class="cov8" title="1">{
                        copied[i].Timeout = IntPtr(*cmd.Timeout)
                }</span>
                <span class="cov8" title="1">if cmd.ContinueOn != nil </span><span class="cov8" title="1">{
                        copied[i].ContinueOn = StringPtr(*cmd.ContinueOn)
                }</span>
                <span class="cov8" title="1">if cmd.Description != nil </span><span class="cov8" title="1">{
                        copied[i].Description = StringPtr(*cmd.Description)
                }</span>
        }

        <span class="cov8" title="1">return copied</span>
}

// mergeHookConfigs merges hook configurations with agent-level overriding global
func mergeHookConfigs(global, agentLevel *HookConfig) *HookConfig <span class="cov8" title="1">{
        if agentLevel != nil </span><span class="cov8" title="1">{
                return copyHookConfig(agentLevel)
        }</span>
        <span class="cov8" title="1">if global != nil </span><span class="cov8" title="1">{
                return copyHookConfig(global)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// copyAgentSettings creates a deep copy of an AgentSettings
func copyAgentSettings(source AgentSettings) AgentSettings <span class="cov8" title="1">{
        copied := AgentSettings{}

        if source.SleepDuration != nil </span><span class="cov8" title="1">{
                copied.SleepDuration = IntPtr(*source.SleepDuration)
        }</span>
        <span class="cov8" title="1">if source.TeamName != nil </span><span class="cov8" title="1">{
                copied.TeamName = StringPtr(*source.TeamName)
        }</span>
        <span class="cov8" title="1">if source.InstallDeps != nil </span><span class="cov8" title="1">{
                copied.InstallDeps = BoolPtr(*source.InstallDeps)
        }</span>
        <span class="cov8" title="1">if source.CommonPrompt != nil </span><span class="cov8" title="1">{
                copied.CommonPrompt = StringPtr(*source.CommonPrompt)
        }</span>
        <span class="cov8" title="1">if source.MaxAttempts != nil </span><span class="cov8" title="1">{
                copied.MaxAttempts = IntPtr(*source.MaxAttempts)
        }</span>

        // Copy service configuration
        <span class="cov8" title="1">if source.Service != nil </span><span class="cov8" title="1">{
                copied.Service = copyServiceConfig(source.Service)
        }</span>

        // Copy MCP servers
        <span class="cov8" title="1">if source.MCPServers != nil </span><span class="cov0" title="0">{
                copied.MCPServers = make(map[string]MCPServer)
                for k, v := range source.MCPServers </span><span class="cov0" title="0">{
                        copied.MCPServers[k] = copyMCPServer(v)
                }</span>
        }

        // Copy hooks configuration
        <span class="cov8" title="1">copied.Hooks = copyHookConfig(source.Hooks)

        // Copy debug flag
        if source.Debug != nil </span><span class="cov0" title="0">{
                copied.Debug = BoolPtr(*source.Debug)
        }</span>

        // Copy flow configuration
        <span class="cov8" title="1">if len(source.Flow) &gt; 0 </span><span class="cov8" title="1">{
                copied.Flow = make([]FlowStep, len(source.Flow))
                copy(copied.Flow, source.Flow)
        }</span>

        <span class="cov8" title="1">return copied</span>
}

// GetEffectiveSettings returns the effective settings for an agent,
// merging global settings with agent-specific overrides
func (w *Worker) GetEffectiveSettings(globalSettings AgentSettings) AgentSettings <span class="cov8" title="1">{
        effective := copyAgentSettings(globalSettings) // Start with copy of global settings

        // Always merge MCP servers, even if agent settings is nil
        effective.MCPServers = mergeMCPServers(globalSettings.MCPServers, nil, w.MCPServers)

        if w.Settings == nil </span><span class="cov8" title="1">{
                return effective
        }</span>

        // Override with worker-specific settings where provided
        <span class="cov8" title="1">if w.Settings.SleepDuration != nil </span><span class="cov8" title="1">{
                effective.SleepDuration = w.Settings.SleepDuration
        }</span>
        <span class="cov8" title="1">if w.Settings.TeamName != nil </span><span class="cov8" title="1">{
                effective.TeamName = w.Settings.TeamName
        }</span>
        <span class="cov8" title="1">if w.Settings.InstallDeps != nil </span><span class="cov8" title="1">{
                effective.InstallDeps = w.Settings.InstallDeps
        }</span>
        <span class="cov8" title="1">if w.Settings.CommonPrompt != nil </span><span class="cov0" title="0">{
                effective.CommonPrompt = w.Settings.CommonPrompt
        }</span>
        <span class="cov8" title="1">if w.Settings.MaxAttempts != nil </span><span class="cov0" title="0">{
                effective.MaxAttempts = w.Settings.MaxAttempts
        }</span>

        // Merge service configurations
        <span class="cov8" title="1">if len(w.Settings.Service) &gt; 0 </span><span class="cov8" title="1">{
                effective.Service = mergeServiceConfigs(globalSettings.Service, w.Settings.Service)
        }</span>

        // Merge MCP server configurations
        <span class="cov8" title="1">effective.MCPServers = mergeMCPServers(globalSettings.MCPServers, w.Settings.MCPServers, w.MCPServers)

        // Merge hooks configuration
        effective.Hooks = mergeHookConfigs(globalSettings.Hooks, w.Settings.Hooks)

        // Override debug flag
        if w.Settings.Debug != nil </span><span class="cov0" title="0">{
                effective.Debug = w.Settings.Debug
        }</span>

        // Merge flow configuration - agent settings override global
        <span class="cov8" title="1">if len(w.Settings.Flow) &gt; 0 </span><span class="cov0" title="0">{
                effective.Flow = make([]FlowStep, len(w.Settings.Flow))
                copy(effective.Flow, w.Settings.Flow)
        }</span> else<span class="cov8" title="1"> if len(globalSettings.Flow) &gt; 0 </span><span class="cov8" title="1">{
                effective.Flow = make([]FlowStep, len(globalSettings.Flow))
                copy(effective.Flow, globalSettings.Flow)
        }</span>

        <span class="cov8" title="1">return effective</span>
}

// GetAllWorkersWithEffectiveSettings returns a slice of workers with their effective settings
func (c *Config) GetAllWorkersWithEffectiveSettings() []WorkerWithSettings <span class="cov8" title="1">{
        var workers []WorkerWithSettings
        for _, worker := range c.Workers </span><span class="cov8" title="1">{
                workers = append(workers, WorkerWithSettings{
                        Worker:   worker,
                        Settings: worker.GetEffectiveSettings(c.Settings),
                })
        }</span>
        <span class="cov8" title="1">return workers</span>
}

// GetEnabledWorkersWithEffectiveSettings returns only enabled workers with their effective settings
func (c *Config) GetEnabledWorkersWithEffectiveSettings() []WorkerWithSettings <span class="cov8" title="1">{
        var workers []WorkerWithSettings
        for _, worker := range c.Workers </span><span class="cov8" title="1">{
                if worker.IsEnabled() </span><span class="cov8" title="1">{
                        workers = append(workers, WorkerWithSettings{
                                Worker:   worker,
                                Settings: worker.GetEffectiveSettings(c.Settings),
                        })
                }</span>
        }
        <span class="cov8" title="1">return workers</span>
}

type WorkerWithSettings struct {
        Worker   Worker
        Settings AgentSettings
}

// GetConsolidatedPrompt returns the worker prompt combined with common prompt
func (wws *WorkerWithSettings) GetConsolidatedPrompt(cfg *Config) string <span class="cov0" title="0">{
        var promptParts []string

        // Add worker-specific prompt
        if wws.Worker.Prompt != "" </span><span class="cov0" title="0">{
                promptParts = append(promptParts, wws.Worker.Prompt)
        }</span>

        // Add common prompt
        <span class="cov0" title="0">if wws.Settings.CommonPrompt != nil &amp;&amp; *wws.Settings.CommonPrompt != "" </span><span class="cov0" title="0">{
                promptParts = append(promptParts, *wws.Settings.CommonPrompt)
        }</span>

        <span class="cov0" title="0">if len(promptParts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return strings.Join(promptParts, "\n\n")</span>
}

// normalizeAgentName converts agent names to snake_case for use in service names and paths
func normalizeWorkerName(name string) string <span class="cov8" title="1">{
        // Replace any non-alphanumeric characters with underscores
        reg := regexp.MustCompile(`[^a-zA-Z0-9]+`)
        normalized := reg.ReplaceAllString(name, "_")

        // Convert to lowercase
        normalized = strings.ToLower(normalized)

        // Remove leading/trailing underscores
        normalized = strings.Trim(normalized, "_")

        // Replace multiple consecutive underscores with single underscore
        multiUnderscoreReg := regexp.MustCompile(`_+`)
        normalized = multiUnderscoreReg.ReplaceAllString(normalized, "_")

        return normalized
}</span>

// GetNormalizedName returns the normalized agent name suitable for service names and paths
func (w *Worker) GetNormalizedName() string <span class="cov8" title="1">{
        return normalizeWorkerName(w.Name)
}</span>

// GetNormalizedNameWithVariation returns the normalized agent name with a variation (e.g., collector, executor)
// for two-layer architecture using subdirectory structure
func (w *Worker) GetNormalizedNameWithVariation(variation string) string <span class="cov8" title="1">{
        normalizedName := normalizeWorkerName(w.Name)
        if variation == "" </span><span class="cov8" title="1">{
                return normalizedName
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s/%s", normalizedName, variation)</span>
}

// GetWorkerDir returns the worker directory path for use in configurations and volume mounts
func (w *Worker) GetWorkerDir() string <span class="cov0" title="0">{
        return fmt.Sprintf("/opt/autoteam/workers/%s", w.GetNormalizedName())
}</span>

// GetWorkerSubDir returns the worker subdirectory path for a specific variation (e.g., collector, executor)
func (w *Worker) GetWorkerSubDir(variation string) string <span class="cov0" title="0">{
        if variation == "" </span><span class="cov0" title="0">{
                return w.GetWorkerDir()
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s/%s", w.GetWorkerDir(), variation)</span>
}

// IsEnabled returns true if the worker is enabled (default is true)
func (w *Worker) IsEnabled() bool <span class="cov8" title="1">{
        if w.Enabled == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return *w.Enabled</span>
}

// StringPtr returns a pointer to the given string value. Suitable for optional string parameters or configurations.
func StringPtr(s string) *string <span class="cov8" title="1">{
        return &amp;s
}</span>

// IntPtr returns a pointer to the given int value. Suitable for optional int parameters or configurations.
func IntPtr(i int) *int <span class="cov8" title="1">{
        return &amp;i
}</span>

// BoolPtr returns a pointer to the given boolean value.
func BoolPtr(b bool) *bool <span class="cov8" title="1">{
        return &amp;b
}</span>

// Helper methods to get values with defaults for AgentSettings
func (s *AgentSettings) GetSleepDuration() int <span class="cov8" title="1">{
        if s.SleepDuration != nil </span><span class="cov8" title="1">{
                return *s.SleepDuration
        }</span>
        <span class="cov0" title="0">return 60</span> // default
}

func (s *AgentSettings) GetTeamName() string <span class="cov8" title="1">{
        if s.TeamName != nil </span><span class="cov8" title="1">{
                return *s.TeamName
        }</span>
        <span class="cov0" title="0">return DefaultTeamName</span> // default
}

func (s *AgentSettings) GetInstallDeps() bool <span class="cov8" title="1">{
        if s.InstallDeps != nil </span><span class="cov8" title="1">{
                return *s.InstallDeps
        }</span>
        <span class="cov0" title="0">return false</span> // default
}

func (s *AgentSettings) GetCommonPrompt() string <span class="cov0" title="0">{
        if s.CommonPrompt != nil </span><span class="cov0" title="0">{
                return *s.CommonPrompt
        }</span>
        <span class="cov0" title="0">return ""</span> // default
}

func (s *AgentSettings) GetMaxAttempts() int <span class="cov8" title="1">{
        if s.MaxAttempts != nil </span><span class="cov8" title="1">{
                return *s.MaxAttempts
        }</span>
        <span class="cov0" title="0">return 3</span> // default
}

func (s *AgentSettings) GetDebug() bool <span class="cov0" title="0">{
        if s.Debug != nil </span><span class="cov0" title="0">{
                return *s.Debug
        }</span>
        <span class="cov0" title="0">return false</span> // default
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package deps

import (
        "context"
        "fmt"
        "os/exec"

        "autoteam/internal/agent"
        "autoteam/internal/logger"

        "go.uber.org/zap"
)

// DependenciesConfig holds configuration for dependency management
type DependenciesConfig struct {
        InstallDeps bool
}

// Installer handles dependency installation
type Installer struct {
        config DependenciesConfig
}

// NewInstaller creates a new dependency installer
func NewInstaller(cfg DependenciesConfig) *Installer <span class="cov0" title="0">{
        return &amp;Installer{
                config: cfg,
        }
}</span>

// Install checks if all required dependencies are available for multiple agents
func (i *Installer) Install(ctx context.Context, agents ...agent.Agent) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        if !i.config.InstallDeps </span><span class="cov0" title="0">{
                lgr.Info("Dependency checking disabled, skipping")
                return nil
        }</span>

        <span class="cov0" title="0">lgr.Info("Checking dependencies for agents", zap.Int("agent_count", len(agents)))

        // Check shared dependencies once
        if err := i.checkSharedDependencies(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("shared dependencies not available: %w\n\nPlease install missing dependencies manually", err)
        }</span>

        // Check agent-specific dependencies for each agent
        <span class="cov0" title="0">for _, selectedAgent := range agents </span><span class="cov0" title="0">{
                if err := i.checkAgentSpecificDependencies(ctx, selectedAgent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("agent %s dependencies not available: %w", selectedAgent.Type(), err)
                }</span>
        }

        <span class="cov0" title="0">lgr.Info("All dependencies are available")
        return nil</span>
}

// hasCommand checks if a command is available
func (i *Installer) hasCommand(ctx context.Context, command string) bool <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "which", command)
        return cmd.Run() == nil
}</span>

// CheckDependencies checks if all required dependencies are available for multiple agents
func (i *Installer) CheckDependencies(ctx context.Context, agents ...agent.Agent) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)
        lgr.Info("Checking dependencies for agents", zap.Int("agent_count", len(agents)))

        // Check shared dependencies once
        if err := i.checkSharedDependencies(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check each agent's specific dependencies
        <span class="cov0" title="0">for _, selectedAgent := range agents </span><span class="cov0" title="0">{
                if err := i.checkAgentSpecificDependencies(ctx, selectedAgent); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">lgr.Info("All dependencies are available")
        return nil</span>
}

// checkSharedDependencies checks dependencies that are shared across all agents
func (i *Installer) checkSharedDependencies(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Check git
        if !i.hasCommand(ctx, "git") </span><span class="cov0" title="0">{
                return fmt.Errorf("git command not found - please install git")
        }</span>
        <span class="cov0" title="0">lgr.Debug("git is available")

        // Check GitHub CLI
        if !i.hasCommand(ctx, "gh") </span><span class="cov0" title="0">{
                return fmt.Errorf("GitHub CLI (gh) command not found - please install GitHub CLI from https://cli.github.com")
        }</span>
        <span class="cov0" title="0">lgr.Debug("GitHub CLI (gh) is available")

        return nil</span>
}

// checkAgentSpecificDependencies checks dependencies specific to a single agent
func (i *Installer) checkAgentSpecificDependencies(ctx context.Context, selectedAgent agent.Agent) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Check if agent is available - this will also call agent.CheckAvailability() which now just checks
        if err := selectedAgent.CheckAvailability(ctx); err != nil </span><span class="cov0" title="0">{
                return err // Agent.CheckAvailability() now returns detailed error messages with installation instructions
        }</span>

        <span class="cov0" title="0">lgr.Debug("Agent is available", zap.String("agent_type", selectedAgent.Type()))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package flow

import (
        "context"
        "fmt"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "text/template"

        "autoteam/internal/agent"
        "autoteam/internal/config"
        "autoteam/internal/logger"

        "github.com/Masterminds/sprig/v3"
        "go.uber.org/zap"
)

// FlowExecutor executes dynamic flows with dependency resolution
type FlowExecutor struct {
        steps      []config.FlowStep
        agents     map[string]agent.Agent
        mcpServers map[string]config.MCPServer
        workingDir string
        worker     *config.Worker // Worker configuration for template context
}

// StepOutput represents the output of a flow step
type StepOutput struct {
        Name   string
        Stdout string
        Stderr string
}

// FlowResult represents the result of executing a flow
type FlowResult struct {
        Steps   []StepOutput
        Success bool
        Error   error
}

// New creates a new FlowExecutor with the given steps and worker configuration
func New(steps []config.FlowStep, mcpServers map[string]config.MCPServer, workingDir string, worker *config.Worker) *FlowExecutor <span class="cov0" title="0">{
        return &amp;FlowExecutor{
                steps:      steps,
                agents:     make(map[string]agent.Agent),
                mcpServers: mcpServers,
                workingDir: workingDir,
                worker:     worker,
        }
}</span>

// Execute runs the flow with dependency resolution and parallel execution
func (fe *FlowExecutor) Execute(ctx context.Context) (*FlowResult, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)
        lgr.Info("Starting flow execution", zap.Int("total_steps", len(fe.steps)))

        // Validate flow configuration
        if err := fe.validateFlow(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("flow validation failed: %w", err)
        }</span>

        // Resolve dependencies and create execution levels for parallel execution
        <span class="cov0" title="0">dependencyLevels, err := fe.resolveDependencyLevels()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dependency resolution failed: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Info("Flow dependency resolution completed",
                zap.Int("levels", len(dependencyLevels)),
                zap.Any("execution_levels", dependencyLevels))

        // Create agents for each step
        if err := fe.createAgents(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("agent creation failed: %w", err)
        }</span>

        // Execute steps level by level with parallel execution within each level
        <span class="cov0" title="0">stepOutputs := make(map[string]StepOutput)
        stepOutputsMutex := sync.RWMutex{}
        var allStepOutputs []StepOutput

        for levelIndex, level := range dependencyLevels </span><span class="cov0" title="0">{
                lgr.Info("Starting execution level",
                        zap.Int("level_index", levelIndex),
                        zap.Strings("steps", level),
                        zap.Int("parallel_steps", len(level)))

                // Execute all steps in this level in parallel
                levelOutputs, err := fe.executeLevel(ctx, level, stepOutputs, &amp;stepOutputsMutex)
                if err != nil </span><span class="cov0" title="0">{
                        // Add partial results and return error
                        allStepOutputs = append(allStepOutputs, levelOutputs...)
                        return &amp;FlowResult{Steps: allStepOutputs, Success: false, Error: err}, err
                }</span>

                // Store outputs from this level
                <span class="cov0" title="0">stepOutputsMutex.Lock()
                for _, output := range levelOutputs </span><span class="cov0" title="0">{
                        stepOutputs[output.Name] = output
                }</span>
                <span class="cov0" title="0">allStepOutputs = append(allStepOutputs, levelOutputs...)
                stepOutputsMutex.Unlock()

                lgr.Info("Level execution completed",
                        zap.Int("level_index", levelIndex),
                        zap.Int("steps_completed", len(levelOutputs)))</span>
        }

        <span class="cov0" title="0">lgr.Info("Flow execution completed successfully", zap.Int("steps_executed", len(allStepOutputs)))
        return &amp;FlowResult{Steps: allStepOutputs, Success: true}, nil</span>
}

// executeLevel executes all steps in a level in parallel
func (fe *FlowExecutor) executeLevel(ctx context.Context, stepNames []string, stepOutputs map[string]StepOutput, stepOutputsMutex *sync.RWMutex) ([]StepOutput, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        if len(stepNames) == 0 </span><span class="cov0" title="0">{
                return []StepOutput{}, nil
        }</span>

        // For single step, execute directly without goroutines
        <span class="cov0" title="0">if len(stepNames) == 1 </span><span class="cov0" title="0">{
                stepName := stepNames[0]
                step := fe.getStepByName(stepName)
                if step == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("step not found: %s", stepName)
                }</span>

                <span class="cov0" title="0">lgr.Info("Executing single step", zap.String("step_name", step.Name))

                stepOutputsMutex.RLock()
                stepOutputsCopy := make(map[string]StepOutput)
                for k, v := range stepOutputs </span><span class="cov0" title="0">{
                        stepOutputsCopy[k] = v
                }</span>
                <span class="cov0" title="0">stepOutputsMutex.RUnlock()

                output, err := fe.executeStep(ctx, *step, stepOutputsCopy)
                if err != nil </span><span class="cov0" title="0">{
                        return []StepOutput{{Name: step.Name, Stdout: "", Stderr: err.Error()}}, err
                }</span>

                <span class="cov0" title="0">return []StepOutput{*output}, nil</span>
        }

        // For multiple steps, execute in parallel
        <span class="cov0" title="0">lgr.Info("Executing parallel steps", zap.Strings("steps", stepNames))

        type stepResult struct {
                output StepOutput
                err    error
        }

        resultChan := make(chan stepResult, len(stepNames))
        var wg sync.WaitGroup

        // Start parallel execution
        for _, stepName := range stepNames </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(stepName string) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        step := fe.getStepByName(stepName)
                        if step == nil </span><span class="cov0" title="0">{
                                resultChan &lt;- stepResult{
                                        output: StepOutput{Name: stepName, Stdout: "", Stderr: "step not found"},
                                        err:    fmt.Errorf("step not found: %s", stepName),
                                }
                                return
                        }</span>

                        <span class="cov0" title="0">lgr.Info("Starting parallel step execution", zap.String("step_name", step.Name))

                        // Create a copy of stepOutputs for thread safety
                        stepOutputsMutex.RLock()
                        stepOutputsCopy := make(map[string]StepOutput)
                        for k, v := range stepOutputs </span><span class="cov0" title="0">{
                                stepOutputsCopy[k] = v
                        }</span>
                        <span class="cov0" title="0">stepOutputsMutex.RUnlock()

                        // Execute the step
                        output, err := fe.executeStep(ctx, *step, stepOutputsCopy)
                        if err != nil </span><span class="cov0" title="0">{
                                lgr.Error("Parallel step execution failed",
                                        zap.String("step_name", step.Name),
                                        zap.Error(err))
                                resultChan &lt;- stepResult{
                                        output: StepOutput{Name: step.Name, Stdout: "", Stderr: err.Error()},
                                        err:    err,
                                }
                                return
                        }</span>

                        <span class="cov0" title="0">lgr.Info("Parallel step execution completed",
                                zap.String("step_name", step.Name),
                                zap.Int("stdout_length", len(output.Stdout)))

                        resultChan &lt;- stepResult{output: *output, err: nil}</span>
                }(stepName)
        }

        // Wait for all goroutines to complete
        <span class="cov0" title="0">wg.Wait()
        close(resultChan)

        // Collect results
        var outputs []StepOutput
        var firstError error

        for result := range resultChan </span><span class="cov0" title="0">{
                outputs = append(outputs, result.output)
                if result.err != nil &amp;&amp; firstError == nil </span><span class="cov0" title="0">{
                        firstError = result.err
                }</span>
        }

        <span class="cov0" title="0">return outputs, firstError</span>
}

// validateFlow validates the flow configuration
func (fe *FlowExecutor) validateFlow() error <span class="cov0" title="0">{
        if len(fe.steps) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("flow must contain at least one step")
        }</span>

        <span class="cov0" title="0">stepNames := make(map[string]bool)
        for _, step := range fe.steps </span><span class="cov0" title="0">{
                if step.Name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("step name is required")
                }</span>
                <span class="cov0" title="0">if step.Type == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("step type is required for step: %s", step.Name)
                }</span>
                <span class="cov0" title="0">if stepNames[step.Name] </span><span class="cov0" title="0">{
                        return fmt.Errorf("duplicate step name: %s", step.Name)
                }</span>
                <span class="cov0" title="0">stepNames[step.Name] = true

                // Validate dependencies exist
                for _, dep := range step.DependsOn </span><span class="cov0" title="0">{
                        if !stepNames[dep] &amp;&amp; !fe.stepExistsInFlow(dep) </span><span class="cov0" title="0">{
                                return fmt.Errorf("step %s depends on non-existent step: %s", step.Name, dep)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// stepExistsInFlow checks if a step name exists in the flow
func (fe *FlowExecutor) stepExistsInFlow(stepName string) bool <span class="cov0" title="0">{
        for _, step := range fe.steps </span><span class="cov0" title="0">{
                if step.Name == stepName </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// resolveDependencyLevels groups steps by dependency levels for parallel execution
func (fe *FlowExecutor) resolveDependencyLevels() ([][]string, error) <span class="cov0" title="0">{
        // Build dependency graph
        graph := make(map[string][]string)
        inDegree := make(map[string]int)

        // Initialize graph and in-degree count
        for _, step := range fe.steps </span><span class="cov0" title="0">{
                graph[step.Name] = []string{}
                inDegree[step.Name] = 0
        }</span>

        // Build edges and calculate in-degrees
        <span class="cov0" title="0">for _, step := range fe.steps </span><span class="cov0" title="0">{
                for _, dep := range step.DependsOn </span><span class="cov0" title="0">{
                        graph[dep] = append(graph[dep], step.Name)
                        inDegree[step.Name]++
                }</span>
        }

        <span class="cov0" title="0">var levels [][]string
        remainingSteps := len(fe.steps)

        // Process steps level by level
        for remainingSteps &gt; 0 </span><span class="cov0" title="0">{
                var currentLevel []string

                // Find all nodes with no incoming edges (ready to execute)
                for stepName, degree := range inDegree </span><span class="cov0" title="0">{
                        if degree == 0 </span><span class="cov0" title="0">{
                                currentLevel = append(currentLevel, stepName)
                        }</span>
                }

                // Check if we found any steps for this level
                <span class="cov0" title="0">if len(currentLevel) == 0 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("circular dependency detected in flow")
                }</span>

                // Sort current level for deterministic ordering
                <span class="cov0" title="0">sort.Strings(currentLevel)
                levels = append(levels, currentLevel)

                // Remove current level steps and update in-degrees
                for _, stepName := range currentLevel </span><span class="cov0" title="0">{
                        // Mark as processed by setting in-degree to -1
                        inDegree[stepName] = -1
                        remainingSteps--

                        // Reduce in-degree for dependent steps
                        for _, neighbor := range graph[stepName] </span><span class="cov0" title="0">{
                                if inDegree[neighbor] &gt; 0 </span><span class="cov0" title="0">{
                                        inDegree[neighbor]--
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return levels, nil</span>
}

// createAgents creates agent instances for each step in the flow
func (fe *FlowExecutor) createAgents(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        for _, step := range fe.steps </span><span class="cov0" title="0">{
                // Create agent config from step
                agentConfig := config.AgentConfig{
                        Type: step.Type,
                        Args: step.Args,
                        Env:  step.Env,
                }

                // Create agent with working directory + step name for proper MCP config paths
                // Extract just the directory name from workingDir (e.g., "senior_developer" from "/opt/autoteam/workers/senior_developer")
                baseName := filepath.Base(fe.workingDir)
                fullAgentName := fmt.Sprintf("%s/%s", baseName, step.Name)
                stepAgent, err := agent.CreateAgent(agentConfig, fullAgentName, fe.mcpServers)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create agent for step %s: %w", step.Name, err)
                }</span>

                <span class="cov0" title="0">fe.agents[step.Name] = stepAgent

                // Configure MCP servers if the agent supports configuration
                if configurable, ok := stepAgent.(agent.Configurable); ok </span><span class="cov0" title="0">{
                        lgr.Info("Configuring MCP servers for agent",
                                zap.String("step_name", step.Name),
                                zap.String("agent_type", step.Type),
                                zap.Int("mcp_servers", len(fe.mcpServers)))

                        if err := configurable.Configure(ctx); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to configure MCP servers for step %s: %w", step.Name, err)
                        }</span>

                        <span class="cov0" title="0">lgr.Info("MCP servers configured successfully for agent",
                                zap.String("step_name", step.Name))</span>
                } else<span class="cov0" title="0"> {
                        lgr.Debug("Agent does not support MCP configuration",
                                zap.String("step_name", step.Name),
                                zap.String("agent_type", step.Type))
                }</span>

                <span class="cov0" title="0">lgr.Info("Created agent for flow step",
                        zap.String("step_name", step.Name),
                        zap.String("agent_type", step.Type))</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// executeStep executes a single flow step
func (fe *FlowExecutor) executeStep(ctx context.Context, step config.FlowStep, previousOutputs map[string]StepOutput) (*StepOutput, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Check skip condition first
        shouldSkip, err := fe.evaluateSkipCondition(ctx, step, previousOutputs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to evaluate skip condition for step %s: %w", step.Name, err)
        }</span>

        <span class="cov0" title="0">if shouldSkip </span><span class="cov0" title="0">{
                lgr.Info("Skipping step due to skip condition",
                        zap.String("step_name", step.Name),
                        zap.String("skip_when", step.SkipWhen))

                // Return empty output for skipped step
                return &amp;StepOutput{
                        Name:   step.Name,
                        Stdout: "",
                        Stderr: "",
                }, nil
        }</span>

        // Get agent for this step
        <span class="cov0" title="0">stepAgent, exists := fe.agents[step.Name]
        if !exists </span><span class="cov0" title="0">{
                // Debug: list all available agents
                var availableAgents []string
                for agentName := range fe.agents </span><span class="cov0" title="0">{
                        availableAgents = append(availableAgents, agentName)
                }</span>
                <span class="cov0" title="0">lgr.Error("Agent not found for step",
                        zap.String("step_name", step.Name),
                        zap.Strings("available_agents", availableAgents))
                return nil, fmt.Errorf("agent not found for step: %s", step.Name)</span>
        }

        // Prepare input data for template processing
        <span class="cov0" title="0">inputData := fe.prepareInputData(step, previousOutputs)

        // Process input field as template if it contains template syntax
        prompt := step.Input
        if step.Input != "" </span><span class="cov0" title="0">{
                transformedInput, transformErr := fe.applyTemplate(step.Input, inputData)
                if transformErr != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Input template processing failed, using original input",
                                zap.String("step_name", step.Name),
                                zap.String("input_template", step.Input),
                                zap.Error(transformErr))
                }</span> else<span class="cov0" title="0"> {
                        prompt = transformedInput
                }</span>
        }

        // Log step input for debugging
        <span class="cov0" title="0">lgr.Info("Starting step execution",
                zap.String("step_name", step.Name),
                zap.String("agent_type", step.Type),
                zap.String("prompt", prompt))

        // Set up run options
        runOptions := agent.RunOptions{
                MaxRetries:       1,
                ContinueMode:     false,
                WorkingDirectory: fmt.Sprintf("%s/%s", fe.workingDir, step.Name),
        }

        // Execute agent
        output, err := stepAgent.Run(ctx, prompt, runOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("agent execution failed for step %s: %w", step.Name, err)
        }</span>

        // Log raw agent output for debugging
        <span class="cov0" title="0">lgr.Info("Agent execution completed",
                zap.String("step_name", step.Name),
                zap.String("agent_type", step.Type),
                zap.String("raw_stdout", output.Stdout),
                zap.String("raw_stderr", output.Stderr))

        // Apply output transformation if specified
        stdout := output.Stdout
        if step.Output != "" </span><span class="cov0" title="0">{
                templateData := map[string]interface{}{
                        "stdout": output.Stdout,
                        "stderr": output.Stderr,
                }

                transformedOutput, err := fe.applyTemplate(step.Output, templateData)
                if err != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Output transformation failed, using raw output",
                                zap.String("step_name", step.Name),
                                zap.String("output_template", step.Output),
                                zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        stdout = transformedOutput
                        lgr.Info("Output transformed successfully",
                                zap.String("step_name", step.Name),
                                zap.String("transformed_output", stdout))
                }</span>
        }

        // Log final step output
        <span class="cov0" title="0">lgr.Info("Step execution finished",
                zap.String("step_name", step.Name),
                zap.String("final_stdout", stdout),
                zap.String("final_stderr", output.Stderr))

        return &amp;StepOutput{
                Name:   step.Name,
                Stdout: stdout,
                Stderr: output.Stderr,
        }, nil</span>
}

// prepareInputData prepares template data for input transformation
func (fe *FlowExecutor) prepareInputData(step config.FlowStep, previousOutputs map[string]StepOutput) map[string]interface{} <span class="cov0" title="0">{
        // Collect inputs from dependencies
        var inputs []string
        for _, dep := range step.DependsOn </span><span class="cov0" title="0">{
                if output, exists := previousOutputs[dep]; exists </span><span class="cov0" title="0">{
                        inputs = append(inputs, output.Stdout)
                }</span>
        }

        <span class="cov0" title="0">return map[string]interface{}{
                "inputs": inputs,
                "step":   step,
                "flow": map[string]interface{}{
                        "worker": fe.worker,
                },
        }</span>
}

// evaluateSkipCondition evaluates a skip condition template and returns true if step should be skipped
func (fe *FlowExecutor) evaluateSkipCondition(ctx context.Context, step config.FlowStep, previousOutputs map[string]StepOutput) (bool, error) <span class="cov0" title="0">{
        if step.SkipWhen == "" </span><span class="cov0" title="0">{
                return false, nil // No skip condition defined
        }</span>

        <span class="cov0" title="0">lgr := logger.FromContext(ctx)

        // Prepare input data for skip condition evaluation (same as input transformers)
        inputData := fe.prepareInputData(step, previousOutputs)

        lgr.Debug("Evaluating skip condition",
                zap.String("step_name", step.Name),
                zap.String("skip_when", step.SkipWhen),
                zap.Any("input_data", inputData))

        // Evaluate the skip condition template
        result, err := fe.applyTemplate(step.SkipWhen, inputData)
        if err != nil </span><span class="cov0" title="0">{
                lgr.Warn("Skip condition template execution failed, assuming step should not be skipped",
                        zap.String("step_name", step.Name),
                        zap.String("skip_when", step.SkipWhen),
                        zap.Error(err))
                return false, nil // Don't skip if template fails
        }</span>

        // Trim whitespace and check if result is "true"
        <span class="cov0" title="0">shouldSkip := strings.TrimSpace(result) == "true"

        lgr.Info("Skip condition evaluated",
                zap.String("step_name", step.Name),
                zap.String("condition_result", result),
                zap.Bool("should_skip", shouldSkip))

        return shouldSkip, nil</span>
}

// applyTemplate applies a Sprig template to the given data
func (fe *FlowExecutor) applyTemplate(templateStr string, data interface{}) (string, error) <span class="cov0" title="0">{
        // Create template with Sprig functions
        tmpl, err := template.New("transform").Funcs(sprig.FuncMap()).Parse(templateStr)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("template parsing failed: %w", err)
        }</span>

        // Execute template
        <span class="cov0" title="0">var buf strings.Builder
        if err := tmpl.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("template execution failed: %w", err)
        }</span>

        <span class="cov0" title="0">return buf.String(), nil</span>
}

// getStepByName finds a step by its name
func (fe *FlowExecutor) getStepByName(name string) *config.FlowStep <span class="cov0" title="0">{
        for _, step := range fe.steps </span><span class="cov0" title="0">{
                if step.Name == name </span><span class="cov0" title="0">{
                        return &amp;step
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package generator

import (
        "fmt"
        "os"
        "path/filepath"

        "autoteam/internal/config"
)

// FileOperations handles file and directory operations for the generator
type FileOperations struct{}

// NewFileOperations creates a new FileOperations instance
func NewFileOperations() *FileOperations <span class="cov8" title="1">{
        return &amp;FileOperations{}
}</span>

// EnsureDirectory creates a directory if it doesn't exist
func (f *FileOperations) EnsureDirectory(path string, perm os.FileMode) error <span class="cov8" title="1">{
        if err := f.ValidatePath(path); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid path %s: %w", path, err)
        }</span>

        <span class="cov8" title="1">if err := os.MkdirAll(path, perm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory %s: %w", path, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RemoveIfExists removes a file or directory if it exists
func (f *FileOperations) RemoveIfExists(path string) error <span class="cov8" title="1">{
        if err := f.ValidatePath(path); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid path %s: %w", path, err)
        }</span>

        <span class="cov8" title="1">if _, err := os.Lstat(path); err == nil </span><span class="cov0" title="0">{
                if err := os.RemoveAll(path); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove %s: %w", path, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// WriteFileIfNotExists writes content to a file only if it doesn't exist
func (f *FileOperations) WriteFileIfNotExists(path string, content []byte, perm os.FileMode) error <span class="cov0" title="0">{
        if err := f.ValidatePath(path); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid path %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                if err := os.WriteFile(path, content, perm); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write file %s: %w", path, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CopyDirectory recursively copies a directory from src to dst
func (f *FileOperations) CopyDirectory(src, dst string) error <span class="cov8" title="1">{
        if err := f.ValidatePath(src); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid source path %s: %w", src, err)
        }</span>
        <span class="cov8" title="1">if err := f.ValidatePath(dst); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid destination path %s: %w", dst, err)
        }</span>

        // Create destination directory
        <span class="cov8" title="1">if err := f.EnsureDirectory(dst, config.DirPerm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination directory: %w", err)
        }</span>

        // Read source directory
        <span class="cov8" title="1">entries, err := os.ReadDir(src)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read source directory %s: %w", src, err)
        }</span>

        // Copy each entry
        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                srcPath := filepath.Join(src, entry.Name())
                dstPath := filepath.Join(dst, entry.Name())

                if entry.IsDir() </span><span class="cov0" title="0">{
                        // Recursively copy subdirectory
                        if err := f.CopyDirectory(srcPath, dstPath); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to copy subdirectory %s: %w", entry.Name(), err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Copy file
                        if err := f.CopyFile(srcPath, dstPath); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to copy file %s: %w", entry.Name(), err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// CopyFile copies a single file from src to dst with preserved permissions
func (f *FileOperations) CopyFile(src, dst string) error <span class="cov8" title="1">{
        if err := f.ValidatePath(src); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid source path %s: %w", src, err)
        }</span>
        <span class="cov8" title="1">if err := f.ValidatePath(dst); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid destination path %s: %w", dst, err)
        }</span>

        // Read source file
        <span class="cov8" title="1">srcData, err := os.ReadFile(src)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read source file %s: %w", src, err)
        }</span>

        // Get source file permissions
        <span class="cov8" title="1">srcInfo, err := os.Stat(src)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get source file info for %s: %w", src, err)
        }</span>

        // Write destination file with same permissions
        <span class="cov8" title="1">if err := os.WriteFile(dst, srcData, srcInfo.Mode()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write destination file %s: %w", dst, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DirectoryExists checks if a directory exists
func (f *FileOperations) DirectoryExists(path string) bool <span class="cov8" title="1">{
        if err := f.ValidatePath(path); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return info.IsDir()</span>
}

// ValidatePath performs basic validation on file paths
func (f *FileOperations) ValidatePath(path string) error <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("path cannot be empty")
        }</span>

        // Check for path traversal attempts
        <span class="cov8" title="1">cleanPath := filepath.Clean(path)
        if cleanPath != path &amp;&amp; !filepath.IsAbs(path) </span><span class="cov0" title="0">{
                return fmt.Errorf("potentially unsafe path detected")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CreateWorkerDirectoryStructure creates the complete directory structure for a worker
func (f *FileOperations) CreateWorkerDirectoryStructure(workerName string) error <span class="cov8" title="1">{
        workerDir := filepath.Join(config.WorkersDir, workerName)

        // Create main worker directory - subdirectories will be created as needed by individual layers
        if err := f.EnsureDirectory(workerDir, config.DirPerm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create worker directory for worker %s: %w", workerName, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package generator

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "autoteam/internal/config"
        "autoteam/internal/ports"

        "gopkg.in/yaml.v3"
)

// ComposeConfig represents the structure of a Docker Compose file
type ComposeConfig struct {
        Services map[string]interface{} `yaml:"services"`
        Volumes  map[string]interface{} `yaml:"volumes,omitempty"`
}

type Generator struct {
        fileOps *FileOperations
}

func New() *Generator <span class="cov8" title="1">{
        return &amp;Generator{
                fileOps: NewFileOperations(),
        }
}</span>

// normalizeEnvironmentValue replaces AutoTeam placeholder variables with actual runtime values.
// Supported placeholders:
//   - ${AUTOTEAM_AGENT_NAME} -&gt; actual agent name (e.g., "Senior Developer")
//   - ${AUTOTEAM_WORKER_DIR}  -&gt; agent directory path (e.g., "/opt/autoteam/workers/senior_developer")
//   - ${AUTOTEAM_AGENT_NORMALIZED_NAME} -&gt; normalized agent name (e.g., "senior_developer")
func (g *Generator) normalizeEnvironmentValue(value string, worker config.Worker) string <span class="cov0" title="0">{
        value = strings.ReplaceAll(value, "${AUTOTEAM_AGENT_NAME}", worker.Name)
        value = strings.ReplaceAll(value, "${AUTOTEAM_WORKER_DIR}", worker.GetWorkerDir())
        value = strings.ReplaceAll(value, "${AUTOTEAM_AGENT_NORMALIZED_NAME}", worker.GetNormalizedName())
        return value
}</span>

func (g *Generator) GenerateCompose(cfg *config.Config) error <span class="cov8" title="1">{
        return g.GenerateComposeWithPorts(cfg, nil)
}</span>

func (g *Generator) GenerateComposeWithPorts(cfg *config.Config, portAllocation ports.PortAllocation) error <span class="cov8" title="1">{
        // Ensure .autoteam directory exists
        if err := g.fileOps.EnsureDirectory(config.AutoTeamDir, config.DirPerm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create .autoteam directory: %w", err)
        }</span>

        // Ensure worker directories exist
        <span class="cov8" title="1">if err := g.createWorkerDirectories(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create worker directories: %w", err)
        }</span>

        // Generate worker config files
        <span class="cov8" title="1">if err := g.generateAgentConfigFiles(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate agent config files: %w", err)
        }</span>

        // Generate compose.yaml programmatically
        <span class="cov8" title="1">if err := g.generateComposeYAML(cfg, portAllocation); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate compose.yaml: %w", err)
        }</span>

        // Copy system bin directory
        <span class="cov8" title="1">if err := g.copyBinDirectory(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy bin directory: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// generateComposeYAML creates a Docker Compose YAML file programmatically
func (g *Generator) generateComposeYAML(cfg *config.Config, portAllocation ports.PortAllocation) error <span class="cov8" title="1">{
        compose := ComposeConfig{
                Services: make(map[string]interface{}),
        }

        // Get only enabled agents with their effective settings
        workersWithSettings := cfg.GetEnabledWorkersWithEffectiveSettings()

        for _, workerWithSettings := range workersWithSettings </span><span class="cov8" title="1">{
                worker := workerWithSettings.Worker
                settings := workerWithSettings.Settings
                serviceName := worker.GetNormalizedName()

                // Start with the service configuration from settings
                serviceConfig := make(map[string]interface{})

                // Copy all service properties from effective settings
                if settings.Service != nil </span><span class="cov8" title="1">{
                        for key, value := range settings.Service </span><span class="cov8" title="1">{
                                serviceConfig[key] = value
                        }</span>
                }

                // Add standard Docker Compose properties that are always needed
                <span class="cov8" title="1">serviceConfig["tty"] = true
                serviceConfig["stdin_open"] = true

                // Build volumes array
                volumes := []string{
                        fmt.Sprintf("./workers/%s:%s", serviceName, worker.GetWorkerDir()),
                        "./bin:/opt/autoteam/bin",
                }

                // Add any additional volumes from service config
                if existingVolumes, ok := serviceConfig["volumes"]; ok </span><span class="cov8" title="1">{
                        if volumeSlice, ok := existingVolumes.([]string); ok </span><span class="cov8" title="1">{
                                volumes = append(volumes, volumeSlice...)
                        }</span> else<span class="cov0" title="0"> if volumeInterface, ok := existingVolumes.([]interface{}); ok </span><span class="cov0" title="0">{
                                // Handle case where YAML unmarshals to []interface{}
                                for _, v := range volumeInterface </span><span class="cov0" title="0">{
                                        if volumeStr, ok := v.(string); ok </span><span class="cov0" title="0">{
                                                volumes = append(volumes, volumeStr)
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">serviceConfig["volumes"] = volumes

                // Build environment variables - now we only need the config file path
                environment := make(map[string]string)

                // Set the path to the worker's config file
                environment["CONFIG_FILE"] = fmt.Sprintf("%s/config.yaml", worker.GetWorkerDir())

                // Set AutoTeam worker runtime variables with consistent AUTOTEAM_ prefix
                environment["AUTOTEAM_AGENT_NAME"] = worker.Name
                environment["AUTOTEAM_WORKER_DIR"] = worker.GetWorkerDir()
                environment["AUTOTEAM_AGENT_NORMALIZED_NAME"] = worker.GetNormalizedName()

                // Keep some optional runtime variables that can be overridden
                environment["DEBUG"] = "${DEBUG:-false}"
                environment["LOG_LEVEL"] = "${LOG_LEVEL:-info}"

                // Merge with environment from service config and normalize placeholder variables
                if existingEnv, ok := serviceConfig["environment"]; ok </span><span class="cov0" title="0">{
                        // Handle both map[string]string and map[string]interface{} cases
                        if envMap, ok := existingEnv.(map[string]string); ok </span><span class="cov0" title="0">{
                                for k, v := range envMap </span><span class="cov0" title="0">{
                                        environment[k] = g.normalizeEnvironmentValue(v, worker)
                                }</span>
                        } else<span class="cov0" title="0"> if envMapInterface, ok := existingEnv.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                for k, v := range envMapInterface </span><span class="cov0" title="0">{
                                        if vStr, ok := v.(string); ok </span><span class="cov0" title="0">{
                                                environment[k] = g.normalizeEnvironmentValue(vStr, worker)
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">serviceConfig["environment"] = environment

                // Set default entrypoint if not specified
                if _, hasEntrypoint := serviceConfig["entrypoint"]; !hasEntrypoint </span><span class="cov8" title="1">{
                        serviceConfig["entrypoint"] = []string{"/opt/autoteam/bin/entrypoint.sh"}
                }</span>

                // Add port mapping if ports are allocated
                <span class="cov8" title="1">if portAllocation != nil </span><span class="cov0" title="0">{
                        if port, hasPort := portAllocation[serviceName]; hasPort </span><span class="cov0" title="0">{
                                // Add port mapping: host:container (8080 is the default container port)
                                portMappings := []string{fmt.Sprintf("%d:8080", port)}

                                // Merge with existing ports if any
                                if existingPorts, ok := serviceConfig["ports"]; ok </span><span class="cov0" title="0">{
                                        if portSlice, ok := existingPorts.([]string); ok </span><span class="cov0" title="0">{
                                                portMappings = append(portMappings, portSlice...)
                                        }</span> else<span class="cov0" title="0"> if portInterface, ok := existingPorts.([]interface{}); ok </span><span class="cov0" title="0">{
                                                for _, p := range portInterface </span><span class="cov0" title="0">{
                                                        if portStr, ok := p.(string); ok </span><span class="cov0" title="0">{
                                                                portMappings = append(portMappings, portStr)
                                                        }</span>
                                                }
                                        }
                                }
                                <span class="cov0" title="0">serviceConfig["ports"] = portMappings</span>
                        }
                }

                <span class="cov8" title="1">compose.Services[serviceName] = serviceConfig</span>
        }

        // Add custom services from configuration
        <span class="cov8" title="1">if cfg.Services != nil </span><span class="cov0" title="0">{
                for serviceName, serviceConfig := range cfg.Services </span><span class="cov0" title="0">{
                        // Check for conflicts with agent services
                        if _, exists := compose.Services[serviceName]; exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("custom service '%s' conflicts with generated agent service - please choose a different name", serviceName)
                        }</span>

                        // Add custom service directly to compose
                        <span class="cov0" title="0">compose.Services[serviceName] = serviceConfig</span>
                }
        }

        // Auto-detect and create named volume definitions
        <span class="cov8" title="1">namedVolumes := g.detectNamedVolumes(compose.Services)
        if len(namedVolumes) &gt; 0 </span><span class="cov0" title="0">{
                compose.Volumes = make(map[string]interface{})
                for volumeName := range namedVolumes </span><span class="cov0" title="0">{
                        // Create empty volume definition (external volumes can be customized later)
                        compose.Volumes[volumeName] = map[string]interface{}{}
                }</span>
        }

        // Marshal to YAML
        <span class="cov8" title="1">yamlData, err := yaml.Marshal(&amp;compose)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal compose config to YAML: %w", err)
        }</span>

        // Write to file
        <span class="cov8" title="1">if err := os.WriteFile(config.ComposeFilePath, yamlData, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write compose.yaml file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (g *Generator) copyBinDirectory() error <span class="cov8" title="1">{
        // Ensure workers directory exists
        if err := g.fileOps.EnsureDirectory(config.WorkersDir, config.DirPerm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create workers directory: %w", err)
        }</span>

        // Remove existing directory if it exists
        <span class="cov8" title="1">if err := g.fileOps.RemoveIfExists(config.LocalBinPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove existing bin directory: %w", err)
        }</span>

        // Check if system bin directory exists
        <span class="cov8" title="1">sourceDir := config.SystemBinDir
        if !g.fileOps.DirectoryExists(config.SystemBinDir) </span><span class="cov0" title="0">{
                // Fallback: check for old entrypoints directory for backward compatibility
                oldEntrypointsDir := "/opt/autoteam/entrypoints"
                if g.fileOps.DirectoryExists(oldEntrypointsDir) </span><span class="cov0" title="0">{
                        sourceDir = oldEntrypointsDir
                }</span> else<span class="cov0" title="0"> {
                        // Neither directory exists - create a temporary directory with a helpful message
                        if err := g.fileOps.EnsureDirectory(config.LocalBinPath, config.DirPerm); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create temporary bin directory: %w", err)
                        }</span>

                        <span class="cov0" title="0">readmePath := filepath.Join(config.LocalBinPath, config.ReadmeFile)
                        readmeContent := `# AutoTeam Binary Directory

This directory should contain all AutoTeam binaries including:
- Entrypoint scripts for different platforms
- MCP servers (github-mcp-server, etc.)
- Other runtime binaries

To install the binaries system-wide, run:
` + "```bash" + `
make install
` + "```" + `

This will:
1. Install all binaries for supported platforms to ` + config.SystemBinDir + `
2. Copy the binaries to this local directory during generation

Supported platforms:
- linux-amd64
- linux-arm64  
- darwin-amd64
- darwin-arm64
`

                        if err := g.fileOps.WriteFileIfNotExists(readmePath, []byte(readmeContent), config.ReadmePerm); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create README file: %w", err)
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                }
        }

        // Copy system bin directory (or fallback entrypoints directory) to local directory
        <span class="cov8" title="1">return g.fileOps.CopyDirectory(sourceDir, config.LocalBinPath)</span>
}

func (g *Generator) createWorkerDirectories(cfg *config.Config) error <span class="cov8" title="1">{
        for _, worker := range cfg.Workers </span><span class="cov8" title="1">{
                // Skip disabled agents
                if !worker.IsEnabled() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">normalizedName := worker.GetNormalizedName()
                if err := g.fileOps.CreateWorkerDirectoryStructure(normalizedName); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory structure for worker %s (normalized: %s): %w", worker.Name, normalizedName, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// detectNamedVolumes scans all services for named volume references and returns a set of volume names
func (g *Generator) detectNamedVolumes(services map[string]interface{}) map[string]bool <span class="cov8" title="1">{
        namedVolumes := make(map[string]bool)
        // Regex to match named volumes (e.g., "postgres_data:/var/lib/postgresql/data")
        // Named volumes don't start with ./ or / (those are bind mounts)
        namedVolumeRegex := regexp.MustCompile(`^([^/.][^:/]*):`)

        for _, serviceConfig := range services </span><span class="cov8" title="1">{
                if serviceMap, ok := serviceConfig.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        if volumes, exists := serviceMap["volumes"]; exists </span><span class="cov8" title="1">{
                                // Handle both []string and []interface{} volume formats
                                if volumeSlice, ok := volumes.([]string); ok </span><span class="cov8" title="1">{
                                        for _, volume := range volumeSlice </span><span class="cov8" title="1">{
                                                if matches := namedVolumeRegex.FindStringSubmatch(volume); matches != nil </span><span class="cov0" title="0">{
                                                        namedVolumes[matches[1]] = true
                                                }</span>
                                        }
                                } else<span class="cov0" title="0"> if volumeInterface, ok := volumes.([]interface{}); ok </span><span class="cov0" title="0">{
                                        for _, v := range volumeInterface </span><span class="cov0" title="0">{
                                                if volumeStr, ok := v.(string); ok </span><span class="cov0" title="0">{
                                                        if matches := namedVolumeRegex.FindStringSubmatch(volumeStr); matches != nil </span><span class="cov0" title="0">{
                                                                namedVolumes[matches[1]] = true
                                                        }</span>
                                                }
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return namedVolumes</span>
}

// generateAgentConfigFiles creates YAML config files for each enabled agent
func (g *Generator) generateAgentConfigFiles(cfg *config.Config) error <span class="cov8" title="1">{
        for _, worker := range cfg.Workers </span><span class="cov8" title="1">{
                // Skip disabled agents
                if !worker.IsEnabled() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">settings := worker.GetEffectiveSettings(cfg.Settings)
                workerWithSettings := &amp;config.WorkerWithSettings{Worker: worker, Settings: settings}
                serviceName := worker.GetNormalizedName()

                // Build the worker config (now we generate worker config directly)
                workerConfig := &amp;config.Worker{
                        Name:       worker.Name,
                        Prompt:     workerWithSettings.GetConsolidatedPrompt(cfg),
                        Settings:   &amp;settings,
                        MCPServers: worker.MCPServers,
                }

                // Create worker config directory
                workerDir := filepath.Join(config.WorkersDir, serviceName)
                if err := os.MkdirAll(workerDir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create worker config directory %s: %w", workerDir, err)
                }</span>

                // Write config file
                <span class="cov8" title="1">configPath := filepath.Join(workerDir, "config.yaml")
                configData, err := yaml.Marshal(workerConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal config for worker %s: %w", worker.Name, err)
                }</span>

                <span class="cov8" title="1">if err := os.WriteFile(configPath, configData, 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write config file %s: %w", configPath, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package generator

import (
        "strings"
        "text/template"
)

// GetTemplateFunctions returns the template functions map for use in templates
func GetTemplateFunctions() template.FuncMap <span class="cov0" title="0">{
        return template.FuncMap{
                "indent":              indentFunction,
                "escapeDockerCompose": escapeDockerComposeFunction,
                "join":                joinFunction,
                "add":                 addFunction,
        }
}</span>

// indentFunction indents each line of text by the specified number of spaces
func indentFunction(spaces int, text string) string <span class="cov0" title="0">{
        if text == "" </span><span class="cov0" title="0">{
                return text
        }</span>

        // Create the indentation string
        <span class="cov0" title="0">indentation := strings.Repeat(" ", spaces)

        // Split text into lines and add indentation to each line
        lines := strings.Split(text, "\n")
        for i, line := range lines </span><span class="cov0" title="0">{
                if line != "" </span><span class="cov0" title="0">{ // Don't indent empty lines
                        lines[i] = indentation + line
                }</span>
        }

        <span class="cov0" title="0">return strings.Join(lines, "\n")</span>
}

// escapeDockerComposeFunction escapes single $ with $$ for Docker Compose
// This prevents Docker Compose from trying to substitute shell variables
func escapeDockerComposeFunction(text string) string <span class="cov0" title="0">{
        return strings.ReplaceAll(text, "$", "$$")
}</span>

// joinFunction joins a slice of strings with a separator
func joinFunction(slice []string, separator string) string <span class="cov0" title="0">{
        return strings.Join(slice, separator)
}</span>

// addFunction adds two integers
func addFunction(a, b int) int <span class="cov0" title="0">{
        return a + b
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package logger

import (
        "context"
        "fmt"
        "strings"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// LogLevel represents the logging level
type LogLevel string

const (
        DebugLevel LogLevel = "debug"
        InfoLevel  LogLevel = "info"
        WarnLevel  LogLevel = "warn"
        ErrorLevel LogLevel = "error"
)

// ParseLogLevel parses a string into a LogLevel
func ParseLogLevel(level string) (LogLevel, error) <span class="cov0" title="0">{
        switch strings.ToLower(level) </span>{
        case "debug":<span class="cov0" title="0">
                return DebugLevel, nil</span>
        case "info":<span class="cov0" title="0">
                return InfoLevel, nil</span>
        case "warn", "warning":<span class="cov0" title="0">
                return WarnLevel, nil</span>
        case "error":<span class="cov0" title="0">
                return ErrorLevel, nil</span>
        default:<span class="cov0" title="0">
                return InfoLevel, fmt.Errorf("invalid log level: %s", level)</span>
        }
}

// zapLevel converts LogLevel to zapcore.Level
func (l LogLevel) zapLevel() zapcore.Level <span class="cov0" title="0">{
        switch l </span>{
        case DebugLevel:<span class="cov0" title="0">
                return zapcore.DebugLevel</span>
        case InfoLevel:<span class="cov0" title="0">
                return zapcore.InfoLevel</span>
        case WarnLevel:<span class="cov0" title="0">
                return zapcore.WarnLevel</span>
        case ErrorLevel:<span class="cov0" title="0">
                return zapcore.ErrorLevel</span>
        default:<span class="cov0" title="0">
                return zapcore.InfoLevel</span>
        }
}

type contextKey struct{}

var loggerKey = contextKey{}

// NewLogger creates a new zap logger with the specified level
func NewLogger(level LogLevel) (*zap.Logger, error) <span class="cov0" title="0">{
        config := zap.NewProductionConfig()
        config.Level = zap.NewAtomicLevelAt(level.zapLevel())
        config.EncoderConfig.TimeKey = "timestamp"
        config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        config.EncoderConfig.CallerKey = "caller"
        config.EncoderConfig.EncodeCaller = zapcore.ShortCallerEncoder

        // Use console encoder for better readability
        config.Encoding = "console"
        config.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
        config.DisableStacktrace = true // Reduce noise

        return config.Build(zap.AddCallerSkip(1))
}</span>

// WithLogger adds a logger to the context
func WithLogger(ctx context.Context, logger *zap.Logger) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, loggerKey, logger)
}</span>

// FromContext retrieves the logger from the context
// If no logger is found, it creates a default info-level logger
func FromContext(ctx context.Context) *zap.Logger <span class="cov0" title="0">{
        if logger, ok := ctx.Value(loggerKey).(*zap.Logger); ok </span><span class="cov0" title="0">{
                return logger
        }</span>

        // Fallback to default logger
        <span class="cov0" title="0">logger, err := NewLogger(InfoLevel)
        if err != nil </span><span class="cov0" title="0">{
                // Last resort - use no-op logger
                return zap.NewNop()
        }</span>
        <span class="cov0" title="0">return logger</span>
}

// SetupContext creates a context with a logger configured at the specified level
func SetupContext(ctx context.Context, level LogLevel) (context.Context, error) <span class="cov0" title="0">{
        logger, err := NewLogger(level)
        if err != nil </span><span class="cov0" title="0">{
                return ctx, fmt.Errorf("failed to create logger: %w", err)
        }</span>

        <span class="cov0" title="0">return WithLogger(ctx, logger), nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package monitor

import (
        "context"
        "fmt"
        "time"

        "autoteam/internal/agent"
        "autoteam/internal/config"
        "autoteam/internal/flow"
        "autoteam/internal/logger"
        "autoteam/internal/task"

        "go.uber.org/zap"
)

// Config contains configuration for the monitor
type Config struct {
        SleepDuration time.Duration // Sleep duration between flow execution cycles
        TeamName      string
}

// Monitor handles flow-based agent monitoring
type Monitor struct {
        flowExecutor *flow.FlowExecutor // Dynamic flow executor
        flowSteps    []config.FlowStep  // Flow configuration
        config       Config
        worker       *config.Worker       // Worker configuration
        settings     config.AgentSettings // Effective settings
        taskService  *task.Service        // Service for task persistence operations
        httpServer   agent.HTTPServer     // HTTP API server for monitoring
}

// New creates a new flow-based monitor instance
func New(worker *config.Worker, settings config.AgentSettings, monitorConfig Config) *Monitor <span class="cov0" title="0">{
        // Get agent directory for task service
        agentDirectory := worker.GetWorkerDir()

        // Create flow executor with worker configuration and effective settings
        flowExecutor := flow.New(settings.Flow, settings.MCPServers, agentDirectory, worker)

        return &amp;Monitor{
                flowExecutor: flowExecutor,
                flowSteps:    settings.Flow,
                config:       monitorConfig,
                worker:       worker,
                settings:     settings,
                taskService:  task.NewService(agentDirectory),
        }
}</span>

// Start starts the flow-based agent processing loop
func (m *Monitor) Start(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        lgr.Info("Starting flow-based agent monitor",
                zap.Duration("sleep_duration", m.config.SleepDuration),
                zap.Int("flow_steps", len(m.flowSteps)))

        lgr.Info("Starting flow processing loop: dynamic dependency-based execution")

        // Start HTTP API server if supported
        if err := m.startHTTPServer(ctx); err != nil </span><span class="cov0" title="0">{
                lgr.Warn("Failed to start HTTP API server", zap.Error(err))
        }</span>

        // Start continuous flow processing loop with sleep-based intervals
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                // Check for cancellation before starting cycle
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        lgr.Info("Monitor shutting down due to context cancellation")

                        // Stop HTTP server
                        if err := m.stopHTTPServer(ctx); err != nil </span><span class="cov0" title="0">{
                                lgr.Warn("Failed to stop HTTP server", zap.Error(err))
                        }</span>

                        <span class="cov0" title="0">return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                // Execute flow processing cycle
                <span class="cov0" title="0">cycleStart := time.Now()
                if err := m.processFlowCycle(ctx); err != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Failed to process flow cycle", zap.Error(err))
                }</span>
                <span class="cov0" title="0">cycleEnd := time.Now()
                executionDuration := cycleEnd.Sub(cycleStart)

                // Log execution timing for monitoring
                lgr.Debug("Flow cycle completed",
                        zap.Duration("execution_time", executionDuration),
                        zap.Duration("sleep_duration", m.config.SleepDuration))

                // Sleep for the configured duration, with context cancellation check
                lgr.Debug("Sleeping before next flow cycle", zap.Duration("sleep_duration", m.config.SleepDuration))

                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        lgr.Info("Monitor shutting down during sleep interval")

                        // Stop HTTP server
                        if err := m.stopHTTPServer(ctx); err != nil </span><span class="cov0" title="0">{
                                lgr.Warn("Failed to stop HTTP server", zap.Error(err))
                        }</span>

                        <span class="cov0" title="0">return ctx.Err()</span>
                case &lt;-time.After(m.config.SleepDuration):<span class="cov0" title="0"></span>
                        // Continue to next cycle after sleep
                }
        }
}

// processFlowCycle executes one cycle of the flow-based architecture
func (m *Monitor) processFlowCycle(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)
        lgr.Debug("Starting flow processing cycle")

        // Execute the flow
        result, err := m.flowExecutor.Execute(ctx)
        if err != nil </span><span class="cov0" title="0">{
                lgr.Error("Flow execution failed", zap.Error(err))
                return fmt.Errorf("flow execution failed: %w", err)
        }</span>

        <span class="cov0" title="0">if !result.Success </span><span class="cov0" title="0">{
                lgr.Warn("Flow execution completed with errors",
                        zap.Int("steps_executed", len(result.Steps)),
                        zap.Error(result.Error))
                return result.Error
        }</span>

        <span class="cov0" title="0">lgr.Info("Flow execution completed successfully",
                zap.Int("steps_executed", len(result.Steps)))

        // Log step outputs for debugging
        for _, stepOutput := range result.Steps </span><span class="cov0" title="0">{
                lgr.Debug("Flow step output",
                        zap.String("step_name", stepOutput.Name),
                        zap.Int("stdout_length", len(stepOutput.Stdout)),
                        zap.Int("stderr_length", len(stepOutput.Stderr)))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// startHTTPServer starts the HTTP API server for agent monitoring
func (m *Monitor) startHTTPServer(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)
        lgr.Debug("HTTP API server not implemented for flow mode")
        return nil
}</span>

// stopHTTPServer stops the HTTP API server
func (m *Monitor) stopHTTPServer(ctx context.Context) error <span class="cov0" title="0">{
        if m.httpServer != nil &amp;&amp; m.httpServer.IsRunning() </span><span class="cov0" title="0">{
                lgr := logger.FromContext(ctx)
                lgr.Info("Stopping HTTP API server")
                return m.httpServer.Stop(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package ports

import (
        "fmt"
        "net"
        "sort"
)

// PortManager handles dynamic port allocation
type PortManager struct {
        // Starting port range (default 8080-8999)
        StartPort int
        EndPort   int
        // Track allocated ports to avoid conflicts
        allocatedPorts map[int]bool
}

// NewPortManager creates a new port manager with default range (using less popular ports)
func NewPortManager() *PortManager <span class="cov8" title="1">{
        return &amp;PortManager{
                StartPort:      45000,
                EndPort:        45999,
                allocatedPorts: make(map[int]bool),
        }
}</span>

// NewPortManagerWithRange creates a port manager with custom range
func NewPortManagerWithRange(startPort, endPort int) *PortManager <span class="cov8" title="1">{
        return &amp;PortManager{
                StartPort:      startPort,
                EndPort:        endPort,
                allocatedPorts: make(map[int]bool),
        }
}</span>

// IsPortAvailable checks if a port is available on localhost
func (pm *PortManager) IsPortAvailable(port int) bool <span class="cov8" title="1">{
        // Check if already allocated
        if pm.allocatedPorts[port] </span><span class="cov8" title="1">{
                return false
        }</span>

        // Try to listen on the port
        <span class="cov8" title="1">listener, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">defer listener.Close()
        return true</span>
}

// FindFreePort finds the next available port in the range
func (pm *PortManager) FindFreePort() (int, error) <span class="cov8" title="1">{
        for port := pm.StartPort; port &lt;= pm.EndPort; port++ </span><span class="cov8" title="1">{
                if pm.IsPortAvailable(port) </span><span class="cov8" title="1">{
                        pm.allocatedPorts[port] = true
                        return port, nil
                }</span>
        }
        <span class="cov0" title="0">return 0, fmt.Errorf("no free ports available in range %d-%d", pm.StartPort, pm.EndPort)</span>
}

// FindFreePorts finds multiple free ports
func (pm *PortManager) FindFreePorts(count int) ([]int, error) <span class="cov8" title="1">{
        var ports []int

        for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                port, err := pm.FindFreePort()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to find %d free ports, only found %d: %w", count, len(ports), err)
                }</span>
                <span class="cov8" title="1">ports = append(ports, port)</span>
        }

        <span class="cov8" title="1">return ports, nil</span>
}

// ReservePort reserves a specific port if available
func (pm *PortManager) ReservePort(port int) error <span class="cov8" title="1">{
        if !pm.IsPortAvailable(port) </span><span class="cov0" title="0">{
                return fmt.Errorf("port %d is not available", port)
        }</span>
        <span class="cov8" title="1">pm.allocatedPorts[port] = true
        return nil</span>
}

// ReleasePort releases a previously allocated port
func (pm *PortManager) ReleasePort(port int) <span class="cov8" title="1">{
        delete(pm.allocatedPorts, port)
}</span>

// GetAllocatedPorts returns a sorted list of allocated ports
func (pm *PortManager) GetAllocatedPorts() []int <span class="cov8" title="1">{
        var ports []int
        for port := range pm.allocatedPorts </span><span class="cov8" title="1">{
                ports = append(ports, port)
        }</span>
        <span class="cov8" title="1">sort.Ints(ports)
        return ports</span>
}

// Reset clears all allocated ports
func (pm *PortManager) Reset() <span class="cov0" title="0">{
        pm.allocatedPorts = make(map[int]bool)
}</span>

// PortAllocation represents a mapping of service names to ports
type PortAllocation map[string]int

// AllocatePortsForServices allocates ports for a list of service names
func (pm *PortManager) AllocatePortsForServices(serviceNames []string) (PortAllocation, error) <span class="cov8" title="1">{
        allocation := make(PortAllocation)

        for _, serviceName := range serviceNames </span><span class="cov8" title="1">{
                port, err := pm.FindFreePort()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to allocate port for service '%s': %w", serviceName, err)
                }</span>
                <span class="cov8" title="1">allocation[serviceName] = port</span>
        }

        <span class="cov8" title="1">return allocation, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package server

import (
        "bufio"
        "fmt"
        "io/fs"
        "net/http"
        "os"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
        "time"

        "autoteam/internal/task"

        "github.com/labstack/echo/v4"
)

// Handlers contains the HTTP handlers for the agent API
type Handlers struct {
        agent       AgentInterface
        workingDir  string
        startTime   time.Time
        taskService *task.Service
}

// NewHandlers creates a new handlers instance
func NewHandlers(ag AgentInterface, workingDir string, startTime time.Time) *Handlers <span class="cov0" title="0">{
        return &amp;Handlers{
                agent:       ag,
                workingDir:  workingDir,
                startTime:   startTime,
                taskService: task.NewService(workingDir),
        }
}</span>

// GetHealth handles GET /health
func (h *Handlers) GetHealth(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        // Get agent info
        agentInfo := AgentInfo{
                Name:    h.agent.Name(),
                Type:    h.agent.Type(),
                Version: "unknown",
        }

        // Get agent version
        if version, err := h.agent.Version(ctx); err == nil </span><span class="cov0" title="0">{
                agentInfo.Version = version
        }</span>

        // Check agent availability
        <span class="cov0" title="0">available := h.agent.IsAvailable(ctx)
        agentInfo.Available = &amp;available

        // Perform health checks
        checks := make(map[string]HealthCheck)

        // Agent availability check
        if available </span><span class="cov0" title="0">{
                checks["agent_available"] = HealthCheck{
                        Status:  HealthCheckPass,
                        Message: "Agent is available and ready",
                }
        }</span> else<span class="cov0" title="0"> {
                checks["agent_available"] = HealthCheck{
                        Status:  HealthCheckFail,
                        Message: "Agent is not available",
                }
        }</span>

        // Working directory check
        <span class="cov0" title="0">if _, err := os.Stat(h.workingDir); err == nil </span><span class="cov0" title="0">{
                checks["working_directory"] = HealthCheck{
                        Status:  HealthCheckPass,
                        Message: "Working directory accessible",
                }
        }</span> else<span class="cov0" title="0"> {
                checks["working_directory"] = HealthCheck{
                        Status:  HealthCheckFail,
                        Message: fmt.Sprintf("Working directory not accessible: %v", err),
                }
        }</span>

        // Determine overall health status
        <span class="cov0" title="0">status := HealthStatusHealthy
        for _, check := range checks </span><span class="cov0" title="0">{
                if check.Status == HealthCheckFail </span><span class="cov0" title="0">{
                        status = HealthStatusUnhealthy
                        break</span>
                }
        }

        <span class="cov0" title="0">response := HealthResponse{
                Status:    status,
                Timestamp: time.Now(),
                Agent:     agentInfo,
                Checks:    checks,
        }

        return c.JSON(http.StatusOK, response)</span>
}

// GetStatus handles GET /status
func (h *Handlers) GetStatus(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        // Get agent info
        agentInfo := AgentInfo{
                Name:    h.agent.Name(),
                Type:    h.agent.Type(),
                Version: "unknown",
        }

        // Get agent version
        if version, err := h.agent.Version(ctx); err == nil </span><span class="cov0" title="0">{
                agentInfo.Version = version
        }</span>

        // Check availability
        <span class="cov0" title="0">available := h.agent.IsAvailable(ctx)
        agentInfo.Available = &amp;available

        // Calculate uptime
        uptime := time.Since(h.startTime).String()

        // For now, status is always idle - in real implementation this would track actual agent state
        response := StatusResponse{
                Status:    AgentStatusIdle,
                Mode:      AgentModeBoth,
                Timestamp: time.Now(),
                Agent:     agentInfo,
                Uptime:    uptime,
        }

        return c.JSON(http.StatusOK, response)</span>
}

// GetLogs handles GET /logs
func (h *Handlers) GetLogs(c echo.Context) error <span class="cov0" title="0">{
        role := c.QueryParam("role")
        limitStr := c.QueryParam("limit")

        limit := 50 // default
        if limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 &amp;&amp; l &lt;= 100 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">logs, err := h.getLogFiles(role, limit)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">response := LogsResponse{
                Logs:      logs,
                Total:     len(logs),
                Timestamp: time.Now(),
        }

        return c.JSON(http.StatusOK, response)</span>
}

// GetCollectorLogs handles GET /logs/collector
func (h *Handlers) GetCollectorLogs(c echo.Context) error <span class="cov0" title="0">{
        limitStr := c.QueryParam("limit")

        limit := 50 // default
        if limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 &amp;&amp; l &lt;= 100 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">logs, err := h.getLogFiles(LogRoleCollector, limit)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">response := LogsResponse{
                Logs:      logs,
                Total:     len(logs),
                Timestamp: time.Now(),
        }

        return c.JSON(http.StatusOK, response)</span>
}

// GetExecutorLogs handles GET /logs/executor
func (h *Handlers) GetExecutorLogs(c echo.Context) error <span class="cov0" title="0">{
        limitStr := c.QueryParam("limit")

        limit := 50 // default
        if limitStr != "" </span><span class="cov0" title="0">{
                if l, err := strconv.Atoi(limitStr); err == nil &amp;&amp; l &gt; 0 &amp;&amp; l &lt;= 100 </span><span class="cov0" title="0">{
                        limit = l
                }</span>
        }

        <span class="cov0" title="0">logs, err := h.getLogFiles(LogRoleExecutor, limit)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
        }</span>

        <span class="cov0" title="0">response := LogsResponse{
                Logs:      logs,
                Total:     len(logs),
                Timestamp: time.Now(),
        }

        return c.JSON(http.StatusOK, response)</span>
}

// GetLogFile handles GET /logs/{filename}
func (h *Handlers) GetLogFile(c echo.Context) error <span class="cov0" title="0">{
        filename := c.Param("filename")
        tailStr := c.QueryParam("tail")

        if filename == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "filename is required")
        }</span>

        // Security check: prevent path traversal
        <span class="cov0" title="0">if strings.Contains(filename, "..") || strings.Contains(filename, "/") </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "invalid filename")
        }</span>

        <span class="cov0" title="0">logPath := filepath.Join(h.workingDir, "logs", filename)

        // Check if file exists
        if _, err := os.Stat(logPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "log file not found")
        }</span>

        // Handle tail parameter
        <span class="cov0" title="0">if tailStr != "" </span><span class="cov0" title="0">{
                tailLines, err := strconv.Atoi(tailStr)
                if err != nil || tailLines &lt;= 0 || tailLines &gt; 10000 </span><span class="cov0" title="0">{
                        return echo.NewHTTPError(http.StatusBadRequest, "invalid tail parameter")
                }</span>

                <span class="cov0" title="0">content, err := h.tailFile(logPath, tailLines)
                if err != nil </span><span class="cov0" title="0">{
                        return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
                }</span>

                <span class="cov0" title="0">c.Response().Header().Set("Content-Type", "text/plain; charset=utf-8")
                return c.String(http.StatusOK, content)</span>
        }

        // Serve entire file
        <span class="cov0" title="0">return c.File(logPath)</span>
}

// GetTasks handles GET /tasks
func (h *Handlers) GetTasks(c echo.Context) error <span class="cov0" title="0">{
        // For now, return empty tasks list - in real implementation this would query actual tasks
        response := TasksResponse{
                Tasks:     []TaskSummary{},
                Total:     0,
                Timestamp: time.Now(),
        }

        return c.JSON(http.StatusOK, response)
}</span>

// GetTask handles GET /tasks/{id}
func (h *Handlers) GetTask(c echo.Context) error <span class="cov0" title="0">{
        id := c.Param("id")

        if id == "" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "task id is required")
        }</span>

        // For now, return not found - in real implementation this would query actual task
        <span class="cov0" title="0">return echo.NewHTTPError(http.StatusNotFound, "task not found")</span>
}

// GetMetrics handles GET /metrics
func (h *Handlers) GetMetrics(c echo.Context) error <span class="cov0" title="0">{
        uptime := time.Since(h.startTime).String()

        metrics := AgentMetrics{
                Uptime: &amp;uptime,
                // In real implementation, these would be tracked
                TasksProcessed:   intPtr(0),
                TasksSuccess:     intPtr(0),
                TasksFailed:      intPtr(0),
                AvgExecutionTime: stringPtr("0s"),
                LastActivity:     timePtr(h.startTime),
        }

        response := MetricsResponse{
                Metrics:   metrics,
                Timestamp: time.Now(),
        }

        return c.JSON(http.StatusOK, response)
}</span>

// GetConfig handles GET /config
func (h *Handlers) GetConfig(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        // Get agent version
        version := "unknown"
        if v, err := h.agent.Version(ctx); err == nil </span><span class="cov0" title="0">{
                version = v
        }</span>

        <span class="cov0" title="0">config := AgentConfig{
                Name:    stringPtr(h.agent.Name()),
                Type:    stringPtr(h.agent.Type()),
                Enabled: boolPtr(true),
                Version: stringPtr(version),
        }

        response := ConfigResponse{
                Config:    config,
                Timestamp: time.Now(),
        }

        return c.JSON(http.StatusOK, response)</span>
}

// getLogFiles retrieves log files based on role filter and limit
func (h *Handlers) getLogFiles(role string, limit int) ([]LogFile, error) <span class="cov0" title="0">{
        logsDir := filepath.Join(h.workingDir, "logs")

        // Check if logs directory exists
        if _, err := os.Stat(logsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return []LogFile{}, nil
        }</span>

        <span class="cov0" title="0">var logFiles []LogFile

        err := filepath.WalkDir(logsDir, func(path string, d fs.DirEntry, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip directories
                <span class="cov0" title="0">if d.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Only include .log files
                <span class="cov0" title="0">if !strings.HasSuffix(d.Name(), ".log") </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">info, err := d.Info()
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Skip files we can't stat
                }</span>

                // Determine role based on filename or directory
                <span class="cov0" title="0">fileRole := h.determineLogRole(d.Name(), path)

                // Apply role filter
                if role != "" &amp;&amp; role != fileRole </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">logFile := LogFile{
                        Filename: d.Name(),
                        Size:     info.Size(),
                        Modified: info.ModTime(),
                }

                if fileRole != "" </span><span class="cov0" title="0">{
                        logFile.Role = &amp;fileRole
                }</span>

                <span class="cov0" title="0">logFiles = append(logFiles, logFile)

                return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Sort by modification time (newest first)
        <span class="cov0" title="0">sort.Slice(logFiles, func(i, j int) bool </span><span class="cov0" title="0">{
                return logFiles[i].Modified.After(logFiles[j].Modified)
        }</span>)

        // Apply limit
        <span class="cov0" title="0">if limit &gt; 0 &amp;&amp; len(logFiles) &gt; limit </span><span class="cov0" title="0">{
                logFiles = logFiles[:limit]
        }</span>

        <span class="cov0" title="0">return logFiles, nil</span>
}

// determineLogRole determines the role based on log filename or path
func (h *Handlers) determineLogRole(filename, path string) string <span class="cov0" title="0">{
        // Check if path contains collector or executor subdirectory
        if strings.Contains(path, "/collector/") </span><span class="cov0" title="0">{
                return LogRoleCollector
        }</span>
        <span class="cov0" title="0">if strings.Contains(path, "/executor/") </span><span class="cov0" title="0">{
                return LogRoleExecutor
        }</span>

        // Check filename patterns (fallback)
        <span class="cov0" title="0">lower := strings.ToLower(filename)
        if strings.Contains(lower, "collector") </span><span class="cov0" title="0">{
                return LogRoleCollector
        }</span>
        <span class="cov0" title="0">if strings.Contains(lower, "executor") </span><span class="cov0" title="0">{
                return LogRoleExecutor
        }</span>

        <span class="cov0" title="0">return LogRoleBoth</span>
}

// tailFile reads the last n lines from a file
func (h *Handlers) tailFile(filepath string, lines int) (string, error) <span class="cov0" title="0">{
        file, err := os.Open(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var result []string
        scanner := bufio.NewScanner(file)

        // Read all lines
        var allLines []string
        for scanner.Scan() </span><span class="cov0" title="0">{
                allLines = append(allLines, scanner.Text())
        }</span>

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Get last n lines
        <span class="cov0" title="0">start := len(allLines) - lines
        if start &lt; 0 </span><span class="cov0" title="0">{
                start = 0
        }</span>

        <span class="cov0" title="0">result = allLines[start:]
        return strings.Join(result, "\n"), nil</span>
}

// Utility functions for pointer creation
func stringPtr(s string) *string     <span class="cov0" title="0">{ return &amp;s }</span>
func intPtr(i int) *int              <span class="cov0" title="0">{ return &amp;i }</span>
func boolPtr(b bool) *bool           <span class="cov0" title="0">{ return &amp;b }</span>
func timePtr(t time.Time) *time.Time <span class="cov0" title="0">{ return &amp;t }</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package server

import (
        "context"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "autoteam/internal/logger"

        "github.com/labstack/echo/v4"
        "github.com/labstack/echo/v4/middleware"
        "go.uber.org/zap"
)

// AgentInterface defines the minimal interface needed by the HTTP server
type AgentInterface interface {
        Name() string
        Type() string
        IsAvailable(ctx context.Context) bool
        Version(ctx context.Context) (string, error)
}

// Server represents the HTTP API server for an agent
type Server struct {
        echo       *echo.Echo
        agent      AgentInterface
        port       int
        apiKey     string
        workingDir string
        startTime  time.Time
        server     *http.Server
        handlers   *Handlers
}

// Config contains server configuration
type Config struct {
        Port       int
        APIKey     string
        WorkingDir string
}

// NewServer creates a new HTTP API server for the given agent
func NewServer(ag AgentInterface, config Config) *Server <span class="cov0" title="0">{
        e := echo.New()
        e.HideBanner = true

        server := &amp;Server{
                echo:       e,
                agent:      ag,
                port:       config.Port,
                apiKey:     config.APIKey,
                workingDir: config.WorkingDir,
                startTime:  time.Now(),
        }

        // Create handlers
        server.handlers = NewHandlers(ag, server.workingDir, server.startTime)

        // Setup middleware
        server.setupMiddleware()

        // Setup routes
        server.setupRoutes()

        return server
}</span>

// setupMiddleware configures Echo middleware
func (s *Server) setupMiddleware() <span class="cov0" title="0">{
        // CORS middleware
        s.echo.Use(middleware.CORSWithConfig(middleware.CORSConfig{
                AllowOrigins: []string{"*"},
                AllowMethods: []string{http.MethodGet, http.MethodOptions},
                AllowHeaders: []string{"*"},
        }))

        // Rate limiting middleware (100 requests per minute per IP)
        s.echo.Use(middleware.RateLimiter(middleware.NewRateLimiterMemoryStore(100)))

        // Logger middleware
        s.echo.Use(middleware.LoggerWithConfig(middleware.LoggerConfig{
                Format: `{"time":"${time_rfc3339}","method":"${method}","uri":"${uri}","status":${status},"latency":"${latency_human}","error":"${error}"}` + "\n",
        }))

        // Recovery middleware
        s.echo.Use(middleware.Recover())

        // API Key authentication middleware (optional)
        if s.apiKey != "" </span><span class="cov0" title="0">{
                s.echo.Use(s.apiKeyMiddleware)
        }</span>
}

// apiKeyMiddleware validates API key if configured
func (s *Server) apiKeyMiddleware(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                apiKey := c.Request().Header.Get("X-API-Key")
                if apiKey == "" || apiKey != s.apiKey </span><span class="cov0" title="0">{
                        return echo.NewHTTPError(http.StatusUnauthorized, "Invalid or missing API key")
                }</span>
                <span class="cov0" title="0">return next(c)</span>
        }
}

// setupRoutes configures API routes
func (s *Server) setupRoutes() <span class="cov0" title="0">{
        api := s.echo.Group("/")

        // Health endpoints
        api.GET("health", s.handlers.GetHealth)
        api.GET("status", s.handlers.GetStatus)

        // Log endpoints
        api.GET("logs", s.handlers.GetLogs)
        api.GET("logs/collector", s.handlers.GetCollectorLogs)
        api.GET("logs/executor", s.handlers.GetExecutorLogs)
        api.GET("logs/:filename", s.handlers.GetLogFile)

        // Task endpoints
        api.GET("tasks", s.handlers.GetTasks)
        api.GET("tasks/:id", s.handlers.GetTask)

        // Metrics endpoint
        api.GET("metrics", s.handlers.GetMetrics)

        // Configuration endpoint
        api.GET("config", s.handlers.GetConfig)

        // Documentation redirect
        api.GET("docs", func(c echo.Context) error </span><span class="cov0" title="0">{
                return c.Redirect(http.StatusMovedPermanently, "/docs/")
        }</span>)

        // Static docs serving (for Swagger UI if needed)
        // Note: In production, you might want to embed static files or serve from CDN
        <span class="cov0" title="0">api.Static("docs/", "docs/")</span>
}

// Start starts the HTTP server
func (s *Server) Start(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        s.server = &amp;http.Server{
                Addr:         ":" + strconv.Itoa(s.port),
                Handler:      s.echo,
                ReadTimeout:  30 * time.Second,
                WriteTimeout: 30 * time.Second,
                IdleTimeout:  120 * time.Second,
        }

        lgr.Info("Starting HTTP API server",
                zap.String("agent", s.agent.Name()),
                zap.String("type", s.agent.Type()),
                zap.Int("port", s.port),
                zap.String("address", s.server.Addr))

        // Start server in goroutine
        go func() </span><span class="cov0" title="0">{
                if err := s.server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        lgr.Error("HTTP server error", zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">return nil</span>
}

// Stop gracefully stops the HTTP server
func (s *Server) Stop(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        if s.server == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">lgr.Info("Stopping HTTP API server",
                zap.String("agent", s.agent.Name()),
                zap.Int("port", s.port))

        // Create context with timeout for shutdown
        shutdownCtx, cancel := context.WithTimeout(ctx, 10*time.Second)
        defer cancel()

        if err := s.server.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                lgr.Error("Error during server shutdown", zap.Error(err))
                return err
        }</span>

        <span class="cov0" title="0">lgr.Info("HTTP API server stopped successfully")
        return nil</span>
}

// Port returns the server port
func (s *Server) Port() int <span class="cov0" title="0">{
        return s.port
}</span>

// IsRunning returns true if the server is running
func (s *Server) IsRunning() bool <span class="cov0" title="0">{
        return s.server != nil
}</span>

// GetURL returns the base URL for the server
func (s *Server) GetURL() string <span class="cov0" title="0">{
        return fmt.Sprintf("http://localhost:%d", s.port)
}</span>

// GetDocsURL returns the documentation URL
func (s *Server) GetDocsURL() string <span class="cov0" title="0">{
        return fmt.Sprintf("http://localhost:%d/docs/", s.port)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package task

import (
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "autoteam/internal/logger"

        "go.uber.org/zap"
)

// StreamingLogger handles streaming logs to separate files per task
type StreamingLogger struct {
        logDir string
}

// NewStreamingLogger creates a new streaming logger for the given directory
func NewStreamingLogger(workingDir string) *StreamingLogger <span class="cov0" title="0">{
        logDir := filepath.Join(workingDir, "logs")
        return &amp;StreamingLogger{
                logDir: logDir,
        }
}</span>

// NormalizeTaskText normalizes a task description for use as a filename
// Format: "{Notification ID} - {NOTIFICATION URL} - {NOTIFICATION TEXT}"
func NormalizeTaskText(taskDescription string) string <span class="cov0" title="0">{
        // Extract the notification text part (everything after the second " - ")
        parts := strings.Split(taskDescription, " - ")
        var notificationText string
        if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                notificationText = strings.Join(parts[2:], " - ")
        }</span> else<span class="cov0" title="0"> {
                notificationText = taskDescription
        }</span>

        // Replace invalid filename characters with underscores
        <span class="cov0" title="0">reg := regexp.MustCompile(`[^\w\-_\s\.]+`)
        normalized := reg.ReplaceAllString(notificationText, "_")

        // Replace spaces with underscores and collapse multiple underscores
        normalized = strings.ReplaceAll(normalized, " ", "_")
        normalized = regexp.MustCompile(`_+`).ReplaceAllString(normalized, "_")

        // Convert to lowercase
        normalized = strings.ToLower(normalized)

        // Trim underscores from start and end
        normalized = strings.Trim(normalized, "_")

        // Limit length to 100 characters to avoid filesystem issues
        if len(normalized) &gt; 100 </span><span class="cov0" title="0">{
                normalized = normalized[:100]
                // Trim trailing underscore if truncated
                normalized = strings.TrimRight(normalized, "_")
        }</span>

        // Ensure it's not empty
        <span class="cov0" title="0">if normalized == "" </span><span class="cov0" title="0">{
                normalized = "unknown_task"
        }</span>

        <span class="cov0" title="0">return normalized</span>
}

// CreateLogFile creates a log file for the given task and returns a file writer
func (sl *StreamingLogger) CreateLogFile(ctx context.Context, taskDescription string) (*os.File, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Ensure logs directory exists
        if err := os.MkdirAll(sl.logDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create logs directory: %w", err)
        }</span>

        // Normalize task text for filename and add timestamp
        <span class="cov0" title="0">normalizedName := NormalizeTaskText(taskDescription)
        timestamp := time.Now().Format("20060102-150405") // YYYYMMDD-HHMMSS format
        logFileName := fmt.Sprintf("%s-%s.log", timestamp, normalizedName)
        logFilePath := filepath.Join(sl.logDir, logFileName)

        lgr.Info("Creating log file for task",
                zap.String("task_description", taskDescription),
                zap.String("normalized_name", normalizedName),
                zap.String("timestamp", timestamp),
                zap.String("log_file", logFilePath))

        // Create/open the log file for appending
        file, err := os.OpenFile(logFilePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create log file: %w", err)
        }</span>

        // Write header with timestamp
        <span class="cov0" title="0">header := fmt.Sprintf("=== Task Execution Log - %s ===\nTask: %s\n\n",
                getCurrentTimestamp(), taskDescription)
        if _, err := file.WriteString(header); err != nil </span><span class="cov0" title="0">{
                file.Close()
                return nil, fmt.Errorf("failed to write log header: %w", err)
        }</span>

        <span class="cov0" title="0">return file, nil</span>
}

// getCurrentTimestamp returns current timestamp in a readable format
func getCurrentTimestamp() string <span class="cov0" title="0">{
        return time.Now().Format("2006-01-02 15:04:05")
}</span>

// StreamingWriter wraps an io.Writer to provide streaming functionality
type StreamingWriter struct {
        file   *os.File
        writer io.Writer
}

// NewStreamingWriter creates a new streaming writer that writes to both file and original writer
func NewStreamingWriter(file *os.File, originalWriter io.Writer) *StreamingWriter <span class="cov0" title="0">{
        return &amp;StreamingWriter{
                file:   file,
                writer: io.MultiWriter(file, originalWriter),
        }
}</span>

// Write implements io.Writer interface
func (sw *StreamingWriter) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        return sw.writer.Write(p)
}</span>

// Close closes the underlying file
func (sw *StreamingWriter) Close() error <span class="cov0" title="0">{
        if sw.file != nil </span><span class="cov0" title="0">{
                return sw.file.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package task

import (
        "encoding/json"
        "fmt"
        "regexp"
        "strings"
)

// TaskResponse represents the expected JSON response from the first layer agent
type TaskResponse struct {
        Tasks []Task `json:"tasks"`
}

// ParseTasksFromOutput parses task list from simple text output (one task per line)
func ParseTasksFromOutput(output string) (*TaskList, error) <span class="cov0" title="0">{
        taskList := NewTaskList()

        // Split output into lines
        lines := strings.Split(strings.TrimSpace(output), "\n")

        for i, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)

                // Skip empty lines
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Remove bullet points or dashes at the beginning
                <span class="cov0" title="0">line = strings.TrimPrefix(line, "- ")
                line = strings.TrimPrefix(line, "* ")
                line = strings.TrimPrefix(line, " ")
                line = strings.TrimSpace(line)

                // Skip if still empty
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Create a simple task with the line as description
                <span class="cov0" title="0">task := NewTask(
                        fmt.Sprintf("task-%d", i+1), // Simple ID
                        TaskTypeGeneric,             // Generic type
                        line,                        // Use the line as title
                        line,                        // Also use as description
                        PlatformGeneric,             // Generic platform
                        "",                          // No completion command needed
                        PriorityMedium,              // Default to medium priority
                )

                taskList.AddTask(*task)</span>
        }

        <span class="cov0" title="0">return taskList, nil</span>
}

// CreateEmptyTaskList creates an empty task list for when parsing fails
func CreateEmptyTaskList() *TaskList <span class="cov0" title="0">{
        return NewTaskList()
}</span>

// extractTodoListFromOutput extracts tasks from TODO_LIST format using improved parsing
func extractTodoListFromOutput(output string) ([]string, error) <span class="cov0" title="0">{
        // Look for the TODO_LIST marker first
        todoStart := strings.Index(strings.ToUpper(output), "TODO_LIST:")
        if todoStart == -1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TODO_LIST format not found")
        }</span>

        // Find the start of the JSON array after TODO_LIST:
        <span class="cov0" title="0">jsonStart := strings.Index(output[todoStart:], "[")
        if jsonStart == -1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TODO_LIST JSON array not found")
        }</span>
        <span class="cov0" title="0">jsonStart += todoStart

        // Use proper JSON parsing to find the end of the array
        // Track bracket nesting and string escaping
        depth := 0
        inString := false
        escaped := false
        jsonEnd := -1

        for i := jsonStart; i &lt; len(output); i++ </span><span class="cov0" title="0">{
                char := output[i]

                if escaped </span><span class="cov0" title="0">{
                        escaped = false
                        continue</span>
                }

                <span class="cov0" title="0">if char == '\\' &amp;&amp; inString </span><span class="cov0" title="0">{
                        escaped = true
                        continue</span>
                }

                <span class="cov0" title="0">if char == '"' </span><span class="cov0" title="0">{
                        inString = !inString
                        continue</span>
                }

                <span class="cov0" title="0">if !inString </span><span class="cov0" title="0">{
                        if char == '[' </span><span class="cov0" title="0">{
                                depth++
                        }</span> else<span class="cov0" title="0"> if char == ']' </span><span class="cov0" title="0">{
                                depth--
                                if depth == 0 </span><span class="cov0" title="0">{
                                        jsonEnd = i
                                        break</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">if jsonEnd == -1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TODO_LIST JSON array not properly closed")
        }</span>

        // Extract the JSON array string
        <span class="cov0" title="0">jsonArrayStr := output[jsonStart : jsonEnd+1]

        // Parse the JSON array
        var tasks []string
        if err := json.Unmarshal([]byte(jsonArrayStr), &amp;tasks); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse TODO_LIST JSON array: %w", err)
        }</span>

        // Clean up the tasks (remove empty strings and trim whitespace)
        <span class="cov0" title="0">var cleanTasks []string
        for _, task := range tasks </span><span class="cov0" title="0">{
                cleanTask := strings.TrimSpace(task)
                if cleanTask != "" </span><span class="cov0" title="0">{
                        cleanTasks = append(cleanTasks, cleanTask)
                }</span>
        }

        <span class="cov0" title="0">return cleanTasks, nil</span>
}

// ParseTasksFromStdout parses agent stdout output and returns a TasksJSON structure
// First tries to extract TODO_LIST format, then falls back to line-by-line parsing
func ParseTasksFromStdout(stdout string) (*TasksJSON, error) <span class="cov0" title="0">{
        tasksJSON := NewTasksJSON()

        if stdout == "" </span><span class="cov0" title="0">{
                return tasksJSON, nil
        }</span>

        // First, try to extract TODO_LIST format using regex
        <span class="cov0" title="0">todoList, err := extractTodoListFromOutput(stdout)
        if err == nil </span><span class="cov0" title="0">{
                // Successfully extracted TODO_LIST format (even if empty)
                for _, task := range todoList </span><span class="cov0" title="0">{
                        tasksJSON.AddTodoTask(task)
                }</span>
                <span class="cov0" title="0">return tasksJSON, nil</span>
        }

        // Fallback to line-by-line parsing if TODO_LIST format not found
        <span class="cov0" title="0">lines := strings.Split(strings.TrimSpace(stdout), "\n")

        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)

                // Skip empty lines
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip lines that contain TODO_LIST pattern (they should be handled by regex above)
                <span class="cov0" title="0">if strings.Contains(strings.ToUpper(line), "TODO_LIST:") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Remove common list prefixes (numbers, bullets, dashes)
                <span class="cov0" title="0">line = cleanTaskLine(line)

                // Skip if still empty after cleaning
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Add as a todo task
                <span class="cov0" title="0">tasksJSON.AddTodoTask(line)</span>
        }

        <span class="cov0" title="0">return tasksJSON, nil</span>
}

// cleanTaskLine removes common list prefixes and cleans up the task line
func cleanTaskLine(line string) string <span class="cov0" title="0">{
        line = strings.TrimSpace(line)

        // Remove numbered list prefixes (1. 2. etc.)
        numberRegex := regexp.MustCompile(`^\d+\.\s*`)
        line = numberRegex.ReplaceAllString(line, "")

        // Remove bullet point prefixes
        line = strings.TrimPrefix(line, "- ")
        line = strings.TrimPrefix(line, "* ")
        line = strings.TrimPrefix(line, " ")
        line = strings.TrimPrefix(line, " ")
        line = strings.TrimPrefix(line, "&gt; ")

        // Remove any remaining leading whitespace
        line = strings.TrimSpace(line)

        return line
}</span>

// LoadTasksJSON loads TasksJSON from a JSON file content
func LoadTasksJSON(jsonContent []byte) (*TasksJSON, error) <span class="cov0" title="0">{
        var tasksJSON TasksJSON
        if err := json.Unmarshal(jsonContent, &amp;tasksJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal tasks JSON: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;tasksJSON, nil</span>
}

// ConvertTasksJSONToTaskList converts TasksJSON to legacy TaskList format for compatibility
func ConvertTasksJSONToTaskList(tasksJSON *TasksJSON) *TaskList <span class="cov0" title="0">{
        taskList := NewTaskList()

        // Convert todo items to tasks
        for i, todoItem := range tasksJSON.Todo </span><span class="cov0" title="0">{
                task := NewTask(
                        fmt.Sprintf("todo-%d", i+1),
                        TaskTypeGeneric,
                        todoItem,
                        todoItem,
                        PlatformGeneric,
                        "",
                        PriorityMedium,
                )
                taskList.AddTask(*task)
        }</span>

        <span class="cov0" title="0">return taskList</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package task

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "autoteam/internal/logger"

        "go.uber.org/zap"
)

// Service handles all task persistence and management operations
type Service struct {
        tasksJSONPath string
}

// NewService creates a new task service instance
func NewService(agentDirectory string) *Service <span class="cov0" title="0">{
        return &amp;Service{
                tasksJSONPath: filepath.Join(agentDirectory, "tasks.json"),
        }
}</span>

// LoadTasks loads existing tasks from the tasks.json file with backup recovery
func (s *Service) LoadTasks(ctx context.Context) (*TasksJSON, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Try to load existing tasks.json file
        existingData, err := os.ReadFile(s.tasksJSONPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        lgr.Debug("No existing tasks.json file, returning empty tasks")
                        return NewTasksJSON(), nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to read tasks.json: %w", err)</span>
        }

        // Parse existing tasks
        <span class="cov0" title="0">tasksJSON, err := LoadTasksJSON(existingData)
        if err != nil </span><span class="cov0" title="0">{
                lgr.Warn("Failed to parse existing tasks.json, attempting backup recovery", zap.Error(err))

                // Try to recover from backup
                backupPath := s.tasksJSONPath + ".backup"
                if backupData, backupErr := os.ReadFile(backupPath); backupErr == nil </span><span class="cov0" title="0">{
                        if backupTasksJSON, backupParseErr := LoadTasksJSON(backupData); backupParseErr == nil </span><span class="cov0" title="0">{
                                lgr.Info("Successfully recovered tasks from backup file",
                                        zap.String("backup_path", backupPath),
                                        zap.Int("todo_count", backupTasksJSON.TodoCount()),
                                        zap.Int("done_count", backupTasksJSON.DoneCount()))

                                // Restore the backup as the main file
                                if restoreErr := s.SaveTasks(ctx, backupTasksJSON); restoreErr == nil </span><span class="cov0" title="0">{
                                        lgr.Info("Backup restored as main tasks.json file")
                                        return backupTasksJSON, nil
                                }</span> else<span class="cov0" title="0"> {
                                        lgr.Warn("Failed to restore backup file", zap.Error(restoreErr))
                                }</span>

                                <span class="cov0" title="0">return backupTasksJSON, nil</span>
                        } else<span class="cov0" title="0"> {
                                lgr.Warn("Backup file is also corrupted", zap.Error(backupParseErr))
                        }</span>
                } else<span class="cov0" title="0"> {
                        lgr.Debug("No backup file available for recovery", zap.Error(backupErr))
                }</span>

                // If both main and backup files are corrupted, return empty tasks but don't overwrite
                <span class="cov0" title="0">lgr.Error("Both main and backup tasks.json files are corrupted, returning empty tasks without overwriting existing files")
                return NewTasksJSON(), nil</span>
        }

        <span class="cov0" title="0">lgr.Debug("Tasks loaded successfully",
                zap.String("path", s.tasksJSONPath),
                zap.Int("todo_count", tasksJSON.TodoCount()),
                zap.Int("done_count", tasksJSON.DoneCount()))

        return tasksJSON, nil</span>
}

// SaveTasks saves tasks to the tasks.json file with atomic operations and backup
func (s *Service) SaveTasks(ctx context.Context, tasksJSON *TasksJSON) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Ensure directory exists
        if err := os.MkdirAll(filepath.Dir(s.tasksJSONPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Validate input data
        <span class="cov0" title="0">if tasksJSON == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot save nil TasksJSON")
        }</span>

        // Marshal to JSON with indentation for readability
        <span class="cov0" title="0">data, err := json.MarshalIndent(tasksJSON, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal tasks JSON: %w", err)
        }</span>

        // Validate marshaled data is not empty
        <span class="cov0" title="0">if len(data) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("marshaled data is empty, refusing to overwrite tasks.json")
        }</span>

        // Use atomic write with backup strategy
        <span class="cov0" title="0">backupPath := s.tasksJSONPath + ".backup"
        tempPath := s.tasksJSONPath + ".tmp"

        // Create backup of existing file if it exists
        if _, err := os.Stat(s.tasksJSONPath); err == nil </span><span class="cov0" title="0">{
                if err := s.copyFile(s.tasksJSONPath, backupPath); err != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Failed to create backup, proceeding without backup", zap.Error(err))
                }</span>
        }

        // Write to temporary file first
        <span class="cov0" title="0">if err := os.WriteFile(tempPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write temporary tasks JSON file: %w", err)
        }</span>

        // Atomic rename - this is the critical section
        <span class="cov0" title="0">if err := os.Rename(tempPath, s.tasksJSONPath); err != nil </span><span class="cov0" title="0">{
                // Clean up temporary file
                os.Remove(tempPath)
                return fmt.Errorf("failed to atomically move tasks JSON file: %w", err)
        }</span>

        // Remove backup after successful write
        <span class="cov0" title="0">os.Remove(backupPath)

        lgr.Debug("Tasks saved successfully",
                zap.String("path", s.tasksJSONPath),
                zap.Int("todo_count", tasksJSON.TodoCount()),
                zap.Int("done_count", tasksJSON.DoneCount()))

        return nil</span>
}

// copyFile copies a file from src to dst
func (s *Service) copyFile(src, dst string) error <span class="cov0" title="0">{
        sourceData, err := os.ReadFile(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(dst, sourceData, 0644)</span>
}

// MergeNewTasks loads existing tasks and merges them with new tasks
// This preserves todo and done state across collection cycles
func (s *Service) MergeNewTasks(ctx context.Context, newTasks *TasksJSON) (*TasksJSON, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Load existing tasks
        existingTasks, err := s.LoadTasks(ctx)
        if err != nil </span><span class="cov0" title="0">{
                lgr.Warn("Failed to load existing tasks, using new tasks only", zap.Error(err))
                return newTasks, nil
        }</span>

        <span class="cov0" title="0">lgr.Debug("Merging tasks",
                zap.Int("existing_todo", existingTasks.TodoCount()),
                zap.Int("existing_done", existingTasks.DoneCount()),
                zap.Int("new_todo", newTasks.TodoCount()))

        // Create merged tasks starting with existing tasks
        mergedTasks := NewTasksJSON()

        // Preserve existing todo items
        for _, existingTodo := range existingTasks.Todo </span><span class="cov0" title="0">{
                mergedTasks.AddTodoTask(existingTodo)
        }</span>

        // Preserve existing done items
        <span class="cov0" title="0">for _, existingDone := range existingTasks.Done </span><span class="cov0" title="0">{
                mergedTasks.AddDoneTask(existingDone)
        }</span>

        // Add new todo items (avoid duplicates)
        <span class="cov0" title="0">for _, newTodo := range newTasks.Todo </span><span class="cov0" title="0">{
                if !mergedTasks.ContainsTodoTask(newTodo) </span><span class="cov0" title="0">{
                        mergedTasks.AddTodoTask(newTodo)
                }</span>
        }

        <span class="cov0" title="0">lgr.Info("Tasks merged successfully",
                zap.Int("final_todo_count", mergedTasks.TodoCount()),
                zap.Int("final_done_count", mergedTasks.DoneCount()),
                zap.Int("new_tasks_added", newTasks.TodoCount()))

        return mergedTasks, nil</span>
}

// AddNewTasksAndSave merges new tasks with existing ones and saves the result
func (s *Service) AddNewTasksAndSave(ctx context.Context, newTasks *TasksJSON) (*TasksJSON, error) <span class="cov0" title="0">{
        // Merge with existing tasks
        mergedTasks, err := s.MergeNewTasks(ctx, newTasks)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to merge tasks: %w", err)
        }</span>

        // Save the merged result
        <span class="cov0" title="0">if err := s.SaveTasks(ctx, mergedTasks); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save merged tasks: %w", err)
        }</span>

        <span class="cov0" title="0">return mergedTasks, nil</span>
}

// MarkTaskCompleted moves a task from todo to done
func (s *Service) MarkTaskCompleted(ctx context.Context, taskDescription string) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Load existing tasks
        tasksJSON, err := s.LoadTasks(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load tasks: %w", err)
        }</span>

        // Check if task exists in todo list
        <span class="cov0" title="0">if !tasksJSON.ContainsTodoTask(taskDescription) </span><span class="cov0" title="0">{
                lgr.Debug("Task not found in todo list, may have been already completed",
                        zap.String("task_description", taskDescription))
                return nil
        }</span>

        // Move task from todo to done
        <span class="cov0" title="0">tasksJSON.MoveToDone(taskDescription)

        // Save updated tasks
        if err := s.SaveTasks(ctx, tasksJSON); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save updated tasks: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Info("Task marked as completed",
                zap.String("task_description", taskDescription),
                zap.Int("remaining_todo_count", tasksJSON.TodoCount()),
                zap.Int("done_count", tasksJSON.DoneCount()))

        return nil</span>
}

// CreateEmpty creates an empty tasks.json file
func (s *Service) CreateEmpty(ctx context.Context) error <span class="cov0" title="0">{
        emptyTasks := NewTasksJSON()
        return s.SaveTasks(ctx, emptyTasks)
}</span>

// GetTasksPath returns the path to the tasks.json file
func (s *Service) GetTasksPath() string <span class="cov0" title="0">{
        return s.tasksJSONPath
}</span>

// ConvertToTaskList converts TasksJSON to legacy TaskList format for compatibility
func (s *Service) ConvertToTaskList(tasksJSON *TasksJSON) *TaskList <span class="cov0" title="0">{
        return ConvertTasksJSONToTaskList(tasksJSON)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package task

import (
        "time"
)

// Task represents a single actionable task
type Task struct {
        ID            string            `json:"id"`
        Type          string            `json:"type"`
        Priority      int               `json:"priority"`
        Title         string            `json:"title"`
        Description   string            `json:"description"`
        Platform      string            `json:"platform"`
        CompletionCmd string            `json:"completion_cmd"`
        Context       map[string]string `json:"context"`
        CreatedAt     time.Time         `json:"created_at"`
}

// TaskList represents a collection of tasks with metadata
type TaskList struct {
        Tasks     []Task    `json:"tasks"`
        Timestamp time.Time `json:"timestamp"`
}

// TasksJSON represents the JSON structure for task persistence
type TasksJSON struct {
        Todo []string `json:"todo"`
        Done []string `json:"done"`
}

// Priority constants
const (
        PriorityCritical = 1
        PriorityHigh     = 2
        PriorityMedium   = 3
        PriorityLow      = 4
)

// Common task types
const (
        TaskTypePRReview       = "pr_review"
        TaskTypeIssueAssigned  = "issue_assigned"
        TaskTypeMention        = "mention"
        TaskTypeSlackMessage   = "slack_message"
        TaskTypeFailedWorkflow = "failed_workflow"
        TaskTypeUnreadComment  = "unread_comment"
        TaskTypeGeneric        = "generic"
)

// Platform constants
const (
        PlatformGitHub  = "github"
        PlatformSlack   = "slack"
        PlatformJira    = "jira"
        PlatformGeneric = "generic"
)

// NewTask creates a new task with the current timestamp
func NewTask(id, taskType, title, description, platform, completionCmd string, priority int) *Task <span class="cov0" title="0">{
        return &amp;Task{
                ID:            id,
                Type:          taskType,
                Priority:      priority,
                Title:         title,
                Description:   description,
                Platform:      platform,
                CompletionCmd: completionCmd,
                Context:       make(map[string]string),
                CreatedAt:     time.Now(),
        }
}</span>

// NewTaskList creates a new task list with the current timestamp
func NewTaskList() *TaskList <span class="cov0" title="0">{
        return &amp;TaskList{
                Tasks:     make([]Task, 0),
                Timestamp: time.Now(),
        }
}</span>

// AddTask adds a task to the task list
func (tl *TaskList) AddTask(task Task) <span class="cov0" title="0">{
        tl.Tasks = append(tl.Tasks, task)
}</span>

// GetHighestPriorityTask returns the task with the highest priority (lowest number)
func (tl *TaskList) GetHighestPriorityTask() *Task <span class="cov0" title="0">{
        if len(tl.Tasks) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">highestPriorityTask := &amp;tl.Tasks[0]
        for i := 1; i &lt; len(tl.Tasks); i++ </span><span class="cov0" title="0">{
                if tl.Tasks[i].Priority &lt; highestPriorityTask.Priority </span><span class="cov0" title="0">{
                        highestPriorityTask = &amp;tl.Tasks[i]
                }</span>
        }

        <span class="cov0" title="0">return highestPriorityTask</span>
}

// FilterByPriority returns tasks with the specified priority
func (tl *TaskList) FilterByPriority(priority int) []Task <span class="cov0" title="0">{
        var filtered []Task
        for _, task := range tl.Tasks </span><span class="cov0" title="0">{
                if task.Priority == priority </span><span class="cov0" title="0">{
                        filtered = append(filtered, task)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

// FilterByType returns tasks with the specified type
func (tl *TaskList) FilterByType(taskType string) []Task <span class="cov0" title="0">{
        var filtered []Task
        for _, task := range tl.Tasks </span><span class="cov0" title="0">{
                if task.Type == taskType </span><span class="cov0" title="0">{
                        filtered = append(filtered, task)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

// FilterByPlatform returns tasks from the specified platform
func (tl *TaskList) FilterByPlatform(platform string) []Task <span class="cov0" title="0">{
        var filtered []Task
        for _, task := range tl.Tasks </span><span class="cov0" title="0">{
                if task.Platform == platform </span><span class="cov0" title="0">{
                        filtered = append(filtered, task)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

// Count returns the total number of tasks
func (tl *TaskList) Count() int <span class="cov0" title="0">{
        return len(tl.Tasks)
}</span>

// IsEmpty returns true if there are no tasks
func (tl *TaskList) IsEmpty() bool <span class="cov0" title="0">{
        return len(tl.Tasks) == 0
}</span>

// NewTasksJSON creates a new empty TasksJSON structure
func NewTasksJSON() *TasksJSON <span class="cov0" title="0">{
        return &amp;TasksJSON{
                Todo: make([]string, 0),
                Done: make([]string, 0),
        }
}</span>

// AddTodoTask adds a task to the todo list
func (tj *TasksJSON) AddTodoTask(task string) <span class="cov0" title="0">{
        if task != "" </span><span class="cov0" title="0">{
                tj.Todo = append(tj.Todo, task)
        }</span>
}

// MoveToDone moves a task from todo to done
func (tj *TasksJSON) MoveToDone(task string) <span class="cov0" title="0">{
        // Remove from todo
        for i, todoTask := range tj.Todo </span><span class="cov0" title="0">{
                if todoTask == task </span><span class="cov0" title="0">{
                        tj.Todo = append(tj.Todo[:i], tj.Todo[i+1:]...)
                        break</span>
                }
        }
        // Add to done
        <span class="cov0" title="0">tj.Done = append(tj.Done, task)</span>
}

// HasTasks returns true if there are any tasks (todo or done)
func (tj *TasksJSON) HasTasks() bool <span class="cov0" title="0">{
        return len(tj.Todo) &gt; 0 || len(tj.Done) &gt; 0
}</span>

// TodoCount returns the number of todo tasks
func (tj *TasksJSON) TodoCount() int <span class="cov0" title="0">{
        return len(tj.Todo)
}</span>

// DoneCount returns the number of done tasks
func (tj *TasksJSON) DoneCount() int <span class="cov0" title="0">{
        return len(tj.Done)
}</span>

// AddDoneTask adds a task to the done list
func (tj *TasksJSON) AddDoneTask(task string) <span class="cov0" title="0">{
        if task != "" </span><span class="cov0" title="0">{
                tj.Done = append(tj.Done, task)
        }</span>
}

// ContainsTodoTask checks if a task is already in the todo list
func (tj *TasksJSON) ContainsTodoTask(task string) bool <span class="cov0" title="0">{
        for _, todoTask := range tj.Todo </span><span class="cov0" title="0">{
                if todoTask == task </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package testutil

import (
        "os"
        "path/filepath"
        "testing"
)

// CreateTempDir creates a temporary directory for testing
func CreateTempDir(t *testing.T) string <span class="cov0" title="0">{
        t.Helper()

        tempDir, err := os.MkdirTemp("", "autoteam-test-*")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create temp dir: %v", err)
        }</span>

        <span class="cov0" title="0">t.Cleanup(func() </span><span class="cov0" title="0">{
                os.RemoveAll(tempDir)
        }</span>)

        <span class="cov0" title="0">return tempDir</span>
}

// CreateTempFile creates a temporary file with content for testing
func CreateTempFile(t *testing.T, dir, filename, content string) string <span class="cov0" title="0">{
        t.Helper()

        filepath := filepath.Join(dir, filename)
        if err := os.WriteFile(filepath, []byte(content), 0600); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create temp file %s: %v", filepath, err)
        }</span>

        <span class="cov0" title="0">return filepath</span>
}

// FileExists checks if a file exists
func FileExists(path string) bool <span class="cov0" title="0">{
        _, err := os.Stat(path)
        return !os.IsNotExist(err)
}</span>

// DirExists checks if a directory exists
func DirExists(path string) bool <span class="cov0" title="0">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return info.IsDir()</span>
}

// ReadFile reads file content for testing
func ReadFile(t *testing.T, path string) string <span class="cov0" title="0">{
        t.Helper()

        content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to read file %s: %v", path, err)
        }</span>

        <span class="cov0" title="0">return string(content)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package worker

import (
        "autoteam/internal/config"
        "fmt"
        "os"

        "gopkg.in/yaml.v3"
)

// LoadWorkerFromFile loads worker configuration directly from a YAML file
func LoadWorkerFromFile(configPath string) (*config.Worker, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file %s: %w", configPath, err)
        }</span>

        <span class="cov0" title="0">var worker config.Worker
        if err := yaml.Unmarshal(data, &amp;worker); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file %s: %w", configPath, err)
        }</span>

        // Validate worker configuration
        <span class="cov0" title="0">if worker.Name == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("worker name is required")
        }</span>

        <span class="cov0" title="0">return &amp;worker, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package worker

import (
        "context"
        "fmt"
        "os"
        "os/exec"
        "strings"
        "time"

        "autoteam/internal/config"
        "autoteam/internal/logger"

        "go.uber.org/zap"
)

// ExecuteHooks executes hooks for a specific lifecycle event
func ExecuteHooks(ctx context.Context, hookConfig *config.HookConfig, hookType string) error <span class="cov0" title="0">{
        hooks := GetHooksForEvent(hookConfig, hookType)
        if len(hooks) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">lgr := logger.FromContext(ctx)
        lgr.Info("Executing container hooks",
                zap.String("hook_type", hookType),
                zap.Int("hook_count", len(hooks)))

        for i, hook := range hooks </span><span class="cov0" title="0">{
                if err := executeHook(ctx, hookType, i+1, hook); err != nil </span><span class="cov0" title="0">{
                        lgr.Error("Hook execution failed",
                                zap.String("hook_type", hookType),
                                zap.Int("hook_index", i+1),
                                zap.Error(err))

                        // Check continue_on setting
                        continueOn := "error" // default
                        if hook.ContinueOn != nil </span><span class="cov0" title="0">{
                                continueOn = *hook.ContinueOn
                        }</span>

                        <span class="cov0" title="0">switch continueOn </span>{
                        case "always":<span class="cov0" title="0">
                                lgr.Info("Continuing despite hook failure (continue_on: always)")
                                continue</span>
                        case "success":<span class="cov0" title="0">
                                return fmt.Errorf("hook %d failed and continue_on is 'success': %w", i+1, err)</span>
                        case "error":<span class="cov0" title="0">
                                lgr.Info("Continuing after hook failure (continue_on: error)")
                                continue</span>
                        default:<span class="cov0" title="0">
                                return fmt.Errorf("hook %d failed: %w", i+1, err)</span>
                        }
                }
        }

        <span class="cov0" title="0">lgr.Info("All hooks executed successfully", zap.String("hook_type", hookType))
        return nil</span>
}

// executeHook executes a single hook command
func executeHook(ctx context.Context, hookType string, index int, hook config.HookCommand) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        description := fmt.Sprintf("Hook %d", index)
        if hook.Description != nil </span><span class="cov0" title="0">{
                description = *hook.Description
        }</span>

        <span class="cov0" title="0">lgr.Info("Executing hook",
                zap.String("hook_type", hookType),
                zap.Int("index", index),
                zap.String("description", description),
                zap.String("command", hook.Command),
                zap.Strings("args", hook.Args))

        // Set working directory - default to container working directory
        workingDir := "/opt/autoteam"
        if hook.WorkingDir != nil </span><span class="cov0" title="0">{
                workingDir = *hook.WorkingDir
        }</span>

        // Set timeout
        <span class="cov0" title="0">timeout := 30 * time.Second // default timeout
        if hook.Timeout != nil </span><span class="cov0" title="0">{
                timeout = time.Duration(*hook.Timeout) * time.Second
        }</span>

        // Create context with timeout
        <span class="cov0" title="0">timeoutCtx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        // Prepare command
        cmd := exec.CommandContext(timeoutCtx, hook.Command, hook.Args...)
        cmd.Dir = workingDir

        // Set environment variables
        cmd.Env = os.Environ()
        for key, value := range hook.Env </span><span class="cov0" title="0">{
                cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", key, value))
        }</span>

        // Capture output
        <span class="cov0" title="0">output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                lgr.Error("Hook command failed",
                        zap.String("hook_type", hookType),
                        zap.Int("index", index),
                        zap.String("command", hook.Command),
                        zap.String("working_dir", workingDir),
                        zap.String("output", string(output)),
                        zap.Error(err))
                return fmt.Errorf("hook command failed: %w\nOutput: %s", err, string(output))
        }</span>

        <span class="cov0" title="0">if len(output) &gt; 0 </span><span class="cov0" title="0">{
                lgr.Info("Hook command output",
                        zap.String("hook_type", hookType),
                        zap.Int("index", index),
                        zap.String("output", strings.TrimSpace(string(output))))
        }</span>

        <span class="cov0" title="0">lgr.Info("Hook executed successfully",
                zap.String("hook_type", hookType),
                zap.Int("index", index))

        return nil</span>
}

// GetHooksForEvent retrieves hooks for a specific event from hook configuration
func GetHooksForEvent(hookConfig *config.HookConfig, eventType string) []config.HookCommand <span class="cov0" title="0">{
        if hookConfig == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">switch eventType </span>{
        case "on_init":<span class="cov0" title="0">
                return hookConfig.OnInit</span>
        case "on_start":<span class="cov0" title="0">
                return hookConfig.OnStart</span>
        case "on_stop":<span class="cov0" title="0">
                return hookConfig.OnStop</span>
        case "on_error":<span class="cov0" title="0">
                return hookConfig.OnError</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
