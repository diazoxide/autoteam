
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>autoteam: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">autoteam/cmd/autoteam/main.go (27.4%)</option>
				
				<option value="file1">autoteam/cmd/entrypoint/main.go (0.0%)</option>
				
				<option value="file2">autoteam/internal/agent/claude_code.go (0.0%)</option>
				
				<option value="file3">autoteam/internal/agent/factory.go (0.0%)</option>
				
				<option value="file4">autoteam/internal/agent/gemini_cli.go (0.0%)</option>
				
				<option value="file5">autoteam/internal/agent/qwen_code.go (0.0%)</option>
				
				<option value="file6">autoteam/internal/config/config.go (53.7%)</option>
				
				<option value="file7">autoteam/internal/deps/installer.go (0.0%)</option>
				
				<option value="file8">autoteam/internal/entrypoint/config.go (0.0%)</option>
				
				<option value="file9">autoteam/internal/generator/fileops.go (56.9%)</option>
				
				<option value="file10">autoteam/internal/generator/generator.go (50.0%)</option>
				
				<option value="file11">autoteam/internal/generator/templates.go (0.0%)</option>
				
				<option value="file12">autoteam/internal/logger/logger.go (0.0%)</option>
				
				<option value="file13">autoteam/internal/monitor/loop.go (0.0%)</option>
				
				<option value="file14">autoteam/internal/task/log_stream.go (0.0%)</option>
				
				<option value="file15">autoteam/internal/task/parser.go (0.0%)</option>
				
				<option value="file16">autoteam/internal/task/prompts.go (0.0%)</option>
				
				<option value="file17">autoteam/internal/task/service.go (0.0%)</option>
				
				<option value="file18">autoteam/internal/task/types.go (0.0%)</option>
				
				<option value="file19">autoteam/internal/testutil/testutil.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "os"
        "os/exec"
        "strings"

        "autoteam/internal/config"
        "autoteam/internal/generator"
        "autoteam/internal/logger"

        "github.com/joho/godotenv"
        "github.com/urfave/cli/v3"
        "go.uber.org/zap"
)

// Build-time variables (set by ldflags)
var (
        Version   = "dev"
        BuildTime = "unknown"
        GitCommit = "unknown"
)

// Context key for storing config
type contextKey string

const configContextKey contextKey = "config"

func main() <span class="cov0" title="0">{
        // Load .env file if it exists (ignore errors for optional file)
        _ = godotenv.Load()

        app := &amp;cli.Command{
                Name:    "autoteam",
                Usage:   "Universal AI Agent Management System",
                Version: fmt.Sprintf("%s (built %s, commit %s)", Version, BuildTime, GitCommit),
                Before:  setupContextWithLogger,
                Flags: []cli.Flag{
                        &amp;cli.StringFlag{
                                Name:    "log-level",
                                Aliases: []string{"l"},
                                Usage:   "Set log level (debug, info, warn, error)",
                                Value:   "warn",
                        },
                },
                Commands: []*cli.Command{
                        {
                                Name:   "generate",
                                Usage:  "Generate compose.yaml from autoteam.yaml",
                                Action: generateCommand,
                        },
                        {
                                Name:   "up",
                                Usage:  "Generate and start containers",
                                Action: upCommand,
                                Flags: []cli.Flag{
                                        &amp;cli.StringFlag{
                                                Name:    "docker-compose-args",
                                                Aliases: []string{"args"},
                                                Usage:   "Additional arguments to pass to docker compose command",
                                                Value:   "",
                                        },
                                },
                        },
                        {
                                Name:   "down",
                                Usage:  "Stop containers",
                                Action: downCommand,
                        },
                        {
                                Name:   "init",
                                Usage:  "Create sample autoteam.yaml",
                                Action: initCommand,
                        },
                        {
                                Name:   "agents",
                                Usage:  "List all agents and their states",
                                Action: agentsCommand,
                        },
                },
        }

        if err := app.Run(context.Background(), os.Args); err != nil </span><span class="cov0" title="0">{
                // Create emergency logger for fatal errors
                if emergencyLogger, logErr := logger.NewLogger(logger.ErrorLevel); logErr == nil </span><span class="cov0" title="0">{
                        emergencyLogger.Fatal("Application failed to run", zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        os.Exit(1)
                }</span>
        }
}

func generateCommand(ctx context.Context, cmd *cli.Command) error <span class="cov8" title="1">{
        log := logger.FromContext(ctx)
        cfg := getConfigFromContext(ctx)
        if cfg == nil </span><span class="cov8" title="1">{
                log.Error("Config not available in context")
                return fmt.Errorf("config not available in context")
        }</span>

        <span class="cov8" title="1">log.Info("Generating compose.yaml", zap.String("team_name", cfg.Settings.GetTeamName()))
        gen := generator.New()
        if err := gen.GenerateCompose(cfg); err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to generate compose.yaml", zap.Error(err))
                return fmt.Errorf("failed to generate compose.yaml: %w", err)
        }</span>

        <span class="cov8" title="1">log.Info("Generated compose.yaml successfully")
        fmt.Println("Generated compose.yaml successfully")
        return nil</span>
}

func upCommand(ctx context.Context, cmd *cli.Command) error <span class="cov0" title="0">{
        if err := generateCommand(ctx, cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("Starting containers...")

        // Start with default args
        args := []string{"up", "-d", "--remove-orphans"}

        // Add additional docker-compose-args if provided
        if dockerComposeArgs := cmd.String("docker-compose-args"); dockerComposeArgs != "" </span><span class="cov0" title="0">{
                // Split the args string by spaces and append to args
                additionalArgs := strings.Fields(dockerComposeArgs)
                args = append(args, additionalArgs...)
        }</span>

        <span class="cov0" title="0">if err := runDockerCompose(ctx, args...); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start containers: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Containers started successfully")
        return nil</span>
}

func downCommand(ctx context.Context, cmd *cli.Command) error <span class="cov0" title="0">{
        fmt.Println("Stopping containers...")
        if err := runDockerCompose(ctx, "down"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop containers: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Containers stopped successfully")
        return nil</span>
}

func initCommand(ctx context.Context, cmd *cli.Command) error <span class="cov8" title="1">{
        if err := config.CreateSampleConfig("autoteam.yaml"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create sample config: %w", err)
        }</span>

        <span class="cov8" title="1">fmt.Println("Created sample autoteam.yaml")
        return nil</span>
}

func agentsCommand(ctx context.Context, cmd *cli.Command) error <span class="cov0" title="0">{
        log := logger.FromContext(ctx)
        cfg := getConfigFromContext(ctx)
        if cfg == nil </span><span class="cov0" title="0">{
                log.Error("Config not available in context")
                return fmt.Errorf("config not available in context")
        }</span>

        <span class="cov0" title="0">fmt.Println("Agents configuration:")
        fmt.Println()

        for i, agent := range cfg.Agents </span><span class="cov0" title="0">{
                status := "enabled"
                if !agent.IsEnabled() </span><span class="cov0" title="0">{
                        status = "disabled"
                }</span>

                <span class="cov0" title="0">fmt.Printf("%d. %s (%s)\n", i+1, agent.Name, status)
                if agent.Prompt != "" </span><span class="cov0" title="0">{
                        // Show first line of prompt
                        lines := strings.Split(agent.Prompt, "\n")
                        if len(lines) &gt; 0 &amp;&amp; lines[0] != "" </span><span class="cov0" title="0">{
                                prompt := lines[0]
                                if len(prompt) &gt; 80 </span><span class="cov0" title="0">{
                                        prompt = prompt[:77] + "..."
                                }</span>
                                <span class="cov0" title="0">fmt.Printf("   Prompt: %s\n", prompt)</span>
                        }
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Summary
        <span class="cov0" title="0">enabledCount := 0
        for _, agent := range cfg.Agents </span><span class="cov0" title="0">{
                if agent.IsEnabled() </span><span class="cov0" title="0">{
                        enabledCount++
                }</span>
        }
        <span class="cov0" title="0">fmt.Printf("Total agents: %d (enabled: %d, disabled: %d)\n",
                len(cfg.Agents), enabledCount, len(cfg.Agents)-enabledCount)

        return nil</span>
}

func runDockerCompose(ctx context.Context, args ...string) error <span class="cov8" title="1">{
        cfg := getConfigFromContext(ctx)

        // Use the compose.yaml file from .autoteam directory
        composeArgs := []string{"-f", config.ComposeFilePath}

        // If config is available, use custom project name, otherwise use default
        if cfg != nil &amp;&amp; cfg.Settings.GetTeamName() != "" </span><span class="cov0" title="0">{
                composeArgs = append(composeArgs, "-p", cfg.Settings.GetTeamName())
        }</span>

        <span class="cov8" title="1">composeArgs = append(composeArgs, args...)

        cmd := exec.Command("docker-compose", composeArgs...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        return cmd.Run()</span>
}

// setupContextWithLogger sets up logger and loads config into context
func setupContextWithLogger(ctx context.Context, cmd *cli.Command) (context.Context, error) <span class="cov0" title="0">{
        // Setup logger first
        logLevelStr := cmd.String("log-level")
        logLevel, err := logger.ParseLogLevel(logLevelStr)
        if err != nil </span><span class="cov0" title="0">{
                return ctx, fmt.Errorf("invalid log level: %w", err)
        }</span>

        <span class="cov0" title="0">ctx, err = logger.SetupContext(ctx, logLevel)
        if err != nil </span><span class="cov0" title="0">{
                return ctx, fmt.Errorf("failed to setup logger: %w", err)
        }</span>

        <span class="cov0" title="0">log := logger.FromContext(ctx)
        log.Info("Starting autoteam",
                zap.String("version", Version),
                zap.String("build_time", BuildTime),
                zap.String("git_commit", GitCommit),
                zap.String("log_level", string(logLevel)),
        )

        // Skip loading config for init command as it creates the config file
        // Check command line arguments since Before hook runs on root command
        if len(os.Args) &gt; 1 &amp;&amp; os.Args[1] == "init" </span><span class="cov0" title="0">{
                return ctx, nil
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadConfig("autoteam.yaml")
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to load config", zap.Error(err))
                return ctx, fmt.Errorf("failed to load config: %w", err)
        }</span>

        <span class="cov0" title="0">log.Debug("Config loaded successfully", zap.String("team_name", cfg.Settings.GetTeamName()))
        return context.WithValue(ctx, configContextKey, cfg), nil</span>
}

// getConfigFromContext retrieves the config from context
func getConfigFromContext(ctx context.Context) *config.Config <span class="cov8" title="1">{
        cfg, ok := ctx.Value(configContextKey).(*config.Config)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return cfg</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "autoteam/internal/agent"
        "autoteam/internal/config"
        "autoteam/internal/deps"
        "autoteam/internal/entrypoint"
        "autoteam/internal/logger"
        "autoteam/internal/monitor"

        "github.com/joho/godotenv"
        "github.com/urfave/cli/v3"
        "go.uber.org/zap"
)

// Build-time variables (set by ldflags)
var (
        Version   = "dev"
        BuildTime = "unknown"
        GitCommit = "unknown"
)

func main() <span class="cov0" title="0">{
        // Load .env file if it exists (ignore errors for optional file)
        _ = godotenv.Load()

        app := &amp;cli.Command{
                Name:    "autoteam-entrypoint",
                Usage:   "AutoTeam Agent Entrypoint - AI agent execution via MCP servers",
                Version: fmt.Sprintf("%s (built %s, commit %s)", Version, BuildTime, GitCommit),
                Action:  runEntrypoint,
                Flags: []cli.Flag{

                        // Agent Configuration
                        &amp;cli.StringFlag{
                                Name:     "agent-name",
                                Usage:    "Name of the agent",
                                Required: true,
                                Sources:  cli.EnvVars("AGENT_NAME"),
                        },
                        &amp;cli.StringFlag{
                                Name:    "agent-type",
                                Value:   "claude",
                                Usage:   "Type of agent to use",
                                Sources: cli.EnvVars("AGENT_TYPE"),
                        },
                        &amp;cli.StringFlag{
                                Name:    "agent-prompt",
                                Usage:   "Primary prompt for the agent",
                                Sources: cli.EnvVars("AGENT_PROMPT"),
                        },

                        // Two-Layer Agent Architecture Configuration
                        &amp;cli.StringFlag{
                                Name:    "aggregation-agent-type",
                                Value:   "qwen",
                                Usage:   "Type of agent for task collection (first layer)",
                                Sources: cli.EnvVars("AGGREGATION_AGENT_TYPE"),
                        },
                        &amp;cli.StringFlag{
                                Name:    "aggregation-agent-args",
                                Usage:   "Comma-separated arguments for aggregation agent",
                                Sources: cli.EnvVars("AGGREGATION_AGENT_ARGS"),
                        },
                        &amp;cli.StringFlag{
                                Name:    "aggregation-agent-env",
                                Usage:   "Comma-separated key=value environment variables for aggregation agent",
                                Sources: cli.EnvVars("AGGREGATION_AGENT_ENV"),
                        },
                        &amp;cli.StringFlag{
                                Name:    "execution-agent-type",
                                Value:   "claude",
                                Usage:   "Type of agent for task execution (second layer)",
                                Sources: cli.EnvVars("EXECUTION_AGENT_TYPE"),
                        },
                        &amp;cli.StringFlag{
                                Name:    "execution-agent-args",
                                Usage:   "Comma-separated arguments for execution agent",
                                Sources: cli.EnvVars("EXECUTION_AGENT_ARGS"),
                        },
                        &amp;cli.StringFlag{
                                Name:    "execution-agent-env",
                                Usage:   "Comma-separated key=value environment variables for execution agent",
                                Sources: cli.EnvVars("EXECUTION_AGENT_ENV"),
                        },
                        &amp;cli.StringFlag{
                                Name:    "aggregation-agent-prompt",
                                Usage:   "Custom prompt for the aggregation agent (first layer)",
                                Sources: cli.EnvVars("AGGREGATION_AGENT_PROMPT"),
                        },
                        &amp;cli.StringFlag{
                                Name:    "execution-agent-prompt",
                                Usage:   "Custom prompt for the execution agent (second layer)",
                                Sources: cli.EnvVars("EXECUTION_AGENT_PROMPT"),
                        },

                        &amp;cli.StringFlag{
                                Name:    "team-name",
                                Value:   "autoteam",
                                Usage:   "Team name for directory structure",
                                Sources: cli.EnvVars("TEAM_NAME"),
                        },

                        // Monitoring Configuration
                        &amp;cli.IntFlag{
                                Name:    "check-interval",
                                Value:   60,
                                Usage:   "Check interval in seconds",
                                Sources: cli.EnvVars("CHECK_INTERVAL"),
                        },
                        &amp;cli.IntFlag{
                                Name:    "max-retries",
                                Value:   100,
                                Usage:   "Maximum number of retries for operations",
                                Sources: cli.EnvVars("MAX_RETRIES"),
                        },
                        &amp;cli.IntFlag{
                                Name:    "max-attempts",
                                Value:   3,
                                Usage:   "Maximum number of attempts per item before moving to cooldown",
                                Sources: cli.EnvVars("MAX_ATTEMPTS"),
                        },

                        // Dependencies Configuration
                        &amp;cli.BoolFlag{
                                Name:    "install-deps",
                                Usage:   "Install dependencies on startup",
                                Sources: cli.EnvVars("INSTALL_DEPS"),
                        },

                        // Runtime Configuration
                        &amp;cli.BoolFlag{
                                Name:    "debug",
                                Usage:   "Enable debug logging",
                                Sources: cli.EnvVars("DEBUG"),
                        },
                        &amp;cli.BoolFlag{
                                Name:  "verbose",
                                Usage: "Enable verbose logging",
                        },
                        &amp;cli.StringFlag{
                                Name:    "log-level",
                                Aliases: []string{"l"},
                                Usage:   "Set log level (debug, info, warn, error)",
                                Value:   "info",
                                Sources: cli.EnvVars("LOG_LEVEL"),
                        },
                },
        }

        if err := app.Run(context.Background(), os.Args); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func runEntrypoint(ctx context.Context, cmd *cli.Command) error <span class="cov0" title="0">{
        // Setup structured logger first
        logLevelStr := cmd.String("log-level")

        // Handle legacy debug/verbose flags
        if cmd.Bool("debug") </span><span class="cov0" title="0">{
                logLevelStr = "debug"
        }</span> else<span class="cov0" title="0"> if cmd.Bool("verbose") </span><span class="cov0" title="0">{
                logLevelStr = "debug"
        }</span>

        <span class="cov0" title="0">logLevel, err := logger.ParseLogLevel(logLevelStr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid log level: %w", err)
        }</span>

        <span class="cov0" title="0">ctx, err = logger.SetupContext(ctx, logLevel)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup logger: %w", err)
        }</span>

        <span class="cov0" title="0">log := logger.FromContext(ctx)
        log.Info("Starting AutoTeam Entrypoint",
                zap.String("version", Version),
                zap.String("build_time", BuildTime),
                zap.String("git_commit", GitCommit),
                zap.String("log_level", string(logLevel)),
        )

        // Build configuration from CLI flags and environment variables
        cfg, err := buildConfigFromFlags(cmd)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to build configuration", zap.Error(err))
                return fmt.Errorf("failed to build configuration: %w", err)
        }</span>

        // Load MCP servers from environment
        <span class="cov0" title="0">mcpServers, mcpErr := entrypoint.LoadMCPServers()
        if mcpErr != nil </span><span class="cov0" title="0">{
                log.Error("Failed to load MCP servers", zap.Error(mcpErr))
                return fmt.Errorf("failed to load MCP servers: %w", mcpErr)
        }</span>
        <span class="cov0" title="0">cfg.MCPServers = mcpServers

        // Validate configuration
        if err = cfg.Validate(); err != nil </span><span class="cov0" title="0">{
                log.Error("Invalid configuration", zap.Error(err))
                return fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info("Configuration loaded successfully",
                zap.String("agent_name", cfg.Agent.Name),
                zap.String("agent_type", cfg.Agent.Type),
                zap.String("team_name", cfg.TeamName),
        )

        // Create context for graceful shutdown
        ctx, cancel := context.WithCancel(ctx)
        defer cancel()

        // Handle interrupt signals
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
        go func() </span><span class="cov0" title="0">{
                sig := &lt;-sigChan
                log.Info("Received signal, shutting down gracefully", zap.String("signal", sig.String()))
                cancel()
        }</span>()

        // Create layer agent configurations from CLI flags
        // First Layer (Task Collection) - AggregationAgent
        <span class="cov0" title="0">firstLayerConfig := config.AgentConfig{
                Type: cmd.String("aggregation-agent-type"),
                Args: parseCommaSeparated(cmd.String("aggregation-agent-args")),
                Env:  parseKeyValuePairs(cmd.String("aggregation-agent-env")),
        }
        if aggregationPrompt := cmd.String("aggregation-agent-prompt"); aggregationPrompt != "" </span><span class="cov0" title="0">{
                firstLayerConfig.Prompt = &amp;aggregationPrompt
        }</span>

        // Second Layer (Task Execution) - Agent
        <span class="cov0" title="0">secondLayerConfig := config.AgentConfig{
                Type: cmd.String("execution-agent-type"),
                Args: parseCommaSeparated(cmd.String("execution-agent-args")),
                Env:  parseKeyValuePairs(cmd.String("execution-agent-env")),
        }
        if executionPrompt := cmd.String("execution-agent-prompt"); executionPrompt != "" </span><span class="cov0" title="0">{
                secondLayerConfig.Prompt = &amp;executionPrompt
        }</span>

        // Create agent helper for consistent naming
        <span class="cov0" title="0">baseAgent := &amp;config.Agent{Name: cfg.Agent.Name}

        // Create First Layer agent (Task Collection)
        log.Debug("Creating task collection agent", zap.String("agent_type", firstLayerConfig.Type))
        collectorAgentName := baseAgent.GetNormalizedNameWithVariation("collector")
        taskCollectionAgent, err := agent.CreateAgent(firstLayerConfig, collectorAgentName, cfg.MCPServers)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to create task collection agent", zap.Error(err))
                return fmt.Errorf("failed to create task collection agent: %w", err)
        }</span>
        <span class="cov0" title="0">log.Info("Task collection agent initialized successfully", zap.String("agent_type", firstLayerConfig.Type))

        // Create Second Layer agent (Task Execution)
        log.Debug("Creating task execution agent", zap.String("agent_type", secondLayerConfig.Type))
        executorAgentName := baseAgent.GetNormalizedNameWithVariation("executor")
        taskExecutionAgent, err := agent.CreateAgent(secondLayerConfig, executorAgentName, cfg.MCPServers)
        if err != nil </span><span class="cov0" title="0">{
                log.Error("Failed to create task execution agent", zap.Error(err))
                return fmt.Errorf("failed to create task execution agent: %w", err)
        }</span>
        <span class="cov0" title="0">log.Info("Task execution agent initialized successfully", zap.String("agent_type", secondLayerConfig.Type))

        // Install dependencies for both agents if needed
        log.Debug("Installing dependencies for agents")
        installer := deps.NewInstaller(cfg.Dependencies)
        if err := installer.Install(ctx, taskCollectionAgent, taskExecutionAgent); err != nil </span><span class="cov0" title="0">{
                log.Warn("Failed to install dependencies for agents", zap.Error(err))
        }</span>

        // Note: Git operations now handled via MCP servers

        // Initialize and start monitor with two-layer config
        <span class="cov0" title="0">monitorConfig := monitor.Config{
                CheckInterval: cfg.Monitoring.CheckInterval,
                TeamName:      cfg.TeamName,
        }

        mon := monitor.New(taskCollectionAgent, taskExecutionAgent, monitorConfig, cfg)

        // Set layer configurations for custom prompt support
        mon.SetLayerConfigs(&amp;firstLayerConfig, &amp;secondLayerConfig)

        log.Info("Starting two-layer agent monitoring loop",
                zap.Duration("check_interval", cfg.Monitoring.CheckInterval),
                zap.String("collection_agent", firstLayerConfig.Type),
                zap.String("execution_agent", secondLayerConfig.Type),
        )
        return mon.Start(ctx)</span>
}

// buildConfigFromFlags builds a Config struct from CLI flags
func buildConfigFromFlags(cmd *cli.Command) (*entrypoint.Config, error) <span class="cov0" title="0">{
        cfg := &amp;entrypoint.Config{}

        // Agent configuration
        cfg.Agent.Name = cmd.String("agent-name")
        cfg.Agent.Type = cmd.String("agent-type")
        cfg.Agent.Prompt = cmd.String("agent-prompt")

        // Team configuration
        cfg.TeamName = cmd.String("team-name")

        // Monitoring configuration
        checkInterval := cmd.Int("check-interval")
        cfg.Monitoring.CheckInterval = time.Duration(checkInterval) * time.Second
        cfg.Monitoring.MaxRetries = cmd.Int("max-retries")

        // Dependencies configuration
        cfg.Dependencies.InstallDeps = cmd.Bool("install-deps")

        // Debug configuration
        cfg.Debug = cmd.Bool("debug")

        return cfg, nil
}</span>

// parseCommaSeparated parses comma-separated arguments from a string
func parseCommaSeparated(value string) []string <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        <span class="cov0" title="0">args := strings.Split(value, ",")
        // Trim whitespace from each arg
        for i, arg := range args </span><span class="cov0" title="0">{
                args[i] = strings.TrimSpace(arg)
        }</span>
        <span class="cov0" title="0">return args</span>
}

// parseKeyValuePairs parses key=value pairs from a string (comma-separated)
func parseKeyValuePairs(value string) map[string]string <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return map[string]string{}
        }</span>

        <span class="cov0" title="0">envMap := make(map[string]string)
        pairs := strings.Split(value, ",")
        for _, pair := range pairs </span><span class="cov0" title="0">{
                if kv := strings.SplitN(strings.TrimSpace(pair), "=", 2); len(kv) == 2 </span><span class="cov0" title="0">{
                        envMap[kv[0]] = kv[1]
                }</span>
        }
        <span class="cov0" title="0">return envMap</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package agent

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        "autoteam/internal/config"
        "autoteam/internal/entrypoint"
        "autoteam/internal/logger"

        "go.uber.org/zap"
)

// ClaudeCode implements the Agent interface for Claude Code
type ClaudeCode struct {
        config     entrypoint.AgentConfig
        binaryPath string
        mcpServers map[string]config.MCPServer
}

// NewClaudeCode creates a new Claude Code agent instance
func NewClaudeCode(cfg entrypoint.AgentConfig) *ClaudeCode <span class="cov0" title="0">{
        return &amp;ClaudeCode{
                config:     cfg,
                binaryPath: "claude", // Will be found in PATH after installation
                mcpServers: make(map[string]config.MCPServer),
        }
}</span>

// NewClaudeCodeWithMCP creates a new Claude Code agent instance with MCP servers
func NewClaudeCodeWithMCP(cfg entrypoint.AgentConfig, mcpServers map[string]config.MCPServer) *ClaudeCode <span class="cov0" title="0">{
        return &amp;ClaudeCode{
                config:     cfg,
                binaryPath: "claude", // Will be found in PATH after installation
                mcpServers: mcpServers,
        }
}</span>

// Name returns the agent name
func (c *ClaudeCode) Name() string <span class="cov0" title="0">{
        return c.config.Name
}</span>

// Type returns the agent type
func (c *ClaudeCode) Type() string <span class="cov0" title="0">{
        return "claude"
}</span>

// Run executes Claude with the given prompt and options
func (c *ClaudeCode) Run(ctx context.Context, prompt string, options RunOptions) (*AgentOutput, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Update Claude before running
        if err := c.update(ctx); err != nil </span><span class="cov0" title="0">{
                lgr.Warn("Failed to update Claude", zap.Error(err))
        }</span>

        // Build the command arguments
        <span class="cov0" title="0">args := c.buildArgs(options)

        var lastErr error
        var lastOutput *AgentOutput
        maxRetries := options.MaxRetries
        if maxRetries &lt;= 0 </span><span class="cov0" title="0">{
                maxRetries = 1
        }</span>

        <span class="cov0" title="0">for attempt := 1; attempt &lt;= maxRetries; attempt++ </span><span class="cov0" title="0">{
                lgr.Info("Claude execution attempt", zap.Int("attempt", attempt), zap.Int("max_retries", maxRetries))

                // Add continue flag when requested or for retry attempts
                currentArgs := args
                if options.ContinueMode || attempt &gt; 1 </span><span class="cov0" title="0">{
                        currentArgs = append(args, "--continue")
                }</span>

                // Prepare output capture buffers
                <span class="cov0" title="0">var stdout, stderr bytes.Buffer

                // Execute Claude
                cmd := exec.CommandContext(ctx, c.binaryPath, currentArgs...)
                cmd.Dir = options.WorkingDirectory
                cmd.Stdout = &amp;stdout
                cmd.Stderr = &amp;stderr
                cmd.Stdin = strings.NewReader(prompt)

                // Set environment variables
                cmd.Env = os.Environ()

                lgr.Debug("Executing Claude command",
                        zap.String("binary", c.binaryPath),
                        zap.Strings("args", currentArgs),
                        zap.String("working_dir", options.WorkingDirectory),
                        zap.Int("prompt_length", len(prompt)))

                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        // Create output after command execution
                        lastOutput = &amp;AgentOutput{
                                Stdout: stdout.String(),
                                Stderr: stderr.String(),
                        }
                        lastErr = fmt.Errorf("claude execution failed (attempt %d): %w", attempt, err)
                        lgr.Warn("Attempt failed",
                                zap.Int("attempt", attempt),
                                zap.Error(err),
                                zap.String("stderr", stderr.String()))

                        // Don't retry on context cancellation
                        if ctx.Err() != nil </span><span class="cov0" title="0">{
                                return lastOutput, ctx.Err()
                        }</span>

                        // Wait before retry (exponential backoff)
                        <span class="cov0" title="0">if attempt &lt; maxRetries </span><span class="cov0" title="0">{
                                backoff := time.Duration(attempt) * time.Second
                                lgr.Info("Retrying", zap.Duration("backoff", backoff))
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return lastOutput, ctx.Err()</span>
                                case &lt;-time.After(backoff):<span class="cov0" title="0">
                                        continue</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        // Create output after successful execution
                        lastOutput = &amp;AgentOutput{
                                Stdout: stdout.String(),
                                Stderr: stderr.String(),
                        }
                        lgr.Info("Claude execution succeeded",
                                zap.Int("attempt", attempt),
                                zap.Int("stdout_length", len(stdout.String())))
                        return lastOutput, nil
                }</span>
        }

        <span class="cov0" title="0">return lastOutput, fmt.Errorf("all %d attempts failed, last error: %w", maxRetries, lastErr)</span>
}

// IsAvailable checks if Claude is available
func (c *ClaudeCode) IsAvailable(ctx context.Context) bool <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, c.binaryPath, "--version")
        return cmd.Run() == nil
}</span>

// CheckAvailability checks if Claude Code is available, returns error if not found
func (c *ClaudeCode) CheckAvailability(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)
        lgr.Info("Checking Claude Code availability")

        if !c.IsAvailable(ctx) </span><span class="cov0" title="0">{
                return fmt.Errorf("claude command not found - please install Claude Code using: npm install -g @anthropic-ai/claude-code")
        }</span>

        <span class="cov0" title="0">lgr.Info("Claude Code is available")
        return nil</span>
}

// Version returns the Claude version
func (c *ClaudeCode) Version(ctx context.Context) (string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, c.binaryPath, "--version")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get Claude version: %w", err)
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(output)), nil</span>
}

// update updates Claude to the latest version
func (c *ClaudeCode) update(ctx context.Context) error <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, c.binaryPath, "update")
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        return cmd.Run()
}</span>

// buildArgs builds the command line arguments for Claude
func (c *ClaudeCode) buildArgs(options RunOptions) []string <span class="cov0" title="0">{
        args := []string{
                "--dangerously-skip-permissions",
                "--output-format", "stream-json",
                "--verbose",
                "--print",
        }

        // Add MCP config file if MCP servers are configured
        if len(c.mcpServers) &gt; 0 </span><span class="cov0" title="0">{
                mcpConfigPath := c.getMCPConfigPath()
                args = append(args, "--mcp-config", mcpConfigPath)
        }</span>

        <span class="cov0" title="0">return args</span>
}

// Configure configures MCP servers in Claude configuration
func (c *ClaudeCode) Configure(ctx context.Context) error <span class="cov0" title="0">{
        return c.ConfigureForProject(ctx, "")
}</span>

// ConfigureForProject configures MCP servers for a specific agent
func (c *ClaudeCode) ConfigureForProject(ctx context.Context, projectPath string) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        if len(c.mcpServers) == 0 </span><span class="cov0" title="0">{
                lgr.Debug("No MCP servers to configure")
                return nil
        }</span>

        <span class="cov0" title="0">lgr.Info("Configuring MCP servers", zap.Int("count", len(c.mcpServers)), zap.String("agent", c.config.Name))

        // Create dedicated MCP configuration file for this agent
        if err := c.createMCPConfigFile(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create MCP configuration file: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Info("MCP servers configured successfully")
        return nil</span>
}

// getMCPConfigPath returns the path to the MCP configuration file for this agent
func (c *ClaudeCode) getMCPConfigPath() string <span class="cov0" title="0">{
        // Use the agent name as passed from the factory (already normalized with variations)
        // Don't re-normalize as it would convert senior_developer/executor back to senior_developer_executor
        return fmt.Sprintf("/opt/autoteam/agents/%s/.mcp.json", c.config.Name)
}</span>

// createMCPConfigFile creates the MCP configuration file for this agent
func (c *ClaudeCode) createMCPConfigFile(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        mcpConfigPath := c.getMCPConfigPath()
        lgr.Info("Creating MCP configuration file", zap.String("path", mcpConfigPath))

        // Ensure the directory exists
        if err := os.MkdirAll(filepath.Dir(mcpConfigPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create MCP config directory: %w", err)
        }</span>

        // Convert MCP servers to Claude format with mcpServers wrapper
        <span class="cov0" title="0">mcpServersMap := make(map[string]interface{})
        for name, server := range c.mcpServers </span><span class="cov0" title="0">{
                serverConfig := map[string]interface{}{
                        "command": server.Command,
                }

                if len(server.Args) &gt; 0 </span><span class="cov0" title="0">{
                        serverConfig["args"] = server.Args
                }</span>

                <span class="cov0" title="0">if len(server.Env) &gt; 0 </span><span class="cov0" title="0">{
                        serverConfig["env"] = server.Env
                }</span>

                <span class="cov0" title="0">mcpServersMap[name] = serverConfig</span>
        }

        // Wrap in mcpServers object as required by Claude format
        <span class="cov0" title="0">mcpConfig := map[string]interface{}{
                "mcpServers": mcpServersMap,
        }

        // Marshal to JSON with indentation for readability
        data, err := json.MarshalIndent(mcpConfig, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal MCP config: %w", err)
        }</span>

        // Write the MCP configuration file
        <span class="cov0" title="0">if err := os.WriteFile(mcpConfigPath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write MCP config file: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Info("MCP configuration file created successfully",
                zap.String("path", mcpConfigPath),
                zap.Int("mcp_servers", len(c.mcpServers)))

        return nil</span>
}

// SetMCPServers sets the MCP servers for this agent
func (c *ClaudeCode) SetMCPServers(mcpServers map[string]config.MCPServer) <span class="cov0" title="0">{
        c.mcpServers = mcpServers
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package agent

import (
        "fmt"

        "autoteam/internal/config"
        "autoteam/internal/entrypoint"
)

// Agent type constants
const (
        AgentTypeClaudeCode = "claude"
        AgentTypeQwenCode   = "qwen"
        AgentTypeGeminiCli  = "gemini"
)

// CreateAgent creates an agent based on configuration
func CreateAgent(agentConfig config.AgentConfig, name string, mcpServers map[string]config.MCPServer) (Agent, error) <span class="cov0" title="0">{
        switch agentConfig.Type </span>{
        case AgentTypeClaudeCode:<span class="cov0" title="0">
                agent := NewClaudeCodeWithConfig(agentConfig, name, mcpServers)
                return agent, nil</span>
        case AgentTypeQwenCode:<span class="cov0" title="0">
                agent := NewQwenCodeWithConfig(agentConfig, name, mcpServers)
                return agent, nil</span>
        case AgentTypeGeminiCli:<span class="cov0" title="0">
                agent := NewGeminiCliWithConfig(agentConfig, name, mcpServers)
                return agent, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported agent type: %s", agentConfig.Type)</span>
        }
}

// CreateAgentFromEntrypointConfig creates an agent from entrypoint configuration (legacy support)
func CreateAgentFromEntrypointConfig(cfg entrypoint.AgentConfig, mcpServers map[string]config.MCPServer) Agent <span class="cov0" title="0">{
        // Default to Claude for backward compatibility
        return NewClaudeCodeWithMCP(cfg, mcpServers)
}</span>

// NewClaudeCodeWithConfig creates a Claude agent from AgentConfig
func NewClaudeCodeWithConfig(agentConfig config.AgentConfig, name string, mcpServers map[string]config.MCPServer) Agent <span class="cov0" title="0">{
        cfg := entrypoint.AgentConfig{Name: name}
        agent := NewClaudeCodeWithMCP(cfg, mcpServers)

        // Claude agent doesn't currently use custom args/env from AgentConfig
        // This could be extended in the future if needed

        return agent
}</span>

// GetSupportedAgentTypes returns a list of supported agent types
func GetSupportedAgentTypes() []string <span class="cov0" title="0">{
        return []string{AgentTypeClaudeCode, AgentTypeQwenCode}
}</span>

// IsValidAgentType checks if the given agent type is supported
func IsValidAgentType(agentType string) bool <span class="cov0" title="0">{
        supportedTypes := GetSupportedAgentTypes()
        for _, supportedType := range supportedTypes </span><span class="cov0" title="0">{
                if agentType == supportedType </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package agent

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        "autoteam/internal/config"
        "autoteam/internal/entrypoint"
        "autoteam/internal/logger"

        "go.uber.org/zap"
)

// GeminiCli implements the Agent interface for Gemini CLI
type GeminiCli struct {
        config     entrypoint.AgentConfig
        binaryPath string
        mcpServers map[string]config.MCPServer
        agentArgs  []string
        agentEnv   map[string]string
}

// NewGeminiCli creates a new Gemini agent instance
func NewGeminiCli(cfg entrypoint.AgentConfig) *GeminiCli <span class="cov0" title="0">{
        return &amp;GeminiCli{
                config:     cfg,
                binaryPath: "gemini", // Will be found in PATH after npm installation
                mcpServers: make(map[string]config.MCPServer),
                agentArgs:  []string{},
                agentEnv:   make(map[string]string),
        }
}</span>

// NewGeminiCliWithMCP creates a new Gemini agent instance with MCP servers
func NewGeminiCliWithMCP(cfg entrypoint.AgentConfig, mcpServers map[string]config.MCPServer) *GeminiCli <span class="cov0" title="0">{
        return &amp;GeminiCli{
                config:     cfg,
                binaryPath: "gemini", // Will be found in PATH after npm installation
                mcpServers: mcpServers,
                agentArgs:  []string{},
                agentEnv:   make(map[string]string),
        }
}</span>

// NewGeminiCliWithConfig creates a new Gemini agent instance with full configuration
func NewGeminiCliWithConfig(agentConfig config.AgentConfig, name string, mcpServers map[string]config.MCPServer) *GeminiCli <span class="cov0" title="0">{
        cfg := entrypoint.AgentConfig{Name: name}
        agent := &amp;GeminiCli{
                config:     cfg,
                binaryPath: "gemini", // Will be found in PATH after npm installation
                mcpServers: mcpServers,
                agentArgs:  make([]string, len(agentConfig.Args)),
                agentEnv:   make(map[string]string),
        }

        // Copy args
        copy(agent.agentArgs, agentConfig.Args)

        // Copy env
        for k, v := range agentConfig.Env </span><span class="cov0" title="0">{
                agent.agentEnv[k] = v
        }</span>

        <span class="cov0" title="0">return agent</span>
}

// Name returns the agent name
func (q *GeminiCli) Name() string <span class="cov0" title="0">{
        return q.config.Name
}</span>

// Type returns the agent type
func (q *GeminiCli) Type() string <span class="cov0" title="0">{
        return "gemini"
}</span>

// Run executes Gemini with the given prompt and options
func (q *GeminiCli) Run(ctx context.Context, prompt string, options RunOptions) (*AgentOutput, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Build the command arguments
        args := q.buildArgs(options)

        var lastErr error
        var lastOutput *AgentOutput
        maxRetries := options.MaxRetries
        if maxRetries &lt;= 0 </span><span class="cov0" title="0">{
                maxRetries = 1
        }</span>

        <span class="cov0" title="0">for attempt := 1; attempt &lt;= maxRetries; attempt++ </span><span class="cov0" title="0">{
                lgr.Info("Gemini execution attempt", zap.Int("attempt", attempt), zap.Int("max_retries", maxRetries))

                // Log the full prompt being sent for debugging
                lgr.Info("Sending full prompt to Gemini",
                        zap.String("prompt_length", fmt.Sprintf("%d chars", len(prompt))),
                        zap.String("full_prompt", prompt))

                // Add continue flag when requested or for retry attempts
                currentArgs := args
                if options.ContinueMode || attempt &gt; 1 </span><span class="cov0" title="0">{
                        currentArgs = append(args, "--continue")
                }</span>

                // Prepare output capture buffers
                <span class="cov0" title="0">var stdout, stderr bytes.Buffer

                // Execute Gemini
                cmd := exec.CommandContext(ctx, q.binaryPath, currentArgs...)

                // Set working directory to agent's directory so Gemini can find .gemini/settings.json
                // If user specified a working directory, use that; otherwise use agent directory
                if options.WorkingDirectory != "" </span><span class="cov0" title="0">{
                        cmd.Dir = options.WorkingDirectory
                }</span> else<span class="cov0" title="0"> {
                        // Use the agent name as passed (already normalized with variations)
                        cmd.Dir = fmt.Sprintf("/opt/autoteam/agents/%s", q.config.Name)
                }</span>

                // Log execution details for debugging
                <span class="cov0" title="0">lgr.Info("Executing Gemini CLI",
                        zap.String("binary_path", q.binaryPath),
                        zap.Strings("args", currentArgs),
                        zap.String("working_dir", cmd.Dir))

                cmd.Stdout = &amp;stdout
                cmd.Stderr = &amp;stderr
                cmd.Stdin = strings.NewReader(prompt)

                // Set environment variables
                cmd.Env = os.Environ()
                // Add custom environment variables from agent config
                for k, v := range q.agentEnv </span><span class="cov0" title="0">{
                        cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", k, v))
                }</span>

                <span class="cov0" title="0">if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        // Create output after command execution
                        lastOutput = &amp;AgentOutput{
                                Stdout: stdout.String(),
                                Stderr: stderr.String(),
                        }
                        lastErr = fmt.Errorf("gemini execution failed (attempt %d): %w", attempt, err)
                        lgr.Warn("Attempt failed",
                                zap.Int("attempt", attempt),
                                zap.Error(err),
                                zap.String("stderr", stderr.String()))

                        // Don't retry on context cancellation
                        if ctx.Err() != nil </span><span class="cov0" title="0">{
                                return lastOutput, ctx.Err()
                        }</span>

                        // Wait before retry (exponential backoff)
                        <span class="cov0" title="0">if attempt &lt; maxRetries </span><span class="cov0" title="0">{
                                backoff := time.Duration(attempt) * time.Second
                                lgr.Info("Retrying", zap.Duration("backoff", backoff))
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return lastOutput, ctx.Err()</span>
                                case &lt;-time.After(backoff):<span class="cov0" title="0">
                                        continue</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        // Create output after successful execution
                        lastOutput = &amp;AgentOutput{
                                Stdout: stdout.String(),
                                Stderr: stderr.String(),
                        }
                        lgr.Info("Gemini execution succeeded",
                                zap.Int("attempt", attempt),
                                zap.Int("stdout_length", len(stdout.String())))
                        return lastOutput, nil
                }</span>
        }

        <span class="cov0" title="0">return lastOutput, fmt.Errorf("all %d attempts failed, last error: %w", maxRetries, lastErr)</span>
}

// IsAvailable checks if Gemini is available
func (q *GeminiCli) IsAvailable(ctx context.Context) bool <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, q.binaryPath, "--version")
        return cmd.Run() == nil
}</span>

// CheckAvailability checks if Gemini CLI is available, returns error if not found
func (q *GeminiCli) CheckAvailability(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)
        lgr.Info("Checking Gemini CLI availability")

        if !q.IsAvailable(ctx) </span><span class="cov0" title="0">{
                return fmt.Errorf("gemini command not found - please install Gemini CLI using: npm install -g @google/gemini-cli")
        }</span>

        <span class="cov0" title="0">lgr.Info("Gemini CLI is available")
        return nil</span>
}

// Version returns the Gemini version
func (q *GeminiCli) Version(ctx context.Context) (string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, q.binaryPath, "--version")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get Gemini version: %w", err)
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(output)), nil</span>
}

// buildArgs builds the command line arguments for Gemini
func (q *GeminiCli) buildArgs(options RunOptions) []string <span class="cov0" title="0">{
        args := make([]string, 0)

        // Add default yolo parameter for non-interactive execution
        args = append(args, "--yolo")

        // Add custom args from agent configuration
        args = append(args, q.agentArgs...)

        // Gemini automatically looks for .gemini/settings.json in the current working directory
        // or ~/.gemini/settings.json globally. Since we set cmd.Dir to the agent's working directory,
        // Gemini will find the .gemini/settings.json file we created there.

        return args
}</span>

// Configure configures MCP servers for Gemini
func (q *GeminiCli) Configure(ctx context.Context) error <span class="cov0" title="0">{
        return q.ConfigureForProject(ctx, "")
}</span>

// ConfigureForProject configures MCP servers for a specific agent
func (q *GeminiCli) ConfigureForProject(ctx context.Context, projectPath string) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        if len(q.mcpServers) == 0 </span><span class="cov0" title="0">{
                lgr.Debug("No MCP servers to configure for Gemini agent")
                return nil
        }</span>

        <span class="cov0" title="0">lgr.Info("Configuring MCP servers for Gemini", zap.Int("count", len(q.mcpServers)), zap.String("agent", q.config.Name))

        // Create dedicated MCP configuration file for this agent
        if err := q.createMCPConfigFile(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create MCP configuration file: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Info("MCP servers configured successfully for Gemini")
        return nil</span>
}

// getMCPConfigPath returns the path to the MCP configuration file for this agent
// Gemini looks for configuration in ~/.gemini/settings.json or project-specific .gemini/settings.json
func (q *GeminiCli) getMCPConfigPath() string <span class="cov0" title="0">{
        // Use the agent name as passed from the factory (already normalized with variations)
        // Don't re-normalize as it would convert senior_developer/collector back to senior_developer_collector
        return fmt.Sprintf("/opt/autoteam/agents/%s/.gemini/settings.json", q.config.Name)
}</span>

// createMCPConfigFile creates the MCP configuration file for this agent
func (q *GeminiCli) createMCPConfigFile(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        mcpConfigPath := q.getMCPConfigPath()
        lgr.Info("Creating MCP configuration file for Gemini", zap.String("path", mcpConfigPath))

        // Ensure the directory exists
        if err := os.MkdirAll(filepath.Dir(mcpConfigPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create MCP config directory: %w", err)
        }</span>

        // Start with existing settings or create new config
        <span class="cov0" title="0">geminiConfig := make(map[string]interface{})

        // Try to read existing settings file
        if existingData, err := os.ReadFile(mcpConfigPath); err == nil </span><span class="cov0" title="0">{
                if err := json.Unmarshal(existingData, &amp;geminiConfig); err != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Failed to parse existing Gemini settings file, creating new one", zap.Error(err))
                        geminiConfig = make(map[string]interface{})
                }</span>
        }

        // Convert MCP servers to Gemini format (same as Claude/Qwen format)
        <span class="cov0" title="0">mcpServersMap := make(map[string]interface{})
        for name, server := range q.mcpServers </span><span class="cov0" title="0">{
                serverConfig := map[string]interface{}{
                        "command": server.Command,
                }

                if len(server.Args) &gt; 0 </span><span class="cov0" title="0">{
                        serverConfig["args"] = server.Args
                }</span>

                <span class="cov0" title="0">if len(server.Env) &gt; 0 </span><span class="cov0" title="0">{
                        serverConfig["env"] = server.Env
                }</span>

                <span class="cov0" title="0">mcpServersMap[name] = serverConfig</span>
        }

        // Add MCP servers to config while preserving existing settings
        <span class="cov0" title="0">geminiConfig["mcpServers"] = mcpServersMap

        // Marshal to JSON with indentation for readability
        data, err := json.MarshalIndent(geminiConfig, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal Gemini config: %w", err)
        }</span>

        // Write the configuration file
        <span class="cov0" title="0">if err := os.WriteFile(mcpConfigPath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write Gemini config file: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Info("MCP configuration file created successfully for Gemini",
                zap.String("path", mcpConfigPath),
                zap.Int("mcp_servers", len(q.mcpServers)))

        return nil</span>
}

// SetMCPServers sets the MCP servers for this agent
func (q *GeminiCli) SetMCPServers(mcpServers map[string]config.MCPServer) <span class="cov0" title="0">{
        q.mcpServers = mcpServers
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package agent

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"
        "time"

        "autoteam/internal/config"
        "autoteam/internal/entrypoint"
        "autoteam/internal/logger"

        "go.uber.org/zap"
)

// QwenCode implements the Agent interface for Qwen Code
type QwenCode struct {
        config     entrypoint.AgentConfig
        binaryPath string
        mcpServers map[string]config.MCPServer
        agentArgs  []string
        agentEnv   map[string]string
}

// NewQwenCode creates a new Qwen agent instance
func NewQwenCode(cfg entrypoint.AgentConfig) *QwenCode <span class="cov0" title="0">{
        return &amp;QwenCode{
                config:     cfg,
                binaryPath: "qwen", // Will be found in PATH after npm installation
                mcpServers: make(map[string]config.MCPServer),
                agentArgs:  []string{},
                agentEnv:   make(map[string]string),
        }
}</span>

// NewQwenCodeWithMCP creates a new Qwen agent instance with MCP servers
func NewQwenCodeWithMCP(cfg entrypoint.AgentConfig, mcpServers map[string]config.MCPServer) *QwenCode <span class="cov0" title="0">{
        return &amp;QwenCode{
                config:     cfg,
                binaryPath: "qwen", // Will be found in PATH after npm installation
                mcpServers: mcpServers,
                agentArgs:  []string{},
                agentEnv:   make(map[string]string),
        }
}</span>

// NewQwenCodeWithConfig creates a new Qwen agent instance with full configuration
func NewQwenCodeWithConfig(agentConfig config.AgentConfig, name string, mcpServers map[string]config.MCPServer) *QwenCode <span class="cov0" title="0">{
        cfg := entrypoint.AgentConfig{Name: name}
        agent := &amp;QwenCode{
                config:     cfg,
                binaryPath: "qwen", // Will be found in PATH after npm installation
                mcpServers: mcpServers,
                agentArgs:  make([]string, len(agentConfig.Args)),
                agentEnv:   make(map[string]string),
        }

        // Copy args
        copy(agent.agentArgs, agentConfig.Args)

        // Copy env
        for k, v := range agentConfig.Env </span><span class="cov0" title="0">{
                agent.agentEnv[k] = v
        }</span>

        <span class="cov0" title="0">return agent</span>
}

// Name returns the agent name
func (q *QwenCode) Name() string <span class="cov0" title="0">{
        return q.config.Name
}</span>

// Type returns the agent type
func (q *QwenCode) Type() string <span class="cov0" title="0">{
        return "qwen"
}</span>

// Run executes Qwen with the given prompt and options
func (q *QwenCode) Run(ctx context.Context, prompt string, options RunOptions) (*AgentOutput, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Build the command arguments
        args := q.buildArgs(options)

        var lastErr error
        var lastOutput *AgentOutput
        maxRetries := options.MaxRetries
        if maxRetries &lt;= 0 </span><span class="cov0" title="0">{
                maxRetries = 1
        }</span>

        <span class="cov0" title="0">for attempt := 1; attempt &lt;= maxRetries; attempt++ </span><span class="cov0" title="0">{
                lgr.Info("Qwen execution attempt", zap.Int("attempt", attempt), zap.Int("max_retries", maxRetries))

                // Add continue flag when requested or for retry attempts
                currentArgs := args
                if options.ContinueMode || attempt &gt; 1 </span><span class="cov0" title="0">{
                        currentArgs = append(args, "--continue")
                }</span>

                // Prepare output capture buffers
                <span class="cov0" title="0">var stdout, stderr bytes.Buffer

                // Execute Qwen
                cmd := exec.CommandContext(ctx, q.binaryPath, currentArgs...)

                // Set working directory to agent's directory so Qwen can find .qwen/settings.json
                // If user specified a working directory, use that; otherwise use agent directory
                if options.WorkingDirectory != "" </span><span class="cov0" title="0">{
                        cmd.Dir = options.WorkingDirectory
                }</span> else<span class="cov0" title="0"> {
                        // Get agent directory where .qwen/settings.json is located
                        configAgent := &amp;config.Agent{Name: q.config.Name}
                        normalizedAgentName := configAgent.GetNormalizedName()
                        cmd.Dir = fmt.Sprintf("/opt/autoteam/agents/%s", normalizedAgentName)
                }</span>

                <span class="cov0" title="0">cmd.Stdout = &amp;stdout
                cmd.Stderr = &amp;stderr
                cmd.Stdin = strings.NewReader(prompt)

                // Set environment variables
                cmd.Env = os.Environ()
                // Add custom environment variables from agent config
                for k, v := range q.agentEnv </span><span class="cov0" title="0">{
                        cmd.Env = append(cmd.Env, fmt.Sprintf("%s=%s", k, v))
                }</span>

                <span class="cov0" title="0">if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        // Create output after command execution
                        lastOutput = &amp;AgentOutput{
                                Stdout: stdout.String(),
                                Stderr: stderr.String(),
                        }
                        lastErr = fmt.Errorf("qwen execution failed (attempt %d): %w", attempt, err)
                        lgr.Warn("Attempt failed",
                                zap.Int("attempt", attempt),
                                zap.Error(err),
                                zap.String("stderr", stderr.String()))

                        // Don't retry on context cancellation
                        if ctx.Err() != nil </span><span class="cov0" title="0">{
                                return lastOutput, ctx.Err()
                        }</span>

                        // Wait before retry (exponential backoff)
                        <span class="cov0" title="0">if attempt &lt; maxRetries </span><span class="cov0" title="0">{
                                backoff := time.Duration(attempt) * time.Second
                                lgr.Info("Retrying", zap.Duration("backoff", backoff))
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return lastOutput, ctx.Err()</span>
                                case &lt;-time.After(backoff):<span class="cov0" title="0">
                                        continue</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        // Create output after successful execution
                        lastOutput = &amp;AgentOutput{
                                Stdout: stdout.String(),
                                Stderr: stderr.String(),
                        }
                        lgr.Info("Qwen execution succeeded",
                                zap.Int("attempt", attempt),
                                zap.Int("stdout_length", len(stdout.String())))
                        return lastOutput, nil
                }</span>
        }

        <span class="cov0" title="0">return lastOutput, fmt.Errorf("all %d attempts failed, last error: %w", maxRetries, lastErr)</span>
}

// IsAvailable checks if Qwen is available
func (q *QwenCode) IsAvailable(ctx context.Context) bool <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, q.binaryPath, "--version")
        return cmd.Run() == nil
}</span>

// CheckAvailability checks if Qwen Code is available, returns error if not found
func (q *QwenCode) CheckAvailability(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)
        lgr.Info("Checking Qwen Code availability")

        if !q.IsAvailable(ctx) </span><span class="cov0" title="0">{
                return fmt.Errorf("qwen command not found - please install Qwen Code using: npm install -g @qwen-code/qwen-code@latest")
        }</span>

        <span class="cov0" title="0">lgr.Info("Qwen Code is available")
        return nil</span>
}

// Version returns the Qwen version
func (q *QwenCode) Version(ctx context.Context) (string, error) <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, q.binaryPath, "--version")
        output, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get Qwen version: %w", err)
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(string(output)), nil</span>
}

// buildArgs builds the command line arguments for Qwen
func (q *QwenCode) buildArgs(options RunOptions) []string <span class="cov0" title="0">{
        args := make([]string, 0)

        // Add default yolo parameter for non-interactive execution
        args = append(args, "--yolo")

        // Add custom args from agent configuration
        args = append(args, q.agentArgs...)

        // Qwen Code automatically looks for .qwen/settings.json in the current working directory
        // Since we set cmd.Dir to the agent's working directory, Qwen will find the .qwen/settings.json file we created there.

        return args
}</span>

// Configure configures MCP servers for Qwen
func (q *QwenCode) Configure(ctx context.Context) error <span class="cov0" title="0">{
        return q.ConfigureForProject(ctx, "")
}</span>

// ConfigureForProject configures MCP servers for a specific agent
func (q *QwenCode) ConfigureForProject(ctx context.Context, projectPath string) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        if len(q.mcpServers) == 0 </span><span class="cov0" title="0">{
                lgr.Debug("No MCP servers to configure for Qwen agent")
                return nil
        }</span>

        <span class="cov0" title="0">lgr.Info("Configuring MCP servers for Qwen", zap.Int("count", len(q.mcpServers)), zap.String("agent", q.config.Name))

        // Create dedicated MCP configuration file for this agent
        if err := q.createMCPConfigFile(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create MCP configuration file: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Info("MCP servers configured successfully for Qwen")
        return nil</span>
}

// getMCPConfigPath returns the path to the MCP configuration file for this agent
// Qwen Code looks for configuration in .qwen/settings.json in the project directory
func (q *QwenCode) getMCPConfigPath() string <span class="cov0" title="0">{
        // Use the agent name as passed from the factory (already normalized with variations)
        // Don't re-normalize as it would convert senior_developer/collector back to senior_developer_collector
        return fmt.Sprintf("/opt/autoteam/agents/%s/.qwen/settings.json", q.config.Name)
}</span>

// createMCPConfigFile creates the MCP configuration file for this agent
func (q *QwenCode) createMCPConfigFile(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        mcpConfigPath := q.getMCPConfigPath()
        lgr.Info("Creating MCP configuration file for Qwen", zap.String("path", mcpConfigPath))

        // Ensure the directory exists
        if err := os.MkdirAll(filepath.Dir(mcpConfigPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create MCP config directory: %w", err)
        }</span>

        // Start with existing settings or create new config
        <span class="cov0" title="0">qwenConfig := make(map[string]interface{})

        // Try to read existing settings file
        if existingData, err := os.ReadFile(mcpConfigPath); err == nil </span><span class="cov0" title="0">{
                if err := json.Unmarshal(existingData, &amp;qwenConfig); err != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Failed to parse existing Qwen settings file, creating new one", zap.Error(err))
                        qwenConfig = make(map[string]interface{})
                }</span>
        }

        // Convert MCP servers to Qwen format (similar to Gemini/Claude format)
        <span class="cov0" title="0">mcpServersMap := make(map[string]interface{})
        for name, server := range q.mcpServers </span><span class="cov0" title="0">{
                serverConfig := map[string]interface{}{
                        "command": server.Command,
                }

                if len(server.Args) &gt; 0 </span><span class="cov0" title="0">{
                        serverConfig["args"] = server.Args
                }</span>

                <span class="cov0" title="0">if len(server.Env) &gt; 0 </span><span class="cov0" title="0">{
                        serverConfig["env"] = server.Env
                }</span>

                <span class="cov0" title="0">mcpServersMap[name] = serverConfig</span>
        }

        // Add MCP servers to config while preserving existing settings
        <span class="cov0" title="0">qwenConfig["mcpServers"] = mcpServersMap

        // Marshal to JSON with indentation for readability
        data, err := json.MarshalIndent(qwenConfig, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal Qwen config: %w", err)
        }</span>

        // Write the configuration file
        <span class="cov0" title="0">if err := os.WriteFile(mcpConfigPath, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write Qwen config file: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Info("MCP configuration file created successfully for Qwen",
                zap.String("path", mcpConfigPath),
                zap.Int("mcp_servers", len(q.mcpServers)))

        return nil</span>
}

// SetMCPServers sets the MCP servers for this agent
func (q *QwenCode) SetMCPServers(mcpServers map[string]config.MCPServer) <span class="cov0" title="0">{
        q.mcpServers = mcpServers
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "fmt"
        "maps"
        "os"
        "regexp"
        "strings"

        "gopkg.in/yaml.v3"
)

// Default configuration constants
const (
        DefaultTeamName = "autoteam"
)

type Config struct {
        Agents     []Agent                           `yaml:"agents"`
        Services   map[string]map[string]interface{} `yaml:"services,omitempty"`
        Settings   AgentSettings                     `yaml:"settings"`
        MCPServers map[string]MCPServer              `yaml:"mcp_servers,omitempty"`
}

type Agent struct {
        Name       string               `yaml:"name"`
        Prompt     string               `yaml:"prompt"`
        Enabled    *bool                `yaml:"enabled,omitempty"`
        Settings   *AgentSettings       `yaml:"settings,omitempty"`
        MCPServers map[string]MCPServer `yaml:"mcp_servers,omitempty"`
}

type AgentSettings struct {
        CheckInterval *int                   `yaml:"check_interval,omitempty"`
        TeamName      *string                `yaml:"team_name,omitempty"`
        InstallDeps   *bool                  `yaml:"install_deps,omitempty"`
        CommonPrompt  *string                `yaml:"common_prompt,omitempty"`
        MaxAttempts   *int                   `yaml:"max_attempts,omitempty"`
        Service       map[string]interface{} `yaml:"service,omitempty"`
        MCPServers    map[string]MCPServer   `yaml:"mcp_servers,omitempty"`
        // Per-agent First Layer override
        AggregationAgent *AgentConfig `yaml:"aggregation_agent,omitempty"`
        // Per-agent Second Layer override
        ExecutionAgent *AgentConfig `yaml:"execution_agent,omitempty"`
}

// MCPServer represents a Model Context Protocol server configuration
type MCPServer struct {
        Command string            `yaml:"command"`
        Args    []string          `yaml:"args,omitempty"`
        Env     map[string]string `yaml:"env,omitempty"`
}

// AgentConfig represents unified agent configuration structure
type AgentConfig struct {
        Type   string            `yaml:"type"`
        Args   []string          `yaml:"args,omitempty"`
        Env    map[string]string `yaml:"env,omitempty"`
        Prompt *string           `yaml:"prompt,omitempty"`
}

func LoadConfig(filename string) (*Config, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov8" title="1">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse YAML: %w", err)
        }</span>

        // Validate required fields
        <span class="cov8" title="1">if err := validateConfig(&amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        // Set defaults
        <span class="cov8" title="1">setDefaults(&amp;config)

        return &amp;config, nil</span>
}

// isRegexPattern checks if a pattern is a regex pattern (wrapped with /)
func isRegexPattern(pattern string) bool <span class="cov0" title="0">{
        return strings.HasPrefix(pattern, "/") &amp;&amp; strings.HasSuffix(pattern, "/") &amp;&amp; len(pattern) &gt; 2
}</span>

// extractRegexPattern extracts the regex pattern from /pattern/ format
func extractRegexPattern(pattern string) string <span class="cov0" title="0">{
        if !isRegexPattern(pattern) </span><span class="cov0" title="0">{
                return pattern
        }</span>
        <span class="cov0" title="0">return pattern[1 : len(pattern)-1]</span>
}

// matchesPattern checks if a repository name matches a pattern (exact or regex)
func matchesPattern(repoName, pattern string) bool <span class="cov0" title="0">{
        if isRegexPattern(pattern) </span><span class="cov0" title="0">{
                regex, err := regexp.Compile(extractRegexPattern(pattern))
                if err != nil </span><span class="cov0" title="0">{
                        return false // Invalid regex, no match
                }</span>
                <span class="cov0" title="0">return regex.MatchString(repoName)</span>
        }
        <span class="cov0" title="0">return repoName == pattern</span>
}

func validateConfig(config *Config) error <span class="cov8" title="1">{

        if len(config.Agents) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("at least one agent must be configured")
        }</span>

        // Count enabled agents
        <span class="cov8" title="1">enabledCount := 0
        for _, agent := range config.Agents </span><span class="cov8" title="1">{
                if agent.IsEnabled() </span><span class="cov8" title="1">{
                        enabledCount++
                }</span>
        }

        <span class="cov8" title="1">if enabledCount == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("at least one agent must be enabled")
        }</span>

        <span class="cov8" title="1">for i, agent := range config.Agents </span><span class="cov8" title="1">{
                if agent.Name == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("agent[%d].name is required", i)
                }</span>
                // Only validate required fields for enabled agents
                <span class="cov8" title="1">if agent.IsEnabled() </span><span class="cov8" title="1">{
                        if agent.Prompt == "" </span><span class="cov8" title="1">{
                                return fmt.Errorf("agent[%d].prompt is required for enabled agents", i)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func setDefaults(config *Config) <span class="cov8" title="1">{
        if config.Settings.CheckInterval == nil </span><span class="cov8" title="1">{
                config.Settings.CheckInterval = IntPtr(60)
        }</span>
        <span class="cov8" title="1">if config.Settings.TeamName == nil </span><span class="cov8" title="1">{
                config.Settings.TeamName = StringPtr(DefaultTeamName)
        }</span>
        <span class="cov8" title="1">if config.Settings.MaxAttempts == nil </span><span class="cov8" title="1">{
                config.Settings.MaxAttempts = IntPtr(3)
        }</span>
        // Set default service configuration if not provided
        <span class="cov8" title="1">if config.Settings.Service == nil </span><span class="cov8" title="1">{
                config.Settings.Service = map[string]interface{}{
                        "image": "node:18.17.1",
                        "user":  "developer",
                }
        }</span>
}

func CreateSampleConfig(filename string) error <span class="cov8" title="1">{
        sampleConfig := Config{
                Agents: []Agent{
                        {
                                Name:   "dev1",
                                Prompt: "You are a developer agent responsible for implementing features and fixing bugs.",
                        },
                        {
                                Name:   "arch1",
                                Prompt: "You are an architecture agent responsible for system design and code reviews.",
                                Settings: &amp;AgentSettings{
                                        CheckInterval: IntPtr(30),
                                        Service: map[string]interface{}{
                                                "image": "python:3.11",
                                                "volumes": []string{
                                                        "./custom-configs:/app/configs:ro",
                                                        "/var/run/docker.sock:/var/run/docker.sock",
                                                },
                                                "environment": map[string]string{
                                                        "PYTHON_PATH": "/app/custom",
                                                        "DEBUG_MODE":  "true",
                                                },
                                        },
                                },
                        },
                        {
                                Name:    "devops1",
                                Prompt:  "You are a DevOps agent responsible for CI/CD and infrastructure.",
                                Enabled: BoolPtr(false), // This agent is disabled
                        },
                },
                Services: map[string]map[string]interface{}{
                        "postgres": {
                                "image": "postgres:15",
                                "environment": map[string]string{
                                        "POSTGRES_DB":       "autoteam_dev",
                                        "POSTGRES_USER":     "autoteam",
                                        "POSTGRES_PASSWORD": "development_password",
                                },
                                "ports": []string{"5432:5432"},
                                "volumes": []string{
                                        "postgres_data:/var/lib/postgresql/data",
                                        "./sql/init.sql:/docker-entrypoint-initdb.d/init.sql:ro",
                                },
                        },
                        "redis": {
                                "image":   "redis:7",
                                "ports":   []string{"6379:6379"},
                                "volumes": []string{"redis_data:/data"},
                        },
                },
                Settings: AgentSettings{
                        CheckInterval: IntPtr(60),
                        TeamName:      StringPtr(DefaultTeamName),
                        InstallDeps:   BoolPtr(true),
                        CommonPrompt:  StringPtr("Always follow coding best practices and write comprehensive tests."),
                        MaxAttempts:   IntPtr(3),
                        Service: map[string]interface{}{
                                "image": "node:18.17.1",
                                "user":  "developer",
                        },
                },
                MCPServers: map[string]MCPServer{
                        "memory": {
                                Command: "npx",
                                Args:    []string{"-y", "mcp-memory-service"},
                        },
                },
        }

        data, err := yaml.Marshal(&amp;sampleConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal sample config: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(filename, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write sample config: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// mergeServiceConfigs merges global and agent service configurations
// Agent service properties override global ones, with special handling for maps and arrays
func mergeServiceConfigs(global, agent map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        if global == nil &amp;&amp; agent == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if global == nil </span><span class="cov0" title="0">{
                return copyServiceConfig(agent)
        }</span>
        <span class="cov8" title="1">if agent == nil </span><span class="cov0" title="0">{
                return copyServiceConfig(global)
        }</span>

        // Start with a copy of global config
        <span class="cov8" title="1">result := copyServiceConfig(global)

        // Override/merge with agent config
        for key, agentValue := range agent </span><span class="cov8" title="1">{
                globalValue, exists := result[key]

                // If key doesn't exist in global, just add it
                if !exists </span><span class="cov8" title="1">{
                        result[key] = agentValue
                        continue</span>
                }

                // Universal map merging - merge any map-type values recursively
                <span class="cov8" title="1">if merged := tryMergeAsMapRecursive(globalValue, agentValue); merged != nil </span><span class="cov8" title="1">{
                        result[key] = merged
                        continue</span>
                }

                // For all other properties (including arrays like volumes, ports), agent replaces global
                <span class="cov8" title="1">result[key] = agentValue</span>
        }

        <span class="cov8" title="1">return result</span>
}

// tryMergeAsMap attempts to merge two values as maps of various types
// Returns the merged map if successful, nil if values aren't compatible maps
func tryMergeAsMap(globalValue, agentValue interface{}) interface{} <span class="cov0" title="0">{
        // Try map[string]string first (most common for environment, labels, etc.)
        if globalMap, ok := globalValue.(map[string]string); ok </span><span class="cov0" title="0">{
                if agentMap, ok := agentValue.(map[string]string); ok </span><span class="cov0" title="0">{
                        merged := make(map[string]string)
                        // Copy global values first
                        for k, v := range globalMap </span><span class="cov0" title="0">{
                                merged[k] = v
                        }</span>
                        // Override with agent values
                        <span class="cov0" title="0">for k, v := range agentMap </span><span class="cov0" title="0">{
                                merged[k] = v
                        }</span>
                        <span class="cov0" title="0">return merged</span>
                }
        }

        // Try map[string]interface{} (common after YAML unmarshaling)
        <span class="cov0" title="0">if globalMap, ok := globalValue.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if agentMap, ok := agentValue.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        merged := make(map[string]interface{})
                        // Copy global values first
                        for k, v := range globalMap </span><span class="cov0" title="0">{
                                merged[k] = v
                        }</span>
                        // Override with agent values
                        <span class="cov0" title="0">for k, v := range agentMap </span><span class="cov0" title="0">{
                                merged[k] = v
                        }</span>
                        <span class="cov0" title="0">return merged</span>
                }
        }

        // Try mixed map types - convert map[string]string to map[string]interface{}
        <span class="cov0" title="0">if globalMap, ok := globalValue.(map[string]string); ok </span><span class="cov0" title="0">{
                if agentMap, ok := agentValue.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        merged := make(map[string]interface{})
                        // Copy global values first (convert to interface{})
                        for k, v := range globalMap </span><span class="cov0" title="0">{
                                merged[k] = v
                        }</span>
                        // Override with agent values
                        <span class="cov0" title="0">for k, v := range agentMap </span><span class="cov0" title="0">{
                                merged[k] = v
                        }</span>
                        <span class="cov0" title="0">return merged</span>
                }
        }

        // Try reverse mixed types - convert map[string]interface{} to accommodate map[string]string
        <span class="cov0" title="0">if globalMap, ok := globalValue.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if agentMap, ok := agentValue.(map[string]string); ok </span><span class="cov0" title="0">{
                        merged := make(map[string]interface{})
                        // Copy global values first
                        for k, v := range globalMap </span><span class="cov0" title="0">{
                                merged[k] = v
                        }</span>
                        // Override with agent values (convert to interface{})
                        <span class="cov0" title="0">for k, v := range agentMap </span><span class="cov0" title="0">{
                                merged[k] = v
                        }</span>
                        <span class="cov0" title="0">return merged</span>
                }
        }

        // Values aren't compatible maps
        <span class="cov0" title="0">return nil</span>
}

// tryMergeAsMapRecursive attempts to merge two values as maps recursively using golang maps package
// Returns the merged map if successful, nil if values aren't compatible maps
func tryMergeAsMapRecursive(globalValue, agentValue interface{}) interface{} <span class="cov8" title="1">{
        // Try map[string]string first (most common for environment, labels, etc.)
        if globalMap, ok := globalValue.(map[string]string); ok </span><span class="cov8" title="1">{
                if agentMap, ok := agentValue.(map[string]string); ok </span><span class="cov8" title="1">{
                        // Use maps.Clone for efficient copying, then merge
                        merged := maps.Clone(globalMap)
                        maps.Copy(merged, agentMap) // Agent values override global
                        return merged
                }</span>
        }

        // Try map[string]interface{} (common after YAML unmarshaling) with recursive merging
        <span class="cov8" title="1">if globalMap, ok := globalValue.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                if agentMap, ok := agentValue.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        // Use maps.Clone for efficient copying
                        merged := maps.Clone(globalMap)

                        // Recursively merge/override with agent values
                        for k, agentVal := range agentMap </span><span class="cov8" title="1">{
                                globalVal, exists := merged[k]

                                if !exists </span><span class="cov8" title="1">{
                                        // Key doesn't exist in global, just add it (deep copy)
                                        merged[k] = deepCopyValue(agentVal)
                                }</span> else<span class="cov8" title="1"> {
                                        // Try recursive merge for nested maps
                                        if recursiveMerged := tryMergeAsMapRecursive(globalVal, agentVal); recursiveMerged != nil </span><span class="cov8" title="1">{
                                                merged[k] = recursiveMerged
                                        }</span> else<span class="cov8" title="1"> {
                                                // Not mergeable maps, agent value replaces global (deep copy)
                                                merged[k] = deepCopyValue(agentVal)
                                        }</span>
                                }
                        }
                        <span class="cov8" title="1">return merged</span>
                }
        }

        // Try mixed map types - convert map[string]string to map[string]interface{}
        <span class="cov8" title="1">if globalMap, ok := globalValue.(map[string]string); ok </span><span class="cov0" title="0">{
                if agentMap, ok := agentValue.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        // Convert global to interface{} map and clone
                        merged := make(map[string]interface{})
                        for k, v := range globalMap </span><span class="cov0" title="0">{
                                merged[k] = v
                        }</span>

                        // Recursively merge/override with agent values
                        <span class="cov0" title="0">for k, agentVal := range agentMap </span><span class="cov0" title="0">{
                                globalVal, exists := merged[k]

                                if !exists </span><span class="cov0" title="0">{
                                        merged[k] = deepCopyValue(agentVal)
                                }</span> else<span class="cov0" title="0"> {
                                        if recursiveMerged := tryMergeAsMapRecursive(globalVal, agentVal); recursiveMerged != nil </span><span class="cov0" title="0">{
                                                merged[k] = recursiveMerged
                                        }</span> else<span class="cov0" title="0"> {
                                                merged[k] = deepCopyValue(agentVal)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">return merged</span>
                }
        }

        // Try reverse mixed types - convert map[string]interface{} to accommodate map[string]string
        <span class="cov8" title="1">if globalMap, ok := globalValue.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                if agentMap, ok := agentValue.(map[string]string); ok </span><span class="cov0" title="0">{
                        // Use maps.Clone for efficient copying
                        merged := maps.Clone(globalMap)

                        // Override with agent values (convert to interface{})
                        for k, v := range agentMap </span><span class="cov0" title="0">{
                                merged[k] = v
                        }</span>
                        <span class="cov0" title="0">return merged</span>
                }
        }

        // Values aren't compatible maps
        <span class="cov8" title="1">return nil</span>
}

// deepCopyValue creates a deep copy of various value types
func deepCopyValue(value interface{}) interface{} <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case map[string]string:<span class="cov0" title="0">
                return maps.Clone(v)</span> // Use efficient maps.Clone
        case map[string]interface{}:<span class="cov0" title="0">
                // Deep copy for nested interface{} maps
                copied := make(map[string]interface{})
                for k, val := range v </span><span class="cov0" title="0">{
                        copied[k] = deepCopyValue(val) // Recursive deep copy
                }</span>
                <span class="cov0" title="0">return copied</span>
        case []string:<span class="cov0" title="0">
                // Use slices.Clone if available, otherwise manual copy
                copied := make([]string, len(v))
                copy(copied, v)
                return copied</span>
        case []interface{}:<span class="cov0" title="0">
                // Deep copy for slice of interfaces
                copied := make([]interface{}, len(v))
                for i, val := range v </span><span class="cov0" title="0">{
                        copied[i] = deepCopyValue(val) // Recursive deep copy
                }</span>
                <span class="cov0" title="0">return copied</span>
        default:<span class="cov8" title="1">
                // For primitive types (string, int, bool, etc.), direct assignment is fine
                return value</span>
        }
}

// copyServiceConfig creates a deep copy of a service configuration map
func copyServiceConfig(source map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        if source == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">result := make(map[string]interface{})
        for key, value := range source </span><span class="cov8" title="1">{
                // Special handling for map types (like environment)
                if envMap, ok := value.(map[string]string); ok </span><span class="cov8" title="1">{
                        newEnvMap := make(map[string]string)
                        for k, v := range envMap </span><span class="cov8" title="1">{
                                newEnvMap[k] = v
                        }</span>
                        <span class="cov8" title="1">result[key] = newEnvMap</span>
                } else<span class="cov8" title="1"> if strSlice, ok := value.([]string); ok </span><span class="cov8" title="1">{
                        // Copy string slices (like volumes)
                        newSlice := make([]string, len(strSlice))
                        copy(newSlice, strSlice)
                        result[key] = newSlice
                }</span> else<span class="cov8" title="1"> {
                        // For other types, direct assignment (should be safe for scalars)
                        result[key] = value
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// mergeMCPServers merges MCP server configurations from global settings, agent settings, and agent-level MCP servers
// Priority: agent-level MCPServers &gt; agent.settings.MCPServers &gt; global settings MCPServers
func mergeMCPServers(globalMCPServers, agentSettingsMCPServers, agentMCPServers map[string]MCPServer) map[string]MCPServer <span class="cov8" title="1">{
        if globalMCPServers == nil &amp;&amp; agentSettingsMCPServers == nil &amp;&amp; agentMCPServers == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">result := make(map[string]MCPServer)

        // Start with global MCP servers
        for name, server := range globalMCPServers </span><span class="cov0" title="0">{
                result[name] = copyMCPServer(server)
        }</span>

        // Override with agent settings MCP servers
        <span class="cov0" title="0">for name, server := range agentSettingsMCPServers </span><span class="cov0" title="0">{
                result[name] = copyMCPServer(server)
        }</span>

        // Override with agent-level MCP servers (highest priority)
        <span class="cov0" title="0">for name, server := range agentMCPServers </span><span class="cov0" title="0">{
                result[name] = copyMCPServer(server)
        }</span>

        <span class="cov0" title="0">return result</span>
}

// copyMCPServer creates a deep copy of an MCPServer
func copyMCPServer(server MCPServer) MCPServer <span class="cov0" title="0">{
        copied := MCPServer{
                Command: server.Command,
        }

        // Copy args slice
        if server.Args != nil </span><span class="cov0" title="0">{
                copied.Args = make([]string, len(server.Args))
                copy(copied.Args, server.Args)
        }</span>

        // Copy env map using maps.Clone
        <span class="cov0" title="0">if server.Env != nil </span><span class="cov0" title="0">{
                copied.Env = maps.Clone(server.Env)
        }</span>

        <span class="cov0" title="0">return copied</span>
}

// mergeAgentConfig merges agent configurations with agent-level overriding global
func mergeAgentConfig(global, agentLevel *AgentConfig) *AgentConfig <span class="cov8" title="1">{
        if agentLevel != nil </span><span class="cov0" title="0">{
                return copyAgentConfig(agentLevel)
        }</span>
        <span class="cov8" title="1">if global != nil </span><span class="cov0" title="0">{
                return copyAgentConfig(global)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// copyAgentConfig creates a deep copy of an AgentConfig
func copyAgentConfig(source *AgentConfig) *AgentConfig <span class="cov8" title="1">{
        if source == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">copied := &amp;AgentConfig{
                Type: source.Type,
        }

        // Copy args slice
        if source.Args != nil </span><span class="cov0" title="0">{
                copied.Args = make([]string, len(source.Args))
                copy(copied.Args, source.Args)
        }</span>

        // Copy env map using maps.Clone
        <span class="cov0" title="0">if source.Env != nil </span><span class="cov0" title="0">{
                copied.Env = maps.Clone(source.Env)
        }</span>

        // Copy prompt
        <span class="cov0" title="0">if source.Prompt != nil </span><span class="cov0" title="0">{
                copied.Prompt = StringPtr(*source.Prompt)
        }</span>

        <span class="cov0" title="0">return copied</span>
}

// copyAgentSettings creates a deep copy of an AgentSettings
func copyAgentSettings(source AgentSettings) AgentSettings <span class="cov8" title="1">{
        copied := AgentSettings{}

        if source.CheckInterval != nil </span><span class="cov8" title="1">{
                copied.CheckInterval = IntPtr(*source.CheckInterval)
        }</span>
        <span class="cov8" title="1">if source.TeamName != nil </span><span class="cov8" title="1">{
                copied.TeamName = StringPtr(*source.TeamName)
        }</span>
        <span class="cov8" title="1">if source.InstallDeps != nil </span><span class="cov8" title="1">{
                copied.InstallDeps = BoolPtr(*source.InstallDeps)
        }</span>
        <span class="cov8" title="1">if source.CommonPrompt != nil </span><span class="cov0" title="0">{
                copied.CommonPrompt = StringPtr(*source.CommonPrompt)
        }</span>
        <span class="cov8" title="1">if source.MaxAttempts != nil </span><span class="cov0" title="0">{
                copied.MaxAttempts = IntPtr(*source.MaxAttempts)
        }</span>

        // Copy service configuration
        <span class="cov8" title="1">if source.Service != nil </span><span class="cov8" title="1">{
                copied.Service = copyServiceConfig(source.Service)
        }</span>

        // Copy MCP servers
        <span class="cov8" title="1">if source.MCPServers != nil </span><span class="cov0" title="0">{
                copied.MCPServers = make(map[string]MCPServer)
                for k, v := range source.MCPServers </span><span class="cov0" title="0">{
                        copied.MCPServers[k] = copyMCPServer(v)
                }</span>
        }

        // Copy agent configurations
        <span class="cov8" title="1">copied.AggregationAgent = copyAgentConfig(source.AggregationAgent)
        copied.ExecutionAgent = copyAgentConfig(source.ExecutionAgent)

        return copied</span>
}

// GetEffectiveSettings returns the effective settings for an agent,
// merging global settings with agent-specific overrides
func (a *Agent) GetEffectiveSettings(globalSettings AgentSettings) AgentSettings <span class="cov8" title="1">{
        effective := copyAgentSettings(globalSettings) // Start with copy of global settings

        // Always merge MCP servers, even if agent settings is nil
        effective.MCPServers = mergeMCPServers(globalSettings.MCPServers, nil, a.MCPServers)

        if a.Settings == nil </span><span class="cov8" title="1">{
                return effective
        }</span>

        // Override with agent-specific settings where provided
        <span class="cov8" title="1">if a.Settings.CheckInterval != nil </span><span class="cov8" title="1">{
                effective.CheckInterval = a.Settings.CheckInterval
        }</span>
        <span class="cov8" title="1">if a.Settings.TeamName != nil </span><span class="cov8" title="1">{
                effective.TeamName = a.Settings.TeamName
        }</span>
        <span class="cov8" title="1">if a.Settings.InstallDeps != nil </span><span class="cov8" title="1">{
                effective.InstallDeps = a.Settings.InstallDeps
        }</span>
        <span class="cov8" title="1">if a.Settings.CommonPrompt != nil </span><span class="cov0" title="0">{
                effective.CommonPrompt = a.Settings.CommonPrompt
        }</span>
        <span class="cov8" title="1">if a.Settings.MaxAttempts != nil </span><span class="cov0" title="0">{
                effective.MaxAttempts = a.Settings.MaxAttempts
        }</span>

        // Merge service configurations
        <span class="cov8" title="1">if len(a.Settings.Service) &gt; 0 </span><span class="cov8" title="1">{
                effective.Service = mergeServiceConfigs(globalSettings.Service, a.Settings.Service)
        }</span>

        // Merge MCP server configurations
        <span class="cov8" title="1">effective.MCPServers = mergeMCPServers(globalSettings.MCPServers, a.Settings.MCPServers, a.MCPServers)

        // Merge layer agent configurations
        effective.AggregationAgent = mergeAgentConfig(globalSettings.AggregationAgent, a.Settings.AggregationAgent)
        effective.ExecutionAgent = mergeAgentConfig(globalSettings.ExecutionAgent, a.Settings.ExecutionAgent)

        return effective</span>
}

// GetAllAgentsWithEffectiveSettings returns a slice of agents with their effective settings
func (c *Config) GetAllAgentsWithEffectiveSettings() []AgentWithSettings <span class="cov8" title="1">{
        var agents []AgentWithSettings
        for _, agent := range c.Agents </span><span class="cov8" title="1">{
                agents = append(agents, AgentWithSettings{
                        Agent:             agent,
                        EffectiveSettings: agent.GetEffectiveSettings(c.Settings),
                })
        }</span>
        <span class="cov8" title="1">return agents</span>
}

// GetEnabledAgentsWithEffectiveSettings returns only enabled agents with their effective settings
func (c *Config) GetEnabledAgentsWithEffectiveSettings() []AgentWithSettings <span class="cov8" title="1">{
        var agents []AgentWithSettings
        for _, agent := range c.Agents </span><span class="cov8" title="1">{
                if agent.IsEnabled() </span><span class="cov8" title="1">{
                        agents = append(agents, AgentWithSettings{
                                Agent:             agent,
                                EffectiveSettings: agent.GetEffectiveSettings(c.Settings),
                        })
                }</span>
        }
        <span class="cov8" title="1">return agents</span>
}

type AgentWithSettings struct {
        Agent             Agent
        EffectiveSettings AgentSettings
}

// GetConsolidatedPrompt returns the agent prompt combined with common prompt
func (aws *AgentWithSettings) GetConsolidatedPrompt(cfg *Config) string <span class="cov0" title="0">{
        var promptParts []string

        // Add agent-specific prompt
        if aws.Agent.Prompt != "" </span><span class="cov0" title="0">{
                promptParts = append(promptParts, aws.Agent.Prompt)
        }</span>

        // Add common prompt
        <span class="cov0" title="0">if aws.EffectiveSettings.CommonPrompt != nil &amp;&amp; *aws.EffectiveSettings.CommonPrompt != "" </span><span class="cov0" title="0">{
                promptParts = append(promptParts, *aws.EffectiveSettings.CommonPrompt)
        }</span>

        <span class="cov0" title="0">if len(promptParts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return strings.Join(promptParts, "\n\n")</span>
}

// normalizeAgentName converts agent names to snake_case for use in service names and paths
func normalizeAgentName(name string) string <span class="cov8" title="1">{
        // Replace any non-alphanumeric characters with underscores
        reg := regexp.MustCompile(`[^a-zA-Z0-9]+`)
        normalized := reg.ReplaceAllString(name, "_")

        // Convert to lowercase
        normalized = strings.ToLower(normalized)

        // Remove leading/trailing underscores
        normalized = strings.Trim(normalized, "_")

        // Replace multiple consecutive underscores with single underscore
        multiUnderscoreReg := regexp.MustCompile(`_+`)
        normalized = multiUnderscoreReg.ReplaceAllString(normalized, "_")

        return normalized
}</span>

// GetNormalizedName returns the normalized agent name suitable for service names and paths
func (a *Agent) GetNormalizedName() string <span class="cov8" title="1">{
        return normalizeAgentName(a.Name)
}</span>

// GetNormalizedNameWithVariation returns the normalized agent name with a variation (e.g., collector, executor)
// for two-layer architecture using subdirectory structure
func (a *Agent) GetNormalizedNameWithVariation(variation string) string <span class="cov8" title="1">{
        normalizedName := normalizeAgentName(a.Name)
        if variation == "" </span><span class="cov8" title="1">{
                return normalizedName
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s/%s", normalizedName, variation)</span>
}

// IsEnabled returns true if the agent is enabled (default is true)
func (a *Agent) IsEnabled() bool <span class="cov8" title="1">{
        if a.Enabled == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return *a.Enabled</span>
}

// StringPtr returns a pointer to the given string value. Suitable for optional string parameters or configurations.
func StringPtr(s string) *string <span class="cov8" title="1">{
        return &amp;s
}</span>

// IntPtr returns a pointer to the given int value. Suitable for optional int parameters or configurations.
func IntPtr(i int) *int <span class="cov8" title="1">{
        return &amp;i
}</span>

// BoolPtr returns a pointer to the given boolean value.
func BoolPtr(b bool) *bool <span class="cov8" title="1">{
        return &amp;b
}</span>

// Helper methods to get values with defaults for AgentSettings
func (s *AgentSettings) GetCheckInterval() int <span class="cov8" title="1">{
        if s.CheckInterval != nil </span><span class="cov8" title="1">{
                return *s.CheckInterval
        }</span>
        <span class="cov0" title="0">return 60</span> // default
}

func (s *AgentSettings) GetTeamName() string <span class="cov8" title="1">{
        if s.TeamName != nil </span><span class="cov8" title="1">{
                return *s.TeamName
        }</span>
        <span class="cov0" title="0">return DefaultTeamName</span> // default
}

func (s *AgentSettings) GetInstallDeps() bool <span class="cov8" title="1">{
        if s.InstallDeps != nil </span><span class="cov8" title="1">{
                return *s.InstallDeps
        }</span>
        <span class="cov0" title="0">return false</span> // default
}

func (s *AgentSettings) GetCommonPrompt() string <span class="cov0" title="0">{
        if s.CommonPrompt != nil </span><span class="cov0" title="0">{
                return *s.CommonPrompt
        }</span>
        <span class="cov0" title="0">return ""</span> // default
}

func (s *AgentSettings) GetMaxAttempts() int <span class="cov8" title="1">{
        if s.MaxAttempts != nil </span><span class="cov8" title="1">{
                return *s.MaxAttempts
        }</span>
        <span class="cov0" title="0">return 3</span> // default
}

// GetEffectiveLayers returns the effective layer configurations for an agent
func (a *Agent) GetEffectiveLayers(globalSettings AgentSettings) (firstLayer, secondLayer *AgentConfig) <span class="cov0" title="0">{
        effectiveSettings := a.GetEffectiveSettings(globalSettings)

        // First Layer (Task Collection) - AggregationAgent field
        firstLayer = effectiveSettings.AggregationAgent

        // Second Layer (Task Execution) - ExecutionAgent field
        secondLayer = effectiveSettings.ExecutionAgent

        return firstLayer, secondLayer
}</span>

// GetEffectiveFirstLayerPrompt returns the custom prompt for the first layer (aggregation agent) if configured
func (a *Agent) GetEffectiveFirstLayerPrompt(globalSettings AgentSettings) *string <span class="cov0" title="0">{
        firstLayer, _ := a.GetEffectiveLayers(globalSettings)
        if firstLayer != nil &amp;&amp; firstLayer.Prompt != nil </span><span class="cov0" title="0">{
                return firstLayer.Prompt
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetEffectiveSecondLayerPrompt returns the custom prompt for the second layer (execution agent) if configured
func (a *Agent) GetEffectiveSecondLayerPrompt(globalSettings AgentSettings) *string <span class="cov0" title="0">{
        _, secondLayer := a.GetEffectiveLayers(globalSettings)
        if secondLayer != nil &amp;&amp; secondLayer.Prompt != nil </span><span class="cov0" title="0">{
                return secondLayer.Prompt
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package deps

import (
        "context"
        "fmt"
        "os/exec"

        "autoteam/internal/agent"
        "autoteam/internal/entrypoint"
        "autoteam/internal/logger"

        "go.uber.org/zap"
)

// Installer handles dependency installation
type Installer struct {
        config entrypoint.DependenciesConfig
}

// NewInstaller creates a new dependency installer
func NewInstaller(cfg entrypoint.DependenciesConfig) *Installer <span class="cov0" title="0">{
        return &amp;Installer{
                config: cfg,
        }
}</span>

// Install checks if all required dependencies are available for multiple agents
func (i *Installer) Install(ctx context.Context, agents ...agent.Agent) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        if !i.config.InstallDeps </span><span class="cov0" title="0">{
                lgr.Info("Dependency checking disabled, skipping")
                return nil
        }</span>

        <span class="cov0" title="0">lgr.Info("Checking dependencies for agents", zap.Int("agent_count", len(agents)))

        // Check shared dependencies once
        if err := i.checkSharedDependencies(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("shared dependencies not available: %w\n\nPlease install missing dependencies manually", err)
        }</span>

        // Check agent-specific dependencies for each agent
        <span class="cov0" title="0">for _, selectedAgent := range agents </span><span class="cov0" title="0">{
                if err := i.checkAgentSpecificDependencies(ctx, selectedAgent); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("agent %s dependencies not available: %w", selectedAgent.Type(), err)
                }</span>
        }

        <span class="cov0" title="0">lgr.Info("All dependencies are available")
        return nil</span>
}

// hasCommand checks if a command is available
func (i *Installer) hasCommand(ctx context.Context, command string) bool <span class="cov0" title="0">{
        cmd := exec.CommandContext(ctx, "which", command)
        return cmd.Run() == nil
}</span>

// CheckDependencies checks if all required dependencies are available for multiple agents
func (i *Installer) CheckDependencies(ctx context.Context, agents ...agent.Agent) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)
        lgr.Info("Checking dependencies for agents", zap.Int("agent_count", len(agents)))

        // Check shared dependencies once
        if err := i.checkSharedDependencies(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Check each agent's specific dependencies
        <span class="cov0" title="0">for _, selectedAgent := range agents </span><span class="cov0" title="0">{
                if err := i.checkAgentSpecificDependencies(ctx, selectedAgent); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">lgr.Info("All dependencies are available")
        return nil</span>
}

// checkSharedDependencies checks dependencies that are shared across all agents
func (i *Installer) checkSharedDependencies(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Check git
        if !i.hasCommand(ctx, "git") </span><span class="cov0" title="0">{
                return fmt.Errorf("git command not found - please install git")
        }</span>
        <span class="cov0" title="0">lgr.Debug("git is available")

        // Check GitHub CLI
        if !i.hasCommand(ctx, "gh") </span><span class="cov0" title="0">{
                return fmt.Errorf("GitHub CLI (gh) command not found - please install GitHub CLI from https://cli.github.com")
        }</span>
        <span class="cov0" title="0">lgr.Debug("GitHub CLI (gh) is available")

        return nil</span>
}

// checkAgentSpecificDependencies checks dependencies specific to a single agent
func (i *Installer) checkAgentSpecificDependencies(ctx context.Context, selectedAgent agent.Agent) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Check if agent is available - this will also call agent.CheckAvailability() which now just checks
        if err := selectedAgent.CheckAvailability(ctx); err != nil </span><span class="cov0" title="0">{
                return err // Agent.CheckAvailability() now returns detailed error messages with installation instructions
        }</span>

        <span class="cov0" title="0">lgr.Debug("Agent is available", zap.String("agent_type", selectedAgent.Type()))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package entrypoint

import (
        "encoding/json"
        "fmt"
        "os"
        "strconv"
        "time"

        "autoteam/internal/config"
)

// Config represents the complete configuration for the entrypoint
type Config struct {
        Agent        AgentConfig
        TeamName     string
        Monitoring   MonitoringConfig
        Dependencies DependenciesConfig
        MCPServers   map[string]config.MCPServer
        Debug        bool
}

// AgentConfig contains AI agent configuration
type AgentConfig struct {
        Name   string
        Type   string
        Prompt string
}

// MonitoringConfig contains monitoring loop configuration
type MonitoringConfig struct {
        CheckInterval time.Duration
        MaxRetries    int
}

// DependenciesConfig contains dependency installation configuration
type DependenciesConfig struct {
        InstallDeps bool
}

// Load loads configuration from environment variables
func Load() (*Config, error) <span class="cov0" title="0">{
        cfg := &amp;Config{}

        // Agent configuration
        cfg.Agent.Name = os.Getenv("AGENT_NAME")
        if cfg.Agent.Name == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("AGENT_NAME environment variable is required")
        }</span>

        <span class="cov0" title="0">cfg.Agent.Type = getEnvOrDefault("AGENT_TYPE", "claude")
        cfg.Agent.Prompt = os.Getenv("AGENT_PROMPT")

        // Team configuration
        cfg.TeamName = getEnvOrDefault("TEAM_NAME", "autoteam")

        // Monitoring configuration
        checkInterval := getEnvOrDefault("CHECK_INTERVAL", "60")
        interval, err := strconv.Atoi(checkInterval)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid CHECK_INTERVAL: %w", err)
        }</span>
        <span class="cov0" title="0">cfg.Monitoring.CheckInterval = time.Duration(interval) * time.Second

        maxRetries := getEnvOrDefault("MAX_RETRIES", "100")
        cfg.Monitoring.MaxRetries, err = strconv.Atoi(maxRetries)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid MAX_RETRIES: %w", err)
        }</span>

        // Dependencies configuration
        <span class="cov0" title="0">cfg.Dependencies.InstallDeps = getEnvOrDefault("INSTALL_DEPS", "false") == "true"

        // MCP servers configuration
        cfg.MCPServers, err = LoadMCPServers()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load MCP servers: %w", err)
        }</span>

        // Debug configuration
        <span class="cov0" title="0">cfg.Debug = getEnvOrDefault("DEBUG", "false") == "true"

        return cfg, nil</span>
}

// getEnvOrDefault returns the environment variable value or a default value
func getEnvOrDefault(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov0" title="0">{
        if c.Agent.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("agent name is required")
        }</span>
        <span class="cov0" title="0">if c.Monitoring.CheckInterval &lt; time.Second </span><span class="cov0" title="0">{
                return fmt.Errorf("check interval must be at least 1 second")
        }</span>
        <span class="cov0" title="0">if c.Monitoring.MaxRetries &lt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("max retries must be at least 1")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// LoadMCPServers loads MCP server configuration from environment variables
func LoadMCPServers() (map[string]config.MCPServer, error) <span class="cov0" title="0">{
        mcpServersJSON := os.Getenv("MCP_SERVERS")
        if mcpServersJSON == "" </span><span class="cov0" title="0">{
                return nil, nil // No MCP servers configured
        }</span>

        <span class="cov0" title="0">var mcpServers map[string]config.MCPServer
        if err := json.Unmarshal([]byte(mcpServersJSON), &amp;mcpServers); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse MCP_SERVERS JSON: %w", err)
        }</span>

        <span class="cov0" title="0">return mcpServers, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package generator

import (
        "fmt"
        "os"
        "path/filepath"

        "autoteam/internal/config"
)

// FileOperations handles file and directory operations for the generator
type FileOperations struct{}

// NewFileOperations creates a new FileOperations instance
func NewFileOperations() *FileOperations <span class="cov8" title="1">{
        return &amp;FileOperations{}
}</span>

// EnsureDirectory creates a directory if it doesn't exist
func (f *FileOperations) EnsureDirectory(path string, perm os.FileMode) error <span class="cov8" title="1">{
        if err := f.ValidatePath(path); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid path %s: %w", path, err)
        }</span>

        <span class="cov8" title="1">if err := os.MkdirAll(path, perm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory %s: %w", path, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RemoveIfExists removes a file or directory if it exists
func (f *FileOperations) RemoveIfExists(path string) error <span class="cov8" title="1">{
        if err := f.ValidatePath(path); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid path %s: %w", path, err)
        }</span>

        <span class="cov8" title="1">if _, err := os.Lstat(path); err == nil </span><span class="cov0" title="0">{
                if err := os.RemoveAll(path); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove %s: %w", path, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// WriteFileIfNotExists writes content to a file only if it doesn't exist
func (f *FileOperations) WriteFileIfNotExists(path string, content []byte, perm os.FileMode) error <span class="cov0" title="0">{
        if err := f.ValidatePath(path); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid path %s: %w", path, err)
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                if err := os.WriteFile(path, content, perm); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write file %s: %w", path, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CopyDirectory recursively copies a directory from src to dst
func (f *FileOperations) CopyDirectory(src, dst string) error <span class="cov8" title="1">{
        if err := f.ValidatePath(src); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid source path %s: %w", src, err)
        }</span>
        <span class="cov8" title="1">if err := f.ValidatePath(dst); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid destination path %s: %w", dst, err)
        }</span>

        // Create destination directory
        <span class="cov8" title="1">if err := f.EnsureDirectory(dst, config.DirPerm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination directory: %w", err)
        }</span>

        // Read source directory
        <span class="cov8" title="1">entries, err := os.ReadDir(src)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read source directory %s: %w", src, err)
        }</span>

        // Copy each entry
        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                srcPath := filepath.Join(src, entry.Name())
                dstPath := filepath.Join(dst, entry.Name())

                if entry.IsDir() </span><span class="cov0" title="0">{
                        // Recursively copy subdirectory
                        if err := f.CopyDirectory(srcPath, dstPath); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to copy subdirectory %s: %w", entry.Name(), err)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Copy file
                        if err := f.CopyFile(srcPath, dstPath); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to copy file %s: %w", entry.Name(), err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// CopyFile copies a single file from src to dst with preserved permissions
func (f *FileOperations) CopyFile(src, dst string) error <span class="cov8" title="1">{
        if err := f.ValidatePath(src); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid source path %s: %w", src, err)
        }</span>
        <span class="cov8" title="1">if err := f.ValidatePath(dst); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid destination path %s: %w", dst, err)
        }</span>

        // Read source file
        <span class="cov8" title="1">srcData, err := os.ReadFile(src)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read source file %s: %w", src, err)
        }</span>

        // Get source file permissions
        <span class="cov8" title="1">srcInfo, err := os.Stat(src)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get source file info for %s: %w", src, err)
        }</span>

        // Write destination file with same permissions
        <span class="cov8" title="1">if err := os.WriteFile(dst, srcData, srcInfo.Mode()); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write destination file %s: %w", dst, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DirectoryExists checks if a directory exists
func (f *FileOperations) DirectoryExists(path string) bool <span class="cov8" title="1">{
        if err := f.ValidatePath(path); err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return info.IsDir()</span>
}

// ValidatePath performs basic validation on file paths
func (f *FileOperations) ValidatePath(path string) error <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("path cannot be empty")
        }</span>

        // Check for path traversal attempts
        <span class="cov8" title="1">cleanPath := filepath.Clean(path)
        if cleanPath != path &amp;&amp; !filepath.IsAbs(path) </span><span class="cov0" title="0">{
                return fmt.Errorf("potentially unsafe path detected")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CreateAgentDirectoryStructure creates the complete directory structure for an agent
func (f *FileOperations) CreateAgentDirectoryStructure(agentName string) error <span class="cov8" title="1">{
        agentDir := filepath.Join(config.AgentsDir, agentName)

        // Create main agent directory - subdirectories will be created as needed by individual layers
        if err := f.EnsureDirectory(agentDir, config.DirPerm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create agent directory for agent %s: %w", agentName, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package generator

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "autoteam/internal/config"

        "gopkg.in/yaml.v3"
)

// ComposeConfig represents the structure of a Docker Compose file
type ComposeConfig struct {
        Services map[string]interface{} `yaml:"services"`
}

type Generator struct {
        fileOps *FileOperations
}

func New() *Generator <span class="cov8" title="1">{
        return &amp;Generator{
                fileOps: NewFileOperations(),
        }
}</span>

func (g *Generator) GenerateCompose(cfg *config.Config) error <span class="cov8" title="1">{
        // Ensure .autoteam directory exists
        if err := g.fileOps.EnsureDirectory(config.AutoTeamDir, config.DirPerm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create .autoteam directory: %w", err)
        }</span>

        // Ensure agents directories exist
        <span class="cov8" title="1">if err := g.createAgentDirectories(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create agent directories: %w", err)
        }</span>

        // Generate compose.yaml programmatically
        <span class="cov8" title="1">if err := g.generateComposeYAML(cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate compose.yaml: %w", err)
        }</span>

        // Copy system bin directory
        <span class="cov8" title="1">if err := g.copyBinDirectory(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy bin directory: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// generateComposeYAML creates a Docker Compose YAML file programmatically
func (g *Generator) generateComposeYAML(cfg *config.Config) error <span class="cov8" title="1">{
        compose := ComposeConfig{
                Services: make(map[string]interface{}),
        }

        // Get only enabled agents with their effective settings
        agentsWithSettings := cfg.GetEnabledAgentsWithEffectiveSettings()

        for _, agentWithSettings := range agentsWithSettings </span><span class="cov8" title="1">{
                agent := agentWithSettings.Agent
                settings := agentWithSettings.EffectiveSettings
                serviceName := agent.GetNormalizedName()

                // Start with the service configuration from settings
                serviceConfig := make(map[string]interface{})

                // Copy all service properties from effective settings
                if settings.Service != nil </span><span class="cov8" title="1">{
                        for key, value := range settings.Service </span><span class="cov8" title="1">{
                                serviceConfig[key] = value
                        }</span>
                }

                // Add standard Docker Compose properties that are always needed
                <span class="cov8" title="1">serviceConfig["tty"] = true
                serviceConfig["stdin_open"] = true

                // Build volumes array
                volumes := []string{
                        fmt.Sprintf("./agents/%s:/opt/autoteam/agents/%s", serviceName, serviceName),
                        "./bin:/opt/autoteam/bin",
                }

                // Add any additional volumes from service config
                if existingVolumes, ok := serviceConfig["volumes"]; ok </span><span class="cov8" title="1">{
                        if volumeSlice, ok := existingVolumes.([]string); ok </span><span class="cov8" title="1">{
                                volumes = append(volumes, volumeSlice...)
                        }</span> else<span class="cov0" title="0"> if volumeInterface, ok := existingVolumes.([]interface{}); ok </span><span class="cov0" title="0">{
                                // Handle case where YAML unmarshals to []interface{}
                                for _, v := range volumeInterface </span><span class="cov0" title="0">{
                                        if volumeStr, ok := v.(string); ok </span><span class="cov0" title="0">{
                                                volumes = append(volumes, volumeStr)
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">serviceConfig["volumes"] = volumes

                // Build environment variables
                environment := make(map[string]string)

                // Add standard environment variables
                environment["IS_SANDBOX"] = "1"
                environment["AGENT_NAME"] = agent.Name
                environment["AGENT_NORMALIZED_NAME"] = serviceName
                environment["AGENT_TYPE"] = "claude"
                environment["AGENT_PROMPT"] = agentWithSettings.GetConsolidatedPrompt(cfg)
                environment["TEAM_NAME"] = settings.GetTeamName()
                environment["CHECK_INTERVAL"] = fmt.Sprintf("%d", settings.GetCheckInterval())
                environment["INSTALL_DEPS"] = fmt.Sprintf("%t", settings.GetInstallDeps())

                // Two-Layer Agent Architecture Configuration
                if settings.AggregationAgent != nil </span><span class="cov0" title="0">{
                        environment["AGGREGATION_AGENT_TYPE"] = settings.AggregationAgent.Type
                        if len(settings.AggregationAgent.Args) &gt; 0 </span><span class="cov0" title="0">{
                                environment["AGGREGATION_AGENT_ARGS"] = strings.Join(settings.AggregationAgent.Args, ",")
                        }</span>
                        <span class="cov0" title="0">if len(settings.AggregationAgent.Env) &gt; 0 </span><span class="cov0" title="0">{
                                var envPairs []string
                                for k, v := range settings.AggregationAgent.Env </span><span class="cov0" title="0">{
                                        envPairs = append(envPairs, k+"="+v)
                                }</span>
                                <span class="cov0" title="0">environment["AGGREGATION_AGENT_ENV"] = strings.Join(envPairs, ",")</span>
                        }
                        <span class="cov0" title="0">if settings.AggregationAgent.Prompt != nil </span><span class="cov0" title="0">{
                                environment["AGGREGATION_AGENT_PROMPT"] = *settings.AggregationAgent.Prompt
                        }</span>
                }
                <span class="cov8" title="1">if settings.ExecutionAgent != nil </span><span class="cov0" title="0">{
                        environment["EXECUTION_AGENT_TYPE"] = settings.ExecutionAgent.Type
                        if len(settings.ExecutionAgent.Args) &gt; 0 </span><span class="cov0" title="0">{
                                environment["EXECUTION_AGENT_ARGS"] = strings.Join(settings.ExecutionAgent.Args, ",")
                        }</span>
                        <span class="cov0" title="0">if len(settings.ExecutionAgent.Env) &gt; 0 </span><span class="cov0" title="0">{
                                var envPairs []string
                                for k, v := range settings.ExecutionAgent.Env </span><span class="cov0" title="0">{
                                        envPairs = append(envPairs, k+"="+v)
                                }</span>
                                <span class="cov0" title="0">environment["EXECUTION_AGENT_ENV"] = strings.Join(envPairs, ",")</span>
                        }
                        <span class="cov0" title="0">if settings.ExecutionAgent.Prompt != nil </span><span class="cov0" title="0">{
                                environment["EXECUTION_AGENT_PROMPT"] = *settings.ExecutionAgent.Prompt
                        }</span>
                }
                <span class="cov8" title="1">environment["ENTRYPOINT_VERSION"] = "${ENTRYPOINT_VERSION:-latest}"
                environment["MAX_RETRIES"] = "${MAX_RETRIES:-100}"
                environment["DEBUG"] = "${DEBUG:-false}"

                // Auto-inject GitHub MCP server for all agents and add any configured MCP servers
                finalMCPServers := make(map[string]config.MCPServer)

                // Add configured MCP servers
                for name, server := range settings.MCPServers </span><span class="cov0" title="0">{
                        finalMCPServers[name] = server
                }</span>

                // Add MCP servers configuration to environment
                <span class="cov8" title="1">if len(finalMCPServers) &gt; 0 </span><span class="cov0" title="0">{
                        mcpServersJSON, err := json.Marshal(finalMCPServers)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to marshal MCP servers for agent %s: %w", agent.Name, err)
                        }</span>
                        <span class="cov0" title="0">environment["MCP_SERVERS"] = string(mcpServersJSON)</span>
                }

                // Merge with environment from service config
                <span class="cov8" title="1">if existingEnv, ok := serviceConfig["environment"]; ok </span><span class="cov0" title="0">{
                        // Handle both map[string]string and map[string]interface{} cases
                        if envMap, ok := existingEnv.(map[string]string); ok </span><span class="cov0" title="0">{
                                for k, v := range envMap </span><span class="cov0" title="0">{
                                        environment[k] = v
                                }</span>
                        } else<span class="cov0" title="0"> if envMapInterface, ok := existingEnv.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                for k, v := range envMapInterface </span><span class="cov0" title="0">{
                                        if vStr, ok := v.(string); ok </span><span class="cov0" title="0">{
                                                environment[k] = vStr
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">serviceConfig["environment"] = environment

                // Set default entrypoint if not specified
                if _, hasEntrypoint := serviceConfig["entrypoint"]; !hasEntrypoint </span><span class="cov8" title="1">{
                        serviceConfig["entrypoint"] = []string{"/opt/autoteam/bin/entrypoint.sh"}
                }</span>

                <span class="cov8" title="1">compose.Services[serviceName] = serviceConfig</span>
        }

        // Add custom services from configuration
        <span class="cov8" title="1">if cfg.Services != nil </span><span class="cov0" title="0">{
                for serviceName, serviceConfig := range cfg.Services </span><span class="cov0" title="0">{
                        // Check for conflicts with agent services
                        if _, exists := compose.Services[serviceName]; exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("custom service '%s' conflicts with generated agent service - please choose a different name", serviceName)
                        }</span>

                        // Add custom service directly to compose
                        <span class="cov0" title="0">compose.Services[serviceName] = serviceConfig</span>
                }
        }

        // Marshal to YAML
        <span class="cov8" title="1">yamlData, err := yaml.Marshal(&amp;compose)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal compose config to YAML: %w", err)
        }</span>

        // Write to file
        <span class="cov8" title="1">if err := os.WriteFile(config.ComposeFilePath, yamlData, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write compose.yaml file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (g *Generator) copyBinDirectory() error <span class="cov8" title="1">{
        // Ensure agents directory exists
        if err := g.fileOps.EnsureDirectory(config.AgentsDir, config.DirPerm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create agents directory: %w", err)
        }</span>

        // Remove existing directory if it exists
        <span class="cov8" title="1">if err := g.fileOps.RemoveIfExists(config.LocalBinPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove existing bin directory: %w", err)
        }</span>

        // Check if system bin directory exists
        <span class="cov8" title="1">sourceDir := config.SystemBinDir
        if !g.fileOps.DirectoryExists(config.SystemBinDir) </span><span class="cov0" title="0">{
                // Fallback: check for old entrypoints directory for backward compatibility
                oldEntrypointsDir := "/opt/autoteam/entrypoints"
                if g.fileOps.DirectoryExists(oldEntrypointsDir) </span><span class="cov0" title="0">{
                        sourceDir = oldEntrypointsDir
                }</span> else<span class="cov0" title="0"> {
                        // Neither directory exists - create a temporary directory with a helpful message
                        if err := g.fileOps.EnsureDirectory(config.LocalBinPath, config.DirPerm); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create temporary bin directory: %w", err)
                        }</span>

                        <span class="cov0" title="0">readmePath := filepath.Join(config.LocalBinPath, config.ReadmeFile)
                        readmeContent := `# AutoTeam Binary Directory

This directory should contain all AutoTeam binaries including:
- Entrypoint scripts for different platforms
- MCP servers (github-mcp-server, etc.)
- Other runtime binaries

To install the binaries system-wide, run:
` + "```bash" + `
autoteam --install-entrypoints
` + "```" + `

This will:
1. Install all binaries for supported platforms to ` + config.SystemBinDir + `
2. Copy the binaries to this local directory during generation

Supported platforms:
- linux-amd64
- linux-arm64  
- darwin-amd64
- darwin-arm64
`

                        if err := g.fileOps.WriteFileIfNotExists(readmePath, []byte(readmeContent), config.ReadmePerm); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create README file: %w", err)
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                }
        }

        // Copy system bin directory (or fallback entrypoints directory) to local directory
        <span class="cov8" title="1">return g.fileOps.CopyDirectory(sourceDir, config.LocalBinPath)</span>
}

func (g *Generator) createAgentDirectories(cfg *config.Config) error <span class="cov8" title="1">{
        for _, agent := range cfg.Agents </span><span class="cov8" title="1">{
                // Skip disabled agents
                if !agent.IsEnabled() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">normalizedName := agent.GetNormalizedName()
                if err := g.fileOps.CreateAgentDirectoryStructure(normalizedName); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory structure for agent %s (normalized: %s): %w", agent.Name, normalizedName, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package generator

import (
        "strings"
        "text/template"
)

// GetTemplateFunctions returns the template functions map for use in templates
func GetTemplateFunctions() template.FuncMap <span class="cov0" title="0">{
        return template.FuncMap{
                "indent":              indentFunction,
                "escapeDockerCompose": escapeDockerComposeFunction,
                "join":                joinFunction,
        }
}</span>

// indentFunction indents each line of text by the specified number of spaces
func indentFunction(spaces int, text string) string <span class="cov0" title="0">{
        if text == "" </span><span class="cov0" title="0">{
                return text
        }</span>

        // Create the indentation string
        <span class="cov0" title="0">indentation := strings.Repeat(" ", spaces)

        // Split text into lines and add indentation to each line
        lines := strings.Split(text, "\n")
        for i, line := range lines </span><span class="cov0" title="0">{
                if line != "" </span><span class="cov0" title="0">{ // Don't indent empty lines
                        lines[i] = indentation + line
                }</span>
        }

        <span class="cov0" title="0">return strings.Join(lines, "\n")</span>
}

// escapeDockerComposeFunction escapes single $ with $$ for Docker Compose
// This prevents Docker Compose from trying to substitute shell variables
func escapeDockerComposeFunction(text string) string <span class="cov0" title="0">{
        return strings.ReplaceAll(text, "$", "$$")
}</span>

// joinFunction joins a slice of strings with a separator
func joinFunction(slice []string, separator string) string <span class="cov0" title="0">{
        return strings.Join(slice, separator)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package logger

import (
        "context"
        "fmt"
        "strings"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// LogLevel represents the logging level
type LogLevel string

const (
        DebugLevel LogLevel = "debug"
        InfoLevel  LogLevel = "info"
        WarnLevel  LogLevel = "warn"
        ErrorLevel LogLevel = "error"
)

// ParseLogLevel parses a string into a LogLevel
func ParseLogLevel(level string) (LogLevel, error) <span class="cov0" title="0">{
        switch strings.ToLower(level) </span>{
        case "debug":<span class="cov0" title="0">
                return DebugLevel, nil</span>
        case "info":<span class="cov0" title="0">
                return InfoLevel, nil</span>
        case "warn", "warning":<span class="cov0" title="0">
                return WarnLevel, nil</span>
        case "error":<span class="cov0" title="0">
                return ErrorLevel, nil</span>
        default:<span class="cov0" title="0">
                return InfoLevel, fmt.Errorf("invalid log level: %s", level)</span>
        }
}

// zapLevel converts LogLevel to zapcore.Level
func (l LogLevel) zapLevel() zapcore.Level <span class="cov0" title="0">{
        switch l </span>{
        case DebugLevel:<span class="cov0" title="0">
                return zapcore.DebugLevel</span>
        case InfoLevel:<span class="cov0" title="0">
                return zapcore.InfoLevel</span>
        case WarnLevel:<span class="cov0" title="0">
                return zapcore.WarnLevel</span>
        case ErrorLevel:<span class="cov0" title="0">
                return zapcore.ErrorLevel</span>
        default:<span class="cov0" title="0">
                return zapcore.InfoLevel</span>
        }
}

type contextKey struct{}

var loggerKey = contextKey{}

// NewLogger creates a new zap logger with the specified level
func NewLogger(level LogLevel) (*zap.Logger, error) <span class="cov0" title="0">{
        config := zap.NewProductionConfig()
        config.Level = zap.NewAtomicLevelAt(level.zapLevel())
        config.EncoderConfig.TimeKey = "timestamp"
        config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        config.EncoderConfig.CallerKey = "caller"
        config.EncoderConfig.EncodeCaller = zapcore.ShortCallerEncoder

        // Use console encoder for better readability
        config.Encoding = "console"
        config.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
        config.DisableStacktrace = true // Reduce noise

        return config.Build(zap.AddCallerSkip(1))
}</span>

// WithLogger adds a logger to the context
func WithLogger(ctx context.Context, logger *zap.Logger) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, loggerKey, logger)
}</span>

// FromContext retrieves the logger from the context
// If no logger is found, it creates a default info-level logger
func FromContext(ctx context.Context) *zap.Logger <span class="cov0" title="0">{
        if logger, ok := ctx.Value(loggerKey).(*zap.Logger); ok </span><span class="cov0" title="0">{
                return logger
        }</span>

        // Fallback to default logger
        <span class="cov0" title="0">logger, err := NewLogger(InfoLevel)
        if err != nil </span><span class="cov0" title="0">{
                // Last resort - use no-op logger
                return zap.NewNop()
        }</span>
        <span class="cov0" title="0">return logger</span>
}

// SetupContext creates a context with a logger configured at the specified level
func SetupContext(ctx context.Context, level LogLevel) (context.Context, error) <span class="cov0" title="0">{
        logger, err := NewLogger(level)
        if err != nil </span><span class="cov0" title="0">{
                return ctx, fmt.Errorf("failed to create logger: %w", err)
        }</span>

        <span class="cov0" title="0">return WithLogger(ctx, logger), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package monitor

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "autoteam/internal/agent"
        "autoteam/internal/config"
        "autoteam/internal/entrypoint"
        "autoteam/internal/logger"
        "autoteam/internal/task"

        "go.uber.org/zap"
)

// Config contains configuration for the two-layer monitor
type Config struct {
        CheckInterval time.Duration
        TeamName      string
}

// Monitor handles the two-layer agent monitoring loop
type Monitor struct {
        taskCollectionAgent agent.Agent // First Layer - uses AggregationAgent config
        taskExecutionAgent  agent.Agent // Second Layer - uses Agent config
        config              Config
        globalConfig        *entrypoint.Config
        firstLayerConfig    *config.AgentConfig // First Layer configuration with custom prompt
        secondLayerConfig   *config.AgentConfig // Second Layer configuration with custom prompt
        taskService         *task.Service       // Service for task persistence operations
}

// New creates a new two-layer monitor instance
func New(collectionAgent, executionAgent agent.Agent, monitorConfig Config, globalConfig *entrypoint.Config) *Monitor <span class="cov0" title="0">{
        // Get agent directory for task service
        agentNormalizedName := strings.ToLower(strings.ReplaceAll(globalConfig.Agent.Name, " ", "_"))
        agentDirectory := fmt.Sprintf("/opt/autoteam/agents/%s", agentNormalizedName)

        return &amp;Monitor{
                taskCollectionAgent: collectionAgent,
                taskExecutionAgent:  executionAgent,
                config:              monitorConfig,
                globalConfig:        globalConfig,
                firstLayerConfig:    nil, // Will be set via SetLayerConfigs if custom prompts are configured
                secondLayerConfig:   nil, // Will be set via SetLayerConfigs if custom prompts are configured
                taskService:         task.NewService(agentDirectory),
        }
}</span>

// SetLayerConfigs sets the layer configurations for custom prompt support
func (m *Monitor) SetLayerConfigs(firstLayer, secondLayer *config.AgentConfig) <span class="cov0" title="0">{
        m.firstLayerConfig = firstLayer
        m.secondLayerConfig = secondLayer
}</span>

// Start starts the two-layer agent processing loop
func (m *Monitor) Start(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)
        lgr.Info("Starting two-layer agent monitor",
                zap.Duration("check_interval", m.config.CheckInterval),
                zap.String("collection_agent", m.taskCollectionAgent.Type()),
                zap.String("execution_agent", m.taskExecutionAgent.Type()))

        // Repository access handled via MCP servers

        lgr.Info("Starting two-layer processing loop: task collection -&gt; task execution")

        // Configure agents if they support configuration
        if err := m.configureAgents(ctx); err != nil </span><span class="cov0" title="0">{
                lgr.Warn("Failed to configure agents", zap.Error(err))
        }</span>

        // Start continuous two-layer processing loop
        <span class="cov0" title="0">ticker := time.NewTicker(m.config.CheckInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        lgr.Info("Monitor shutting down due to context cancellation")
                        return ctx.Err()</span>

                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Execute two-layer processing cycle
                        if err := m.processTwoLayerCycle(ctx); err != nil </span><span class="cov0" title="0">{
                                lgr.Warn("Failed to process two-layer cycle", zap.Error(err))
                        }</span>
                }
        }
}

// processTwoLayerCycle executes one cycle of the two-layer architecture
func (m *Monitor) processTwoLayerCycle(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)
        lgr.Debug("Starting two-layer processing cycle")

        // Layer 1: Collect tasks using aggregation agent
        tasks, err := m.collectTasksWithAggregationAgent(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("task collection failed: %w", err)
        }</span>

        <span class="cov0" title="0">if tasks.IsEmpty() </span><span class="cov0" title="0">{
                lgr.Debug("No tasks found by aggregation agent")
                return nil
        }</span>

        <span class="cov0" title="0">lgr.Info("Tasks collected by aggregation agent",
                zap.Int("task_count", tasks.Count()),
                zap.String("agent_type", m.taskCollectionAgent.Type()))

        // Layer 2: Execute highest priority task using execution agent
        return m.executeHighestPriorityTask(ctx, tasks)</span>
}

// collectTasksWithAggregationAgent uses the first layer agent to collect tasks
func (m *Monitor) collectTasksWithAggregationAgent(ctx context.Context) (*task.TaskList, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)
        lgr.Debug("Collecting tasks with aggregation agent", zap.String("agent_type", m.taskCollectionAgent.Type()))

        // Use custom prompt if configured, otherwise fallback to default first layer prompt
        var basePrompt string
        if m.firstLayerConfig != nil &amp;&amp; m.firstLayerConfig.Prompt != nil </span><span class="cov0" title="0">{
                basePrompt = *m.firstLayerConfig.Prompt
                lgr.Debug("Using custom first layer prompt from configuration")
        }</span> else<span class="cov0" title="0"> {
                basePrompt = task.FirstLayerPrompt
                lgr.Debug("Using default first layer prompt")
        }</span>

        // Add TODO_LIST format instruction to the prompt
        <span class="cov0" title="0">prompt := basePrompt + `

Return list of tasks in this exact format:

TODO_LIST: ["task text", "task text", ...]

IMPORTANT: 
- Use exactly "TODO_LIST: " followed by a JSON array
- If no tasks found, return: TODO_LIST: []
- Include the TODO_LIST format in your response regardless of other output`

        // Setup run options for task collection
        // Use agent-specific collector directory for first layer
        workingDirectory := m.getLayerWorkingDirectory("collector")

        runOptions := agent.RunOptions{
                MaxRetries:       1,
                ContinueMode:     false,
                WorkingDirectory: workingDirectory,
        }

        // Define file paths - tasks.json in common agent directory, output.txt in layer-specific directory
        outputFilePath := fmt.Sprintf("%s/output.txt", workingDirectory)

        // Log the working directory for debugging
        lgr.Info("Executing task collection with aggregation agent",
                zap.String("working_directory", workingDirectory),
                zap.String("agent_type", m.taskCollectionAgent.Type()))

        // Execute aggregation agent and capture stdout
        output, err := m.taskCollectionAgent.Run(ctx, prompt, runOptions)

        // Always save the stdout to output.txt for debugging (even on failure)
        if output != nil </span><span class="cov0" title="0">{
                if saveErr := m.saveAgentOutput(ctx, outputFilePath, output.Stdout, output.Stderr); saveErr != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Failed to save agent output", zap.Error(saveErr))
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                lgr.Error("Task collection agent failed", zap.Error(err))
                // Do not create empty tasks.json - preserve existing tasks
                return nil, fmt.Errorf("aggregation agent execution failed: %w", err)
        }</span>

        // Parse tasks from agent stdout
        <span class="cov0" title="0">newTasksJSON, err := task.ParseTasksFromStdout(output.Stdout)
        if err != nil </span><span class="cov0" title="0">{
                lgr.Error("Failed to parse tasks from stdout",
                        zap.Error(err),
                        zap.String("stdout", output.Stdout))

                // Do not create empty tasks.json - preserve existing tasks
                // Return empty task list to continue processing without losing existing data
                return task.CreateEmptyTaskList(), nil
        }</span>

        // Use task service to merge and save tasks
        <span class="cov0" title="0">mergedTasksJSON, err := m.taskService.AddNewTasksAndSave(ctx, newTasksJSON)
        if err != nil </span><span class="cov0" title="0">{
                lgr.Warn("Failed to merge and save tasks", zap.Error(err))
                mergedTasksJSON = newTasksJSON
        }</span>

        // Convert TasksJSON to TaskList for compatibility with existing code
        <span class="cov0" title="0">taskList := m.taskService.ConvertToTaskList(mergedTasksJSON)

        lgr.Info("Task collection completed successfully",
                zap.String("agent_type", m.taskCollectionAgent.Type()),
                zap.Int("tasks_count", taskList.Count()),
                zap.Int("todo_count", mergedTasksJSON.TodoCount()),
                zap.Int("done_count", mergedTasksJSON.DoneCount()),
                zap.Int("new_tasks_added", newTasksJSON.TodoCount()),
                zap.String("tasks_file", m.taskService.GetTasksPath()),
                zap.String("stdout_preview", truncateString(output.Stdout, 200)))

        return taskList, nil</span>
}

// createEmptyTasksJSON creates an empty tasks.json file
func (m *Monitor) createEmptyTasksJSON(ctx context.Context, filePath string) error <span class="cov0" title="0">{
        emptyTasks := task.NewTasksJSON()
        return m.saveTasksJSON(ctx, filePath, emptyTasks)
}</span>

// saveTasksJSON saves TasksJSON to a JSON file
func (m *Monitor) saveTasksJSON(ctx context.Context, filePath string, tasksJSON *task.TasksJSON) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Ensure directory exists
        if err := os.MkdirAll(filepath.Dir(filePath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Marshal to JSON with indentation for readability
        <span class="cov0" title="0">data, err := json.MarshalIndent(tasksJSON, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal tasks JSON: %w", err)
        }</span>

        // Write to file
        <span class="cov0" title="0">if err := os.WriteFile(filePath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write tasks JSON file: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Debug("Tasks JSON file saved successfully",
                zap.String("path", filePath),
                zap.Int("todo_count", len(tasksJSON.Todo)),
                zap.Int("done_count", len(tasksJSON.Done)))

        return nil</span>
}

// saveAgentOutput saves agent stdout and stderr to a file for debugging
func (m *Monitor) saveAgentOutput(ctx context.Context, filePath, stdout, stderr string) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Ensure directory exists
        if err := os.MkdirAll(filepath.Dir(filePath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Create output content with timestamp and sections
        <span class="cov0" title="0">timestamp := time.Now().Format("2006-01-02 15:04:05")
        content := fmt.Sprintf("=== Agent Output - %s ===\n\n", timestamp)

        // Add stdout section
        content += "=== STDOUT ===\n"
        if stdout != "" </span><span class="cov0" title="0">{
                content += stdout
        }</span> else<span class="cov0" title="0"> {
                content += "(empty)\n"
        }</span>
        <span class="cov0" title="0">content += "\n\n"

        // Add stderr section
        content += "=== STDERR ===\n"
        if stderr != "" </span><span class="cov0" title="0">{
                content += stderr
        }</span> else<span class="cov0" title="0"> {
                content += "(empty)\n"
        }</span>
        <span class="cov0" title="0">content += "\n"

        // Write to file
        if err := os.WriteFile(filePath, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write agent output file: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Debug("Agent output saved successfully",
                zap.String("path", filePath),
                zap.Int("stdout_length", len(stdout)),
                zap.Int("stderr_length", len(stderr)))

        return nil</span>
}

// truncateString truncates a string to maxLength with "..." suffix if needed
func truncateString(s string, maxLength int) string <span class="cov0" title="0">{
        if len(s) &lt;= maxLength </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov0" title="0">return s[:maxLength-3] + "..."</span>
}

// executeHighestPriorityTask uses the second layer agent to execute a task
func (m *Monitor) executeHighestPriorityTask(ctx context.Context, tasks *task.TaskList) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Get the highest priority task
        highestPriorityTask := tasks.GetHighestPriorityTask()
        if highestPriorityTask == nil </span><span class="cov0" title="0">{
                lgr.Debug("No tasks to execute")
                return nil
        }</span>

        <span class="cov0" title="0">lgr.Info("Executing task with execution agent",
                zap.String("task_id", highestPriorityTask.ID),
                zap.String("task_type", highestPriorityTask.Type),
                zap.Int("priority", highestPriorityTask.Priority),
                zap.String("agent_type", m.taskExecutionAgent.Type()))

        // Repository operations handled via MCP servers
        // Use custom prompt if configured, otherwise fallback to building task-specific prompt
        var prompt string
        if m.secondLayerConfig != nil &amp;&amp; m.secondLayerConfig.Prompt != nil </span><span class="cov0" title="0">{
                // Use custom second layer prompt with task description appended
                prompt = *m.secondLayerConfig.Prompt + "\n\n## Task Description\n" + highestPriorityTask.Description
                lgr.Debug("Using custom second layer prompt from configuration")
        }</span> else<span class="cov0" title="0"> {
                // Build task-specific prompt for execution using the task description
                prompt = task.BuildSecondLayerPrompt(highestPriorityTask.Description)
                lgr.Debug("Using default second layer prompt")
        }</span>

        // Get working directory for execution agent (second layer)
        <span class="cov0" title="0">workingDir := m.getLayerWorkingDirectory("executor")

        // Setup run options for task execution with streaming logs
        runOptions := agent.RunOptions{
                MaxRetries:       3, // More retries for execution
                ContinueMode:     false,
                WorkingDirectory: workingDir,
        }

        // Define output file path in the executor directory (backward compatibility)
        executorOutputPath := fmt.Sprintf("%s/output.txt", workingDir)

        // Log the working directory for debugging
        lgr.Info("Executing task with execution agent",
                zap.String("working_directory", workingDir),
                zap.String("agent_type", m.taskExecutionAgent.Type()))

        // Execute the task with the execution agent using streaming logs
        output, err := m.executeWithStreamingLogs(ctx, prompt, runOptions, highestPriorityTask.Description)

        // Always save the stdout to output.txt for debugging (even on failure) - backward compatibility
        if output != nil </span><span class="cov0" title="0">{
                if saveErr := m.saveAgentOutput(ctx, executorOutputPath, output.Stdout, output.Stderr); saveErr != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Failed to save executor agent output", zap.Error(saveErr))
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                lgr.Error("Task execution agent failed",
                        zap.String("task_id", highestPriorityTask.ID),
                        zap.String("task_type", highestPriorityTask.Type),
                        zap.Error(err))
                return fmt.Errorf("execution agent failed for task %s: %w", highestPriorityTask.ID, err)
        }</span>

        <span class="cov0" title="0">lgr.Info("Task executed successfully",
                zap.String("task_id", highestPriorityTask.ID),
                zap.String("task_type", highestPriorityTask.Type),
                zap.String("agent_type", m.taskExecutionAgent.Type()))

        // Mark task as completed using task service
        if err := m.taskService.MarkTaskCompleted(ctx, highestPriorityTask.Description); err != nil </span><span class="cov0" title="0">{
                lgr.Warn("Failed to mark task as completed in tasks.json",
                        zap.Error(err),
                        zap.String("task_description", highestPriorityTask.Description))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// configureAgents configures both agents if they support configuration
func (m *Monitor) configureAgents(ctx context.Context) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Configure task collection agent
        if configurable, ok := m.taskCollectionAgent.(agent.Configurable); ok </span><span class="cov0" title="0">{
                lgr.Debug("Configuring task collection agent", zap.String("agent_type", m.taskCollectionAgent.Type()))
                if err := configurable.Configure(ctx); err != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Failed to configure task collection agent", zap.Error(err))
                }</span>
        }

        // Configure task execution agent
        <span class="cov0" title="0">if configurable, ok := m.taskExecutionAgent.(agent.Configurable); ok </span><span class="cov0" title="0">{
                lgr.Debug("Configuring task execution agent", zap.String("agent_type", m.taskExecutionAgent.Type()))
                if err := configurable.Configure(ctx); err != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Failed to configure task execution agent", zap.Error(err))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// mergeWithExistingTasks loads existing tasks.json and merges with new tasks
// This preserves the todo and done state across collection cycles
func (m *Monitor) mergeWithExistingTasks(ctx context.Context, tasksJSONPath string, newTasksJSON *task.TasksJSON) (*task.TasksJSON, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Try to load existing tasks.json file
        existingData, err := os.ReadFile(tasksJSONPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        lgr.Debug("No existing tasks.json file, using new tasks only")
                        return newTasksJSON, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to read existing tasks.json: %w", err)</span>
        }

        // Parse existing tasks
        <span class="cov0" title="0">existingTasksJSON, err := task.LoadTasksJSON(existingData)
        if err != nil </span><span class="cov0" title="0">{
                lgr.Warn("Failed to parse existing tasks.json, using new tasks only", zap.Error(err))
                return newTasksJSON, nil
        }</span>

        <span class="cov0" title="0">lgr.Debug("Merging tasks",
                zap.Int("existing_todo", existingTasksJSON.TodoCount()),
                zap.Int("existing_done", existingTasksJSON.DoneCount()),
                zap.Int("new_todo", newTasksJSON.TodoCount()))

        // Create merged tasks starting with existing tasks
        mergedTasks := task.NewTasksJSON()

        // Preserve existing todo items
        for _, existingTodo := range existingTasksJSON.Todo </span><span class="cov0" title="0">{
                mergedTasks.AddTodoTask(existingTodo)
        }</span>

        // Preserve existing done items
        <span class="cov0" title="0">for _, existingDone := range existingTasksJSON.Done </span><span class="cov0" title="0">{
                mergedTasks.AddDoneTask(existingDone)
        }</span>

        // Add new todo items (avoid duplicates)
        <span class="cov0" title="0">for _, newTodo := range newTasksJSON.Todo </span><span class="cov0" title="0">{
                if !mergedTasks.ContainsTodoTask(newTodo) </span><span class="cov0" title="0">{
                        mergedTasks.AddTodoTask(newTodo)
                }</span>
        }

        <span class="cov0" title="0">lgr.Info("Tasks merged successfully",
                zap.Int("final_todo_count", mergedTasks.TodoCount()),
                zap.Int("final_done_count", mergedTasks.DoneCount()),
                zap.Int("tasks_added", newTasksJSON.TodoCount()))

        return mergedTasks, nil</span>
}

// markTaskAsCompleted moves a task from todo to done in the shared tasks.json file
func (m *Monitor) markTaskAsCompleted(ctx context.Context, taskDescription string) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Get the shared tasks.json path
        agentDirectory := m.getAgentWorkingDirectory()
        tasksJSONPath := fmt.Sprintf("%s/tasks.json", agentDirectory)

        // Load existing tasks.json
        existingData, err := os.ReadFile(tasksJSONPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        lgr.Debug("No tasks.json file exists, nothing to mark as completed")
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to read tasks.json: %w", err)</span>
        }

        // Parse existing tasks
        <span class="cov0" title="0">tasksJSON, err := task.LoadTasksJSON(existingData)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse tasks.json: %w", err)
        }</span>

        // Check if task exists in todo list
        <span class="cov0" title="0">if !tasksJSON.ContainsTodoTask(taskDescription) </span><span class="cov0" title="0">{
                lgr.Debug("Task not found in todo list, may have been already completed",
                        zap.String("task_description", taskDescription))
                return nil
        }</span>

        // Move task from todo to done
        <span class="cov0" title="0">tasksJSON.MoveToDone(taskDescription)

        // Save updated tasks.json
        if err := m.saveTasksJSON(ctx, tasksJSONPath, tasksJSON); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save updated tasks.json: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Info("Task marked as completed",
                zap.String("task_description", taskDescription),
                zap.Int("remaining_todo_count", tasksJSON.TodoCount()),
                zap.Int("done_count", tasksJSON.DoneCount()))

        return nil</span>
}

// getAgentWorkingDirectory returns the common agent working directory
func (m *Monitor) getAgentWorkingDirectory() string <span class="cov0" title="0">{
        // Normalize agent name consistently using the same logic as config.Agent.GetNormalizedName()
        agentNormalizedName := strings.ToLower(strings.ReplaceAll(m.globalConfig.Agent.Name, " ", "_"))
        return fmt.Sprintf("/opt/autoteam/agents/%s", agentNormalizedName)
}</span>

// getLayerWorkingDirectory returns the layer-specific working directory
func (m *Monitor) getLayerWorkingDirectory(layer string) string <span class="cov0" title="0">{
        // Normalize agent name consistently using the same logic as config.Agent.GetNormalizedName()
        agentNormalizedName := strings.ToLower(strings.ReplaceAll(m.globalConfig.Agent.Name, " ", "_"))
        return fmt.Sprintf("/opt/autoteam/agents/%s/%s", agentNormalizedName, layer)
}</span>

// executeWithStreamingLogs executes the agent with streaming logs to a task-specific file
func (m *Monitor) executeWithStreamingLogs(ctx context.Context, prompt string, runOptions agent.RunOptions, taskDescription string) (*agent.AgentOutput, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Create streaming logger for the executor working directory
        streamingLogger := task.NewStreamingLogger(runOptions.WorkingDirectory)

        // Create log file for this task
        logFile, err := streamingLogger.CreateLogFile(ctx, taskDescription)
        if err != nil </span><span class="cov0" title="0">{
                lgr.Warn("Failed to create streaming log file, proceeding without streaming logs", zap.Error(err))
                // Fall back to regular execution without streaming logs
                return m.taskExecutionAgent.Run(ctx, prompt, runOptions)
        }</span>
        <span class="cov0" title="0">defer logFile.Close()

        lgr.Info("Created streaming log file for task",
                zap.String("task_description", taskDescription),
                zap.String("normalized_name", task.NormalizeTaskText(taskDescription)),
                zap.String("log_file", logFile.Name()))

        // Note: The current agent interface doesn't support streaming output redirection
        // For now, we'll execute the agent normally and then write the output to the log file
        // This maintains backward compatibility while adding the streaming log functionality

        // Execute the agent normally
        output, err := m.taskExecutionAgent.Run(ctx, prompt, runOptions)

        // Stream the output to the log file immediately after execution
        if output != nil </span><span class="cov0" title="0">{
                // Write stdout section
                if _, writeErr := logFile.WriteString("=== AGENT STDOUT ===\n"); writeErr != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Failed to write to streaming log file", zap.Error(writeErr))
                }</span>
                <span class="cov0" title="0">if output.Stdout != "" </span><span class="cov0" title="0">{
                        if _, writeErr := logFile.WriteString(output.Stdout); writeErr != nil </span><span class="cov0" title="0">{
                                lgr.Warn("Failed to write stdout to streaming log file", zap.Error(writeErr))
                        }</span>
                } else<span class="cov0" title="0"> {
                        if _, writeErr := logFile.WriteString("(empty)\n"); writeErr != nil </span><span class="cov0" title="0">{
                                lgr.Warn("Failed to write stdout to streaming log file", zap.Error(writeErr))
                        }</span>
                }
                <span class="cov0" title="0">if _, writeErr := logFile.WriteString("\n\n"); writeErr != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Failed to write to streaming log file", zap.Error(writeErr))
                }</span>

                // Write stderr section
                <span class="cov0" title="0">if _, writeErr := logFile.WriteString("=== AGENT STDERR ===\n"); writeErr != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Failed to write to streaming log file", zap.Error(writeErr))
                }</span>
                <span class="cov0" title="0">if output.Stderr != "" </span><span class="cov0" title="0">{
                        if _, writeErr := logFile.WriteString(output.Stderr); writeErr != nil </span><span class="cov0" title="0">{
                                lgr.Warn("Failed to write stderr to streaming log file", zap.Error(writeErr))
                        }</span>
                } else<span class="cov0" title="0"> {
                        if _, writeErr := logFile.WriteString("(empty)\n"); writeErr != nil </span><span class="cov0" title="0">{
                                lgr.Warn("Failed to write stderr to streaming log file", zap.Error(writeErr))
                        }</span>
                }
                <span class="cov0" title="0">if _, writeErr := logFile.WriteString("\n"); writeErr != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Failed to write to streaming log file", zap.Error(writeErr))
                }</span>

                // Write completion timestamp
                <span class="cov0" title="0">completionTime := time.Now().Format("2006-01-02 15:04:05")
                if _, writeErr := logFile.WriteString(fmt.Sprintf("=== Task Completed - %s ===\n", completionTime)); writeErr != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Failed to write completion timestamp to streaming log file", zap.Error(writeErr))
                }</span>

                <span class="cov0" title="0">lgr.Info("Successfully wrote agent output to streaming log file",
                        zap.String("log_file", logFile.Name()),
                        zap.Int("stdout_length", len(output.Stdout)),
                        zap.Int("stderr_length", len(output.Stderr)))</span>
        }

        <span class="cov0" title="0">return output, err</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package task

import (
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "autoteam/internal/logger"

        "go.uber.org/zap"
)

// StreamingLogger handles streaming logs to separate files per task
type StreamingLogger struct {
        logDir string
}

// NewStreamingLogger creates a new streaming logger for the given directory
func NewStreamingLogger(workingDir string) *StreamingLogger <span class="cov0" title="0">{
        logDir := filepath.Join(workingDir, "logs")
        return &amp;StreamingLogger{
                logDir: logDir,
        }
}</span>

// NormalizeTaskText normalizes a task description for use as a filename
// Format: "{Notification ID} - {NOTIFICATION URL} - {NOTIFICATION TEXT}"
func NormalizeTaskText(taskDescription string) string <span class="cov0" title="0">{
        // Extract the notification text part (everything after the second " - ")
        parts := strings.Split(taskDescription, " - ")
        var notificationText string
        if len(parts) &gt;= 3 </span><span class="cov0" title="0">{
                notificationText = strings.Join(parts[2:], " - ")
        }</span> else<span class="cov0" title="0"> {
                notificationText = taskDescription
        }</span>

        // Replace invalid filename characters with underscores
        <span class="cov0" title="0">reg := regexp.MustCompile(`[^\w\-_\s\.]+`)
        normalized := reg.ReplaceAllString(notificationText, "_")

        // Replace spaces with underscores and collapse multiple underscores
        normalized = strings.ReplaceAll(normalized, " ", "_")
        normalized = regexp.MustCompile(`_+`).ReplaceAllString(normalized, "_")

        // Convert to lowercase
        normalized = strings.ToLower(normalized)

        // Trim underscores from start and end
        normalized = strings.Trim(normalized, "_")

        // Limit length to 100 characters to avoid filesystem issues
        if len(normalized) &gt; 100 </span><span class="cov0" title="0">{
                normalized = normalized[:100]
                // Trim trailing underscore if truncated
                normalized = strings.TrimRight(normalized, "_")
        }</span>

        // Ensure it's not empty
        <span class="cov0" title="0">if normalized == "" </span><span class="cov0" title="0">{
                normalized = "unknown_task"
        }</span>

        <span class="cov0" title="0">return normalized</span>
}

// CreateLogFile creates a log file for the given task and returns a file writer
func (sl *StreamingLogger) CreateLogFile(ctx context.Context, taskDescription string) (*os.File, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Ensure logs directory exists
        if err := os.MkdirAll(sl.logDir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create logs directory: %w", err)
        }</span>

        // Normalize task text for filename and add timestamp
        <span class="cov0" title="0">normalizedName := NormalizeTaskText(taskDescription)
        timestamp := time.Now().Format("20060102-150405") // YYYYMMDD-HHMMSS format
        logFileName := fmt.Sprintf("%s-%s.log", timestamp, normalizedName)
        logFilePath := filepath.Join(sl.logDir, logFileName)

        lgr.Info("Creating log file for task",
                zap.String("task_description", taskDescription),
                zap.String("normalized_name", normalizedName),
                zap.String("timestamp", timestamp),
                zap.String("log_file", logFilePath))

        // Create/open the log file for appending
        file, err := os.OpenFile(logFilePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create log file: %w", err)
        }</span>

        // Write header with timestamp
        <span class="cov0" title="0">header := fmt.Sprintf("=== Task Execution Log - %s ===\nTask: %s\n\n",
                getCurrentTimestamp(), taskDescription)
        if _, err := file.WriteString(header); err != nil </span><span class="cov0" title="0">{
                file.Close()
                return nil, fmt.Errorf("failed to write log header: %w", err)
        }</span>

        <span class="cov0" title="0">return file, nil</span>
}

// getCurrentTimestamp returns current timestamp in a readable format
func getCurrentTimestamp() string <span class="cov0" title="0">{
        return time.Now().Format("2006-01-02 15:04:05")
}</span>

// StreamingWriter wraps an io.Writer to provide streaming functionality
type StreamingWriter struct {
        file   *os.File
        writer io.Writer
}

// NewStreamingWriter creates a new streaming writer that writes to both file and original writer
func NewStreamingWriter(file *os.File, originalWriter io.Writer) *StreamingWriter <span class="cov0" title="0">{
        return &amp;StreamingWriter{
                file:   file,
                writer: io.MultiWriter(file, originalWriter),
        }
}</span>

// Write implements io.Writer interface
func (sw *StreamingWriter) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        return sw.writer.Write(p)
}</span>

// Close closes the underlying file
func (sw *StreamingWriter) Close() error <span class="cov0" title="0">{
        if sw.file != nil </span><span class="cov0" title="0">{
                return sw.file.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package task

import (
        "encoding/json"
        "fmt"
        "regexp"
        "strings"
)

// TaskResponse represents the expected JSON response from the first layer agent
type TaskResponse struct {
        Tasks []Task `json:"tasks"`
}

// ParseTasksFromOutput parses task list from simple text output (one task per line)
func ParseTasksFromOutput(output string) (*TaskList, error) <span class="cov0" title="0">{
        taskList := NewTaskList()

        // Split output into lines
        lines := strings.Split(strings.TrimSpace(output), "\n")

        for i, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)

                // Skip empty lines
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Remove bullet points or dashes at the beginning
                <span class="cov0" title="0">line = strings.TrimPrefix(line, "- ")
                line = strings.TrimPrefix(line, "* ")
                line = strings.TrimPrefix(line, " ")
                line = strings.TrimSpace(line)

                // Skip if still empty
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Create a simple task with the line as description
                <span class="cov0" title="0">task := NewTask(
                        fmt.Sprintf("task-%d", i+1), // Simple ID
                        TaskTypeGeneric,             // Generic type
                        line,                        // Use the line as title
                        line,                        // Also use as description
                        PlatformGeneric,             // Generic platform
                        "",                          // No completion command needed
                        PriorityMedium,              // Default to medium priority
                )

                taskList.AddTask(*task)</span>
        }

        <span class="cov0" title="0">return taskList, nil</span>
}

// extractJSONFromOutput attempts to find and extract JSON from text output
func extractJSONFromOutput(output string) (string, error) <span class="cov0" title="0">{
        // First, try to find JSON wrapped in code blocks
        codeBlockRegex := regexp.MustCompile("```(?:json)?\n(.*?)\n```")
        matches := codeBlockRegex.FindStringSubmatch(output)
        if len(matches) &gt; 1 </span><span class="cov0" title="0">{
                return strings.TrimSpace(matches[1]), nil
        }</span>

        // Look for JSON object starting with { and ending with }
        <span class="cov0" title="0">jsonRegex := regexp.MustCompile(`\{.*?"tasks".*?\[.*?\].*?\}`)
        match := jsonRegex.FindString(output)
        if match != "" </span><span class="cov0" title="0">{
                return match, nil
        }</span>

        // Look for lines that might contain JSON
        <span class="cov0" title="0">lines := strings.Split(output, "\n")
        var jsonLines []string
        inJsonBlock := false

        for _, line := range lines </span><span class="cov0" title="0">{
                trimmed := strings.TrimSpace(line)

                // Start of JSON object
                if strings.HasPrefix(trimmed, "{") </span><span class="cov0" title="0">{
                        inJsonBlock = true
                        jsonLines = []string{trimmed}
                        continue</span>
                }

                // End of JSON object
                <span class="cov0" title="0">if inJsonBlock &amp;&amp; strings.HasSuffix(trimmed, "}") </span><span class="cov0" title="0">{
                        jsonLines = append(jsonLines, trimmed)
                        potentialJSON := strings.Join(jsonLines, "\n")

                        // Validate if it's proper JSON
                        var test interface{}
                        if json.Unmarshal([]byte(potentialJSON), &amp;test) == nil </span><span class="cov0" title="0">{
                                return potentialJSON, nil
                        }</span>

                        <span class="cov0" title="0">inJsonBlock = false
                        jsonLines = nil
                        continue</span>
                }

                // Middle of JSON object
                <span class="cov0" title="0">if inJsonBlock </span><span class="cov0" title="0">{
                        jsonLines = append(jsonLines, trimmed)
                }</span>
        }

        // If we still haven't found JSON, try to parse the entire output as JSON
        <span class="cov0" title="0">var test interface{}
        if json.Unmarshal([]byte(output), &amp;test) == nil </span><span class="cov0" title="0">{
                return output, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("no valid JSON found in output")</span>
}

// validateTask ensures a task has required fields
func validateTask(task Task) error <span class="cov0" title="0">{
        if task.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("task ID is required")
        }</span>
        <span class="cov0" title="0">if task.Type == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("task type is required")
        }</span>
        <span class="cov0" title="0">if task.Title == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("task title is required")
        }</span>
        <span class="cov0" title="0">if task.Description == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("task description is required")
        }</span>
        <span class="cov0" title="0">if task.Priority &lt; 1 || task.Priority &gt; 4 </span><span class="cov0" title="0">{
                return fmt.Errorf("task priority must be between 1-4, got: %d", task.Priority)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateEmptyTaskList creates an empty task list for when parsing fails
func CreateEmptyTaskList() *TaskList <span class="cov0" title="0">{
        return NewTaskList()
}</span>

// extractTodoListFromOutput extracts tasks from TODO_LIST format using regex
func extractTodoListFromOutput(output string) ([]string, error) <span class="cov0" title="0">{
        // Look for pattern: TODO_LIST: ["task1", "task2", ...]
        // Use a more robust regex that handles multiline arrays and various spacing
        todoListRegex := regexp.MustCompile(`(?i)TODO_LIST:\s*(\[(?:[^\[\]]*|"[^"]*")*\])`)
        matches := todoListRegex.FindStringSubmatch(output)

        if len(matches) &lt; 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("TODO_LIST format not found")
        }</span>

        <span class="cov0" title="0">jsonArrayStr := strings.TrimSpace(matches[1])

        // Parse the JSON array
        var tasks []string
        if err := json.Unmarshal([]byte(jsonArrayStr), &amp;tasks); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse TODO_LIST JSON array: %w", err)
        }</span>

        // Clean up the tasks (remove empty strings and trim whitespace)
        <span class="cov0" title="0">var cleanTasks []string
        for _, task := range tasks </span><span class="cov0" title="0">{
                cleanTask := strings.TrimSpace(task)
                if cleanTask != "" </span><span class="cov0" title="0">{
                        cleanTasks = append(cleanTasks, cleanTask)
                }</span>
        }

        <span class="cov0" title="0">return cleanTasks, nil</span>
}

// ParseTasksFromStdout parses agent stdout output and returns a TasksJSON structure
// First tries to extract TODO_LIST format, then falls back to line-by-line parsing
func ParseTasksFromStdout(stdout string) (*TasksJSON, error) <span class="cov0" title="0">{
        tasksJSON := NewTasksJSON()

        if stdout == "" </span><span class="cov0" title="0">{
                return tasksJSON, nil
        }</span>

        // First, try to extract TODO_LIST format using regex
        <span class="cov0" title="0">todoList, err := extractTodoListFromOutput(stdout)
        if err == nil </span><span class="cov0" title="0">{
                // Successfully extracted TODO_LIST format (even if empty)
                for _, task := range todoList </span><span class="cov0" title="0">{
                        tasksJSON.AddTodoTask(task)
                }</span>
                <span class="cov0" title="0">return tasksJSON, nil</span>
        }

        // Fallback to line-by-line parsing if TODO_LIST format not found
        <span class="cov0" title="0">lines := strings.Split(strings.TrimSpace(stdout), "\n")

        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)

                // Skip empty lines
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip lines that contain TODO_LIST pattern (they should be handled by regex above)
                <span class="cov0" title="0">if strings.Contains(strings.ToUpper(line), "TODO_LIST:") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Remove common list prefixes (numbers, bullets, dashes)
                <span class="cov0" title="0">line = cleanTaskLine(line)

                // Skip if still empty after cleaning
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Add as a todo task
                <span class="cov0" title="0">tasksJSON.AddTodoTask(line)</span>
        }

        <span class="cov0" title="0">return tasksJSON, nil</span>
}

// cleanTaskLine removes common list prefixes and cleans up the task line
func cleanTaskLine(line string) string <span class="cov0" title="0">{
        line = strings.TrimSpace(line)

        // Remove numbered list prefixes (1. 2. etc.)
        numberRegex := regexp.MustCompile(`^\d+\.\s*`)
        line = numberRegex.ReplaceAllString(line, "")

        // Remove bullet point prefixes
        line = strings.TrimPrefix(line, "- ")
        line = strings.TrimPrefix(line, "* ")
        line = strings.TrimPrefix(line, " ")
        line = strings.TrimPrefix(line, " ")
        line = strings.TrimPrefix(line, "&gt; ")

        // Remove any remaining leading whitespace
        line = strings.TrimSpace(line)

        return line
}</span>

// LoadTasksJSON loads TasksJSON from a JSON file content
func LoadTasksJSON(jsonContent []byte) (*TasksJSON, error) <span class="cov0" title="0">{
        var tasksJSON TasksJSON
        if err := json.Unmarshal(jsonContent, &amp;tasksJSON); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal tasks JSON: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;tasksJSON, nil</span>
}

// ConvertTasksJSONToTaskList converts TasksJSON to legacy TaskList format for compatibility
func ConvertTasksJSONToTaskList(tasksJSON *TasksJSON) *TaskList <span class="cov0" title="0">{
        taskList := NewTaskList()

        // Convert todo items to tasks
        for i, todoItem := range tasksJSON.Todo </span><span class="cov0" title="0">{
                task := NewTask(
                        fmt.Sprintf("todo-%d", i+1),
                        TaskTypeGeneric,
                        todoItem,
                        todoItem,
                        PlatformGeneric,
                        "",
                        PriorityMedium,
                )
                taskList.AddTask(*task)
        }</span>

        <span class="cov0" title="0">return taskList</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package task

import (
        "fmt"
)

// FirstLayerPrompt is used by the aggregation agent to collect tasks from MCP servers
const FirstLayerPrompt = `TASK: Query MCP servers and create task list

Your job is to find actionable tasks using available tools and write them to /tmp/tasks.txt

Use your available tools to check for:
- Pending items that need attention
- Tasks requiring action
- Notifications or alerts

Write results to /tmp/tasks.txt with one task per line. Create the file even if no tasks are found.

Examples:
- GitHub: 1 pending PR review for repo/name in PR #123
- GitHub: 1 assigned issue #456 in repo/name  
- Platform: 1 unread notification requiring response

Create /tmp/tasks.txt now.`

// SecondLayerPromptTemplate is used by the execution agent to handle a specific task
const SecondLayerPromptTemplate = `You are a task execution agent. Execute this specific task thoroughly and professionally.

## Task Description
%s

## Your Mission
Complete this task using available MCP servers and tools.

## Important Instructions
1. **Repository Access**: If you need to access a repository's code:
   - First check if the repository exists in the codebase directory
   - If the repository doesn't exist, clone it first using git commands
   - Then navigate to the repository directory to work with the code

2. **Execute Thoroughly**: Take all necessary actions to complete the task
3. **Use MCP Servers**: Leverage available MCP servers for platform-specific operations (GitHub, Slack, etc.)
4. **Be Professional**: Maintain high quality standards in all interactions
5. **Provide Summary**: Briefly summarize what you accomplished

## Common Task Types
- **PR Review**: Examine code changes, provide constructive feedback, approve/request changes
- **Issue Implementation**: Understand requirements, implement solution, create PR
- **Mention Response**: Read context, provide helpful response or take requested action
- **Message Response**: Respond appropriately based on message content and urgency
- **Failed Workflow**: Investigate failure, fix issues, ensure CI passes
- **Comment Response**: Read full thread, respond to questions or address feedback

Begin task execution now.`

// BuildSecondLayerPrompt creates a prompt for the execution agent
func BuildSecondLayerPrompt(taskDescription string) string <span class="cov0" title="0">{
        return fmt.Sprintf(SecondLayerPromptTemplate, taskDescription)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package task

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "autoteam/internal/logger"

        "go.uber.org/zap"
)

// Service handles all task persistence and management operations
type Service struct {
        tasksJSONPath string
}

// NewService creates a new task service instance
func NewService(agentDirectory string) *Service <span class="cov0" title="0">{
        return &amp;Service{
                tasksJSONPath: filepath.Join(agentDirectory, "tasks.json"),
        }
}</span>

// LoadTasks loads existing tasks from the tasks.json file with backup recovery
func (s *Service) LoadTasks(ctx context.Context) (*TasksJSON, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Try to load existing tasks.json file
        existingData, err := os.ReadFile(s.tasksJSONPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        lgr.Debug("No existing tasks.json file, returning empty tasks")
                        return NewTasksJSON(), nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to read tasks.json: %w", err)</span>
        }

        // Parse existing tasks
        <span class="cov0" title="0">tasksJSON, err := LoadTasksJSON(existingData)
        if err != nil </span><span class="cov0" title="0">{
                lgr.Warn("Failed to parse existing tasks.json, attempting backup recovery", zap.Error(err))

                // Try to recover from backup
                backupPath := s.tasksJSONPath + ".backup"
                if backupData, backupErr := os.ReadFile(backupPath); backupErr == nil </span><span class="cov0" title="0">{
                        if backupTasksJSON, backupParseErr := LoadTasksJSON(backupData); backupParseErr == nil </span><span class="cov0" title="0">{
                                lgr.Info("Successfully recovered tasks from backup file",
                                        zap.String("backup_path", backupPath),
                                        zap.Int("todo_count", backupTasksJSON.TodoCount()),
                                        zap.Int("done_count", backupTasksJSON.DoneCount()))

                                // Restore the backup as the main file
                                if restoreErr := s.SaveTasks(ctx, backupTasksJSON); restoreErr == nil </span><span class="cov0" title="0">{
                                        lgr.Info("Backup restored as main tasks.json file")
                                        return backupTasksJSON, nil
                                }</span> else<span class="cov0" title="0"> {
                                        lgr.Warn("Failed to restore backup file", zap.Error(restoreErr))
                                }</span>

                                <span class="cov0" title="0">return backupTasksJSON, nil</span>
                        } else<span class="cov0" title="0"> {
                                lgr.Warn("Backup file is also corrupted", zap.Error(backupParseErr))
                        }</span>
                } else<span class="cov0" title="0"> {
                        lgr.Debug("No backup file available for recovery", zap.Error(backupErr))
                }</span>

                // If both main and backup files are corrupted, return empty tasks but don't overwrite
                <span class="cov0" title="0">lgr.Error("Both main and backup tasks.json files are corrupted, returning empty tasks without overwriting existing files")
                return NewTasksJSON(), nil</span>
        }

        <span class="cov0" title="0">lgr.Debug("Tasks loaded successfully",
                zap.String("path", s.tasksJSONPath),
                zap.Int("todo_count", tasksJSON.TodoCount()),
                zap.Int("done_count", tasksJSON.DoneCount()))

        return tasksJSON, nil</span>
}

// SaveTasks saves tasks to the tasks.json file with atomic operations and backup
func (s *Service) SaveTasks(ctx context.Context, tasksJSON *TasksJSON) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Ensure directory exists
        if err := os.MkdirAll(filepath.Dir(s.tasksJSONPath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Validate input data
        <span class="cov0" title="0">if tasksJSON == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot save nil TasksJSON")
        }</span>

        // Marshal to JSON with indentation for readability
        <span class="cov0" title="0">data, err := json.MarshalIndent(tasksJSON, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal tasks JSON: %w", err)
        }</span>

        // Validate marshaled data is not empty
        <span class="cov0" title="0">if len(data) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("marshaled data is empty, refusing to overwrite tasks.json")
        }</span>

        // Use atomic write with backup strategy
        <span class="cov0" title="0">backupPath := s.tasksJSONPath + ".backup"
        tempPath := s.tasksJSONPath + ".tmp"

        // Create backup of existing file if it exists
        if _, err := os.Stat(s.tasksJSONPath); err == nil </span><span class="cov0" title="0">{
                if err := s.copyFile(s.tasksJSONPath, backupPath); err != nil </span><span class="cov0" title="0">{
                        lgr.Warn("Failed to create backup, proceeding without backup", zap.Error(err))
                }</span>
        }

        // Write to temporary file first
        <span class="cov0" title="0">if err := os.WriteFile(tempPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write temporary tasks JSON file: %w", err)
        }</span>

        // Atomic rename - this is the critical section
        <span class="cov0" title="0">if err := os.Rename(tempPath, s.tasksJSONPath); err != nil </span><span class="cov0" title="0">{
                // Clean up temporary file
                os.Remove(tempPath)
                return fmt.Errorf("failed to atomically move tasks JSON file: %w", err)
        }</span>

        // Remove backup after successful write
        <span class="cov0" title="0">os.Remove(backupPath)

        lgr.Debug("Tasks saved successfully",
                zap.String("path", s.tasksJSONPath),
                zap.Int("todo_count", tasksJSON.TodoCount()),
                zap.Int("done_count", tasksJSON.DoneCount()))

        return nil</span>
}

// copyFile copies a file from src to dst
func (s *Service) copyFile(src, dst string) error <span class="cov0" title="0">{
        sourceData, err := os.ReadFile(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return os.WriteFile(dst, sourceData, 0644)</span>
}

// MergeNewTasks loads existing tasks and merges them with new tasks
// This preserves todo and done state across collection cycles
func (s *Service) MergeNewTasks(ctx context.Context, newTasks *TasksJSON) (*TasksJSON, error) <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Load existing tasks
        existingTasks, err := s.LoadTasks(ctx)
        if err != nil </span><span class="cov0" title="0">{
                lgr.Warn("Failed to load existing tasks, using new tasks only", zap.Error(err))
                return newTasks, nil
        }</span>

        <span class="cov0" title="0">lgr.Debug("Merging tasks",
                zap.Int("existing_todo", existingTasks.TodoCount()),
                zap.Int("existing_done", existingTasks.DoneCount()),
                zap.Int("new_todo", newTasks.TodoCount()))

        // Create merged tasks starting with existing tasks
        mergedTasks := NewTasksJSON()

        // Preserve existing todo items
        for _, existingTodo := range existingTasks.Todo </span><span class="cov0" title="0">{
                mergedTasks.AddTodoTask(existingTodo)
        }</span>

        // Preserve existing done items
        <span class="cov0" title="0">for _, existingDone := range existingTasks.Done </span><span class="cov0" title="0">{
                mergedTasks.AddDoneTask(existingDone)
        }</span>

        // Add new todo items (avoid duplicates)
        <span class="cov0" title="0">for _, newTodo := range newTasks.Todo </span><span class="cov0" title="0">{
                if !mergedTasks.ContainsTodoTask(newTodo) </span><span class="cov0" title="0">{
                        mergedTasks.AddTodoTask(newTodo)
                }</span>
        }

        <span class="cov0" title="0">lgr.Info("Tasks merged successfully",
                zap.Int("final_todo_count", mergedTasks.TodoCount()),
                zap.Int("final_done_count", mergedTasks.DoneCount()),
                zap.Int("new_tasks_added", newTasks.TodoCount()))

        return mergedTasks, nil</span>
}

// AddNewTasksAndSave merges new tasks with existing ones and saves the result
func (s *Service) AddNewTasksAndSave(ctx context.Context, newTasks *TasksJSON) (*TasksJSON, error) <span class="cov0" title="0">{
        // Merge with existing tasks
        mergedTasks, err := s.MergeNewTasks(ctx, newTasks)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to merge tasks: %w", err)
        }</span>

        // Save the merged result
        <span class="cov0" title="0">if err := s.SaveTasks(ctx, mergedTasks); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save merged tasks: %w", err)
        }</span>

        <span class="cov0" title="0">return mergedTasks, nil</span>
}

// MarkTaskCompleted moves a task from todo to done
func (s *Service) MarkTaskCompleted(ctx context.Context, taskDescription string) error <span class="cov0" title="0">{
        lgr := logger.FromContext(ctx)

        // Load existing tasks
        tasksJSON, err := s.LoadTasks(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load tasks: %w", err)
        }</span>

        // Check if task exists in todo list
        <span class="cov0" title="0">if !tasksJSON.ContainsTodoTask(taskDescription) </span><span class="cov0" title="0">{
                lgr.Debug("Task not found in todo list, may have been already completed",
                        zap.String("task_description", taskDescription))
                return nil
        }</span>

        // Move task from todo to done
        <span class="cov0" title="0">tasksJSON.MoveToDone(taskDescription)

        // Save updated tasks
        if err := s.SaveTasks(ctx, tasksJSON); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save updated tasks: %w", err)
        }</span>

        <span class="cov0" title="0">lgr.Info("Task marked as completed",
                zap.String("task_description", taskDescription),
                zap.Int("remaining_todo_count", tasksJSON.TodoCount()),
                zap.Int("done_count", tasksJSON.DoneCount()))

        return nil</span>
}

// CreateEmpty creates an empty tasks.json file
func (s *Service) CreateEmpty(ctx context.Context) error <span class="cov0" title="0">{
        emptyTasks := NewTasksJSON()
        return s.SaveTasks(ctx, emptyTasks)
}</span>

// GetTasksPath returns the path to the tasks.json file
func (s *Service) GetTasksPath() string <span class="cov0" title="0">{
        return s.tasksJSONPath
}</span>

// ConvertToTaskList converts TasksJSON to legacy TaskList format for compatibility
func (s *Service) ConvertToTaskList(tasksJSON *TasksJSON) *TaskList <span class="cov0" title="0">{
        return ConvertTasksJSONToTaskList(tasksJSON)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package task

import (
        "time"
)

// Task represents a single actionable task
type Task struct {
        ID            string            `json:"id"`
        Type          string            `json:"type"`
        Priority      int               `json:"priority"`
        Title         string            `json:"title"`
        Description   string            `json:"description"`
        Platform      string            `json:"platform"`
        CompletionCmd string            `json:"completion_cmd"`
        Context       map[string]string `json:"context"`
        CreatedAt     time.Time         `json:"created_at"`
}

// TaskList represents a collection of tasks with metadata
type TaskList struct {
        Tasks     []Task    `json:"tasks"`
        Timestamp time.Time `json:"timestamp"`
}

// TasksJSON represents the JSON structure for task persistence
type TasksJSON struct {
        Todo []string `json:"todo"`
        Done []string `json:"done"`
}

// Priority constants
const (
        PriorityCritical = 1
        PriorityHigh     = 2
        PriorityMedium   = 3
        PriorityLow      = 4
)

// Common task types
const (
        TaskTypePRReview       = "pr_review"
        TaskTypeIssueAssigned  = "issue_assigned"
        TaskTypeMention        = "mention"
        TaskTypeSlackMessage   = "slack_message"
        TaskTypeFailedWorkflow = "failed_workflow"
        TaskTypeUnreadComment  = "unread_comment"
        TaskTypeGeneric        = "generic"
)

// Platform constants
const (
        PlatformGitHub  = "github"
        PlatformSlack   = "slack"
        PlatformJira    = "jira"
        PlatformGeneric = "generic"
)

// NewTask creates a new task with the current timestamp
func NewTask(id, taskType, title, description, platform, completionCmd string, priority int) *Task <span class="cov0" title="0">{
        return &amp;Task{
                ID:            id,
                Type:          taskType,
                Priority:      priority,
                Title:         title,
                Description:   description,
                Platform:      platform,
                CompletionCmd: completionCmd,
                Context:       make(map[string]string),
                CreatedAt:     time.Now(),
        }
}</span>

// NewTaskList creates a new task list with the current timestamp
func NewTaskList() *TaskList <span class="cov0" title="0">{
        return &amp;TaskList{
                Tasks:     make([]Task, 0),
                Timestamp: time.Now(),
        }
}</span>

// AddTask adds a task to the task list
func (tl *TaskList) AddTask(task Task) <span class="cov0" title="0">{
        tl.Tasks = append(tl.Tasks, task)
}</span>

// GetHighestPriorityTask returns the task with the highest priority (lowest number)
func (tl *TaskList) GetHighestPriorityTask() *Task <span class="cov0" title="0">{
        if len(tl.Tasks) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">highestPriorityTask := &amp;tl.Tasks[0]
        for i := 1; i &lt; len(tl.Tasks); i++ </span><span class="cov0" title="0">{
                if tl.Tasks[i].Priority &lt; highestPriorityTask.Priority </span><span class="cov0" title="0">{
                        highestPriorityTask = &amp;tl.Tasks[i]
                }</span>
        }

        <span class="cov0" title="0">return highestPriorityTask</span>
}

// FilterByPriority returns tasks with the specified priority
func (tl *TaskList) FilterByPriority(priority int) []Task <span class="cov0" title="0">{
        var filtered []Task
        for _, task := range tl.Tasks </span><span class="cov0" title="0">{
                if task.Priority == priority </span><span class="cov0" title="0">{
                        filtered = append(filtered, task)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

// FilterByType returns tasks with the specified type
func (tl *TaskList) FilterByType(taskType string) []Task <span class="cov0" title="0">{
        var filtered []Task
        for _, task := range tl.Tasks </span><span class="cov0" title="0">{
                if task.Type == taskType </span><span class="cov0" title="0">{
                        filtered = append(filtered, task)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

// FilterByPlatform returns tasks from the specified platform
func (tl *TaskList) FilterByPlatform(platform string) []Task <span class="cov0" title="0">{
        var filtered []Task
        for _, task := range tl.Tasks </span><span class="cov0" title="0">{
                if task.Platform == platform </span><span class="cov0" title="0">{
                        filtered = append(filtered, task)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

// Count returns the total number of tasks
func (tl *TaskList) Count() int <span class="cov0" title="0">{
        return len(tl.Tasks)
}</span>

// IsEmpty returns true if there are no tasks
func (tl *TaskList) IsEmpty() bool <span class="cov0" title="0">{
        return len(tl.Tasks) == 0
}</span>

// NewTasksJSON creates a new empty TasksJSON structure
func NewTasksJSON() *TasksJSON <span class="cov0" title="0">{
        return &amp;TasksJSON{
                Todo: make([]string, 0),
                Done: make([]string, 0),
        }
}</span>

// AddTodoTask adds a task to the todo list
func (tj *TasksJSON) AddTodoTask(task string) <span class="cov0" title="0">{
        if task != "" </span><span class="cov0" title="0">{
                tj.Todo = append(tj.Todo, task)
        }</span>
}

// MoveToDone moves a task from todo to done
func (tj *TasksJSON) MoveToDone(task string) <span class="cov0" title="0">{
        // Remove from todo
        for i, todoTask := range tj.Todo </span><span class="cov0" title="0">{
                if todoTask == task </span><span class="cov0" title="0">{
                        tj.Todo = append(tj.Todo[:i], tj.Todo[i+1:]...)
                        break</span>
                }
        }
        // Add to done
        <span class="cov0" title="0">tj.Done = append(tj.Done, task)</span>
}

// HasTasks returns true if there are any tasks (todo or done)
func (tj *TasksJSON) HasTasks() bool <span class="cov0" title="0">{
        return len(tj.Todo) &gt; 0 || len(tj.Done) &gt; 0
}</span>

// TodoCount returns the number of todo tasks
func (tj *TasksJSON) TodoCount() int <span class="cov0" title="0">{
        return len(tj.Todo)
}</span>

// DoneCount returns the number of done tasks
func (tj *TasksJSON) DoneCount() int <span class="cov0" title="0">{
        return len(tj.Done)
}</span>

// AddDoneTask adds a task to the done list
func (tj *TasksJSON) AddDoneTask(task string) <span class="cov0" title="0">{
        if task != "" </span><span class="cov0" title="0">{
                tj.Done = append(tj.Done, task)
        }</span>
}

// ContainsTodoTask checks if a task is already in the todo list
func (tj *TasksJSON) ContainsTodoTask(task string) bool <span class="cov0" title="0">{
        for _, todoTask := range tj.Todo </span><span class="cov0" title="0">{
                if todoTask == task </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package testutil

import (
        "os"
        "path/filepath"
        "testing"
)

// CreateTempDir creates a temporary directory for testing
func CreateTempDir(t *testing.T) string <span class="cov0" title="0">{
        t.Helper()

        tempDir, err := os.MkdirTemp("", "autoteam-test-*")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create temp dir: %v", err)
        }</span>

        <span class="cov0" title="0">t.Cleanup(func() </span><span class="cov0" title="0">{
                os.RemoveAll(tempDir)
        }</span>)

        <span class="cov0" title="0">return tempDir</span>
}

// CreateTempFile creates a temporary file with content for testing
func CreateTempFile(t *testing.T, dir, filename, content string) string <span class="cov0" title="0">{
        t.Helper()

        filepath := filepath.Join(dir, filename)
        if err := os.WriteFile(filepath, []byte(content), 0600); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to create temp file %s: %v", filepath, err)
        }</span>

        <span class="cov0" title="0">return filepath</span>
}

// FileExists checks if a file exists
func FileExists(path string) bool <span class="cov0" title="0">{
        _, err := os.Stat(path)
        return !os.IsNotExist(err)
}</span>

// DirExists checks if a directory exists
func DirExists(path string) bool <span class="cov0" title="0">{
        info, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return info.IsDir()</span>
}

// ReadFile reads file content for testing
func ReadFile(t *testing.T, path string) string <span class="cov0" title="0">{
        t.Helper()

        content, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to read file %s: %v", path, err)
        }</span>

        <span class="cov0" title="0">return string(content)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
